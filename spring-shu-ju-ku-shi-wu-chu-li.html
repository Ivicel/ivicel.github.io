
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index, follow" />

  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:300,400,400i,700" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="./theme/pygments/manni.min.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/font-awesome.min.css">

    <link href="./static/custom.css" rel="stylesheet">



    <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/images/favicon.ico" type="image/x-icon">

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-113622715-2', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->

<meta name="author" content="ivicel" />
<meta name="description" content="1. 事务的传播行为 事务的传播行为是 Spring 对数据库事务添加的特定功能, 指的是当方法 A 调用另一个方法 B 时, B 事务中所采取的不同策略的行为, 比如新建事务, 挂起事务等. 事务的传播注解修饰的是方法 B 自己, 当被别的方法调用时才起的作用, 而不是方法内起作用 1.1 Spring 中七种事务传播行为 事务传播行为类型 说明 PROPAGATION_REQUIRED 1. 如果当前没有事务, 则新建一个事务2. 有的话就则加入到这个事务中 PROPAGATION_SUPPORTS 有则沿用, 没有也不新建1. 如果当前存在事务, 则沿用当前事务 2. 如果当前没有事务, 就以非事务方式运行 PROPAGATION_MANDATORY 确保必须使用当前事务1. 如果当前存在, 使用当前事务. 2. 如果当前没有事务, 就抛出异常 PROPAGATION_REQUIRES_NEW 总是新建自己事务 …" />
<meta name="keywords" content="spring 事务, spring 开发, 事务传播">

<meta property="og:site_name" content="Ivicel's Ambertime"/>
<meta property="og:title" content="Spring 数据库事务处理"/>
<meta property="og:description" content="1. 事务的传播行为 事务的传播行为是 Spring 对数据库事务添加的特定功能, 指的是当方法 A 调用另一个方法 B 时, B 事务中所采取的不同策略的行为, 比如新建事务, 挂起事务等. 事务的传播注解修饰的是方法 B 自己, 当被别的方法调用时才起的作用, 而不是方法内起作用 1.1 Spring 中七种事务传播行为 事务传播行为类型 说明 PROPAGATION_REQUIRED 1. 如果当前没有事务, 则新建一个事务2. 有的话就则加入到这个事务中 PROPAGATION_SUPPORTS 有则沿用, 没有也不新建1. 如果当前存在事务, 则沿用当前事务 2. 如果当前没有事务, 就以非事务方式运行 PROPAGATION_MANDATORY 确保必须使用当前事务1. 如果当前存在, 使用当前事务. 2. 如果当前没有事务, 就抛出异常 PROPAGATION_REQUIRES_NEW 总是新建自己事务 …"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="./spring-shu-ju-ku-shi-wu-chu-li.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2019-01-12 00:00:00+08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="./author/ivicel.html">
<meta property="article:section" content="Java"/>
<meta property="article:tag" content="spring 事务"/>
<meta property="article:tag" content="spring 开发"/>
<meta property="article:tag" content="事务传播"/>
<meta property="og:image" content="/images/favicon.ico">

  <title>Ivicel's Ambertime &ndash; Spring 数据库事务处理</title>

</head>
<body>
  <aside>
    <div>
      <a href=".">
        <img src="/images/favicon.ico" alt="Ambertime" title="Ambertime">
      </a>
      <h1><a href=".">Ambertime</a></h1>

<p>Make memory in past times</p>

      <ul class="social">
      </ul>
    </div>


  </aside>
  <main>

    <nav>
      <a href=".">Home</a>



    </nav>

<article class="single">
  <header>
      
    <h1 id="spring-shu-ju-ku-shi-wu-chu-li">Spring 数据库事务处理</h1>
    <p>
      Posted on Sat 12 January 2019 in <a href="./category/java.html">Java</a>

    </p>
  </header>


  <div>
    <h4 id="1">1. 事务的传播行为</h4>
<p>事务的传播行为是 Spring 对数据库事务添加的特定功能, 指的是当方法 A 调用另一个方法 B 时, B 事务中所采取的不同策略的行为, 比如新建事务, 挂起事务等. 事务的传播注解修饰的是方法 B 自己, 当被别的方法调用时才起的作用, 而不是方法内起作用</p>
<h4 id="11-spring">1.1 Spring 中七种事务传播行为</h4>
<table>
<thead>
<tr>
<th>事务传播行为类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>PROPAGATION_REQUIRED</code></strong></td>
<td>1. 如果当前没有事务, 则新建一个事务<br />2. 有的话就则加入到这个事务中</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>有则沿用, 没有也不新建<br />1. 如果当前存在事务, 则沿用当前事务 <br />2. 如果当前没有事务, 就以非事务方式运行</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>确保必须使用当前事务<br />1. 如果当前存在, 使用当前事务. <br />2. 如果当前没有事务, 就抛出异常</td>
</tr>
<tr>
<td><strong><code>PROPAGATION_REQUIRES_NEW</code></strong></td>
<td>总是新建自己事务, 这样新事务总是拥有新的锁和隔离级别等特性, 如果当前存在事务, 先把当前事务挂起.</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>确保以非事务运行<br />1. 当前不存在事务, 以非事务方式运行<br />2. 如果当前存在事务则先挂起当前事务, 以非事务运行</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>确保当前没有事务<br />1. 以非事务方式运行<br />2. 如果当前存在事务则抛出异常</td>
</tr>
<tr>
<td><strong><code>PROPAGATION_NESTED</code></strong></td>
<td>1. 如果当前存在事务, 是嵌套在事务内运行<br />2. 如果当前没有事务, 创建新的事务来运行, 但与 <code>PROPAGATION_REQUIRED</code> 不同的是, 内部方法发生的异常不会当前方法的 SQL</td>
</tr>
</tbody>
</table>
<blockquote>
<p>加<strong>黑体</strong>的三个是常用的</p>
</blockquote>
<h4 id="2">2. 传播行为的代码测试</h4>
<p>在数据库中有两张表 <code>t_user1</code> 和 <code>t_user2</code>, 以及对应 POJO, 简单的 Service 操作</p>
<blockquote>
<p>下方所有的 <code>test*()</code> 方法都应该在不在 <code>User1Service</code> 或 <code>User2Service</code> 类内, 避免产生类内自调用</p>
</blockquote>
<div class="codehilite"><pre><span></span><span class="c1">// 表 t_user1 对应的 POJO</span>
<span class="kd">public</span> <span class="n">Class</span> <span class="n">User1</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="n">Long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="c1">// getters and setters...</span>
<span class="o">}</span>

<span class="c1">// 表 t_user2 对应的 POJO</span>
<span class="kd">public</span> <span class="n">Class</span> <span class="n">User2</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="n">Long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="c1">// getters and setters...</span>
<span class="o">}</span>
</pre></div>


<h5 id="21-propagation_required">2.1 <code>PROPAGATION_REQUIRED</code> 行为</h5>
<div class="codehilite"><pre><span></span><span class="c1">// user1 和 user2 的 service 的插入操作都在事务中, 传播都为 PROPAGATION_REQUIRED</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">User1Service</span> <span class="o">{</span>
        <span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="n">Propagation</span><span class="o">.</span><span class="na">REQUIRED</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addRequired</span><span class="o">(</span><span class="n">User1</span> <span class="n">user1</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Mybatais mapper: insert into `t_user1` (`name`) values (#name)</span>
        <span class="n">user1Mapper</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">user1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">User2Service</span> <span class="o">{</span>
        <span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="n">Propagation</span><span class="o">.</span><span class="na">REQUIRED</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addRequired</span><span class="o">(</span><span class="n">User2</span> <span class="n">user2</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">user2Mapper</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="n">Propagation</span><span class="o">.</span><span class="na">REQUIRED</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addRequiredWithException</span><span class="o">(</span><span class="n">User2</span> <span class="n">user2</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">user2Mapper</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="s">&quot;手动抛出异常&quot;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>在外围非事务的方法中调用, 各个事务都是相对独立的, 成功或失败都不互相干扰</li>
</ul>
<div class="codehilite"><pre><span></span><span class="c1">// 测试一</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test1</span><span class="o">(){</span>
    <span class="n">User1</span> <span class="n">user1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User1</span><span class="o">();</span>
    <span class="n">user1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;张三&quot;</span><span class="o">);</span>
    <span class="n">user1Service</span><span class="o">.</span><span class="na">addRequired</span><span class="o">(</span><span class="n">user1</span><span class="o">);</span>

    <span class="n">User2</span> <span class="n">user2</span><span class="o">=</span><span class="k">new</span> <span class="n">User2</span><span class="o">();</span>
    <span class="n">user2</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;李四&quot;</span><span class="o">);</span>
    <span class="n">user2Service</span><span class="o">.</span><span class="na">addRequired</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>
        <span class="c1">// 即使在最后抛出异常, 上面的两个独立事务都插入成功</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 测试二</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test2</span><span class="o">(){</span>
    <span class="n">User1</span> <span class="n">user1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User1</span><span class="o">();</span>
    <span class="n">user1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;张三&quot;</span><span class="o">);</span>
    <span class="n">user1Service</span><span class="o">.</span><span class="na">addRequired</span><span class="o">(</span><span class="n">user1</span><span class="o">);</span>

    <span class="n">User2</span> <span class="n">user2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User2</span><span class="o">();</span>
    <span class="n">user2</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;李四&quot;</span><span class="o">);</span>
      <span class="c1">// 在 user2Service 抛出异常, </span>
    <span class="c1">// 但 user1Service, user2Service 是两个独立事务,</span>
    <span class="c1">// 所以 user1Service 插入成功, user2Service 失败</span>
    <span class="n">user2Service</span><span class="o">.</span><span class="na">addRequiredWithException</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>在外围调用方法是开启事务时, 这时的要将被调用方法加入到这个事务当中而不是自己新创建事务</li>
</ul>
<div class="codehilite"><pre><span></span><span class="c1">// 三个测试都开启了事务</span>

<span class="c1">// 测试一</span>
<span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test1</span><span class="o">(){</span>
    <span class="n">User1</span> <span class="n">user1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User1</span><span class="o">();</span>
    <span class="n">user1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;张三&quot;</span><span class="o">);</span>
    <span class="n">user1Service</span><span class="o">.</span><span class="na">addRequired</span><span class="o">(</span><span class="n">user1</span><span class="o">);</span>

    <span class="n">User2</span> <span class="n">user2</span><span class="o">=</span><span class="k">new</span> <span class="n">User2</span><span class="o">();</span>
    <span class="n">user2</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;李四&quot;</span><span class="o">);</span>
    <span class="n">user2Service</span><span class="o">.</span><span class="na">addRequired</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>
        <span class="c1">// user1Service, user2Service 都加入了当前方法的同一事务当中</span>
    <span class="c1">// 所以最后事务抛出异常时, 所有的插入都失败</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 测试二</span>
<span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test2</span><span class="o">(){</span>
    <span class="n">User1</span> <span class="n">user1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User1</span><span class="o">();</span>
    <span class="n">user1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;张三&quot;</span><span class="o">);</span>
    <span class="n">user1Service</span><span class="o">.</span><span class="na">addRequired</span><span class="o">(</span><span class="n">user1</span><span class="o">);</span>

    <span class="n">User2</span> <span class="n">user2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User2</span><span class="o">();</span>
    <span class="n">user2</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;李四&quot;</span><span class="o">);</span>
      <span class="c1">// user1Service, user2Service 都加入了当前方法的同一事务当中</span>
    <span class="c1">// 当内部方法抛出异常时, 事务回滚, 则所有的插入都失败</span>
    <span class="n">user2Service</span><span class="o">.</span><span class="na">addRequiredWithException</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 测试三</span>
<span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test2</span><span class="o">(){</span>
    <span class="n">User1</span> <span class="n">user1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User1</span><span class="o">();</span>
    <span class="n">user1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;张三&quot;</span><span class="o">);</span>
    <span class="c1">// 依赖外围方法事务, 成功插入</span>
    <span class="n">user1Service</span><span class="o">.</span><span class="na">addRequired</span><span class="o">(</span><span class="n">user1</span><span class="o">);</span>

    <span class="n">User2</span> <span class="n">user2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User2</span><span class="o">();</span>
    <span class="n">user2</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;李四&quot;</span><span class="o">);</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// user1Service, user2Service 都加入了当前方法的同一事务当中</span>
            <span class="c1">// 当内部方法抛出异常时, 在外围方法捕获, 处理了这些异常, 事务还是成功的</span>
        <span class="c1">// user2 插入失败</span>
            <span class="n">user2Service</span><span class="o">.</span><span class="na">addRequiredWithException</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h5 id="22-propagation_required_new">2.2 <code>PROPAGATION_REQUIRED_NEW</code> 行为</h5>
<div class="codehilite"><pre><span></span><span class="c1">// user1 和 user2 的 service 的插入操作都在事务中</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">User1Service</span> <span class="o">{</span>
        <span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="n">Propagation</span><span class="o">.</span><span class="na">REQUIRES_NEW</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addRequiresNew</span><span class="o">(</span><span class="n">User1</span> <span class="n">user1</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Mybatais mapper: insert into `t_user1` (`name`) values (#name)</span>
        <span class="n">user1Mapper</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">user1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="n">Propagation</span><span class="o">.</span><span class="na">REQUIRED</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addRequired</span><span class="o">(</span><span class="n">User1</span> <span class="n">user1</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Mybatais mapper: insert into `t_user1` (`name`) values (#name)</span>
        <span class="n">user1Mapper</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">user1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">User2Service</span> <span class="o">{</span>
        <span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="n">Propagation</span><span class="o">.</span><span class="na">REQUIRES_NEW</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addRequiresNew</span><span class="o">(</span><span class="n">User2</span> <span class="n">user2</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">user2Mapper</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="n">Propagation</span><span class="o">.</span><span class="na">REQUIRES_NEW</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addRequiresNewWithException</span><span class="o">(</span><span class="n">User2</span> <span class="n">user2</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">user2Mapper</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="s">&quot;手动抛出异常&quot;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>外围调用方法没有添加事务</li>
</ul>
<div class="codehilite"><pre><span></span><span class="c1">// 测试一</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">User1</span> <span class="n">user1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User1</span><span class="o">();</span>
    <span class="n">user1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;张三&quot;</span><span class="o">);</span>
    <span class="n">user1Service</span><span class="o">.</span><span class="na">addRequiresNew</span><span class="o">(</span><span class="n">user1</span><span class="o">);</span>

    <span class="n">User2</span> <span class="n">user2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User2</span><span class="o">();</span>
    <span class="n">user2</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;李四&quot;</span><span class="o">);</span>
    <span class="n">user2Service</span><span class="o">.</span><span class="na">addRequiresNew</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>
    <span class="c1">// 调用方法抛出异常, 但两个内部方法都是自己很生成自己的事务, 互不影响, 都成功插入新数据</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 测试二</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test2</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">User1</span> <span class="n">user1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User1</span><span class="o">();</span>
    <span class="n">user1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;张三&quot;</span><span class="o">);</span>
    <span class="c1">// 内部方法一独立的事务, 成功插入新数据</span>
    <span class="n">user1Service</span><span class="o">.</span><span class="na">addRequiresNew</span><span class="o">(</span><span class="n">user1</span><span class="o">);</span>

    <span class="n">User2</span> <span class="n">user2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User2</span><span class="o">();</span>
    <span class="n">user2</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;李四&quot;</span><span class="o">);</span>
    <span class="c1">// 内部方法二自己抛出异常, 自回滚自己的事务</span>
    <span class="n">user2Service</span><span class="o">.</span><span class="na">addRequiresNewWithException</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>外围调用方法是在事务中</li>
</ul>
<div class="codehilite"><pre><span></span><span class="c1">// 测试一, 测试外围事务的异常对内部方法的影响</span>
<span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">User1</span> <span class="n">user1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User1</span><span class="o">();</span>
    <span class="n">user1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;张三&quot;</span><span class="o">);</span>
    <span class="c1">// Propagation.REQUIRED 会加入到外部事务中, 外部事务回滚则插入失败</span>
    <span class="n">user1Service</span><span class="o">.</span><span class="na">addRequired</span><span class="o">(</span><span class="n">user1</span><span class="o">);</span>

    <span class="n">User2</span> <span class="n">user2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User2</span><span class="o">();</span>
    <span class="n">user2</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;李四&quot;</span><span class="o">);</span>
    <span class="c1">// Propagation.REQUIRED_NEW 会自己创建新的事务来运行, 无论外部事务如何, 插入数据成功</span>
    <span class="n">user2Service</span><span class="o">.</span><span class="na">addRequiresNew</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>
        <span class="c1">// 外围事务回滚</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">();</span>
<span class="o">}</span>
<span class="c1">// 测试二, 测试内部方法在自己新创建的事务对其他内部方法的影响</span>
<span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test2</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">User1</span> <span class="n">user1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User1</span><span class="o">();</span>
    <span class="n">user1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;张三&quot;</span><span class="o">);</span>
    <span class="c1">// 依赖外围事务, 插入失败</span>
    <span class="n">user1Service</span><span class="o">.</span><span class="na">addRequired</span><span class="o">(</span><span class="n">user1</span><span class="o">);</span>

    <span class="n">User2</span> <span class="n">user2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User2</span><span class="o">();</span>
    <span class="n">user2</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;李四&quot;</span><span class="o">);</span>
    <span class="c1">// 自己新创建事务, 插入成功</span>
    <span class="n">user2Service</span><span class="o">.</span><span class="na">addRequiresNew</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>

    <span class="n">User2</span> <span class="n">user3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User2</span><span class="o">();</span>
    <span class="n">user3</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;王五&quot;</span><span class="o">);</span>
    <span class="c1">// 自己新创建事务, 抛出异常, 并且异常向调用方法抛出, 自已的事务回滚, 外围事务也回滚</span>
    <span class="n">user2Service</span><span class="o">.</span><span class="na">addRequiresNewWithException</span><span class="o">(</span><span class="n">user3</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 测试三, 与测试二惟一不同的是, 新创建的事务向外围抛出的异常在外围事务中捕获并处理了</span>
<span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test3</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">User1</span> <span class="n">user1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User1</span><span class="o">();</span>
    <span class="n">user1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;张三&quot;</span><span class="o">);</span>
    <span class="c1">// 插入成功, 依赖外围事务</span>
    <span class="n">user1Service</span><span class="o">.</span><span class="na">addRequired</span><span class="o">(</span><span class="n">user1</span><span class="o">);</span>

    <span class="n">User2</span> <span class="n">user2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User2</span><span class="o">();</span>
    <span class="n">user2</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;李四&quot;</span><span class="o">);</span>
    <span class="c1">// 插入成功, 自己新创建的事务</span>
    <span class="n">user2Service</span><span class="o">.</span><span class="na">addRequiresNew</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>

    <span class="n">User2</span> <span class="n">user3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User2</span><span class="o">();</span>
    <span class="n">user3</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;王五&quot;</span><span class="o">);</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// 插入失败, 自己创建的事务, 然后把异常抛到了外围方法, 在这里处理了异常</span>
        <span class="n">user2Service</span><span class="o">.</span><span class="na">addRequiresNewWithException</span><span class="o">(</span><span class="n">user3</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h5 id="23-propagation_nested">2.3 <code>PROPAGATION_NESTED</code> 行为</h5>
<p>该行为在外围开启事务时, 内部方法嵌套在外围事务中运行, 外围事务的回溯导致内部方法也一起回滚; 而内部方法的事务则可以自己单独回滚, 不用影响到外围的事务</p>
<blockquote>
<p><code>PROPAGATION_NESTED</code> 事务嵌套行为需要数据库中的<strong>保存点(save point)</strong>, Hibernate 并不支持这个功能, 会抛出: <code>JpaDialect does not support savepoints - check your JPA provider's capabilities</code> 异常</p>
</blockquote>
<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User1Service</span> <span class="o">{</span>
        <span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="n">Propagation</span><span class="o">.</span><span class="na">NESTED</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addNested</span><span class="o">(</span><span class="n">User1</span> <span class="n">user1</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">user1Mapper</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">user1</span><span class="o">);</span>
    <span class="o">}</span> 
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">User2Service</span> <span class="o">{</span>
    <span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="n">Propagation</span><span class="o">.</span><span class="na">NESTED</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addNested</span><span class="o">(</span><span class="n">User2</span> <span class="n">user2</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">user2Mapper</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="n">Propagation</span><span class="o">.</span><span class="na">NESTED</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addNestedWithException</span><span class="o">(</span><span class="n">User2</span> <span class="n">user2</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">user2Mapper</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="s">&quot;抛出异常&quot;</span><span class="o">);</span>
    <span class="o">}</span>  
<span class="o">}</span>
</pre></div>


<ul>
<li>外围方法没有开启事务</li>
</ul>
<div class="codehilite"><pre><span></span><span class="c1">// 测试一, 外围方法抛出异常</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">User1</span> <span class="n">user1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User1</span><span class="o">();</span>
    <span class="n">user1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;张三&quot;</span><span class="o">);</span>
    <span class="c1">// 创建新事务, 插入成功</span>
    <span class="n">user1Service</span><span class="o">.</span><span class="na">addNested</span><span class="o">(</span><span class="n">user1</span><span class="o">);</span>

    <span class="n">User2</span> <span class="n">user2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User2</span><span class="o">();</span>
    <span class="n">user2</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;李四&quot;</span><span class="o">);</span>
    <span class="c1">// 创建新事务, 插入成功</span>
    <span class="n">user2Service</span><span class="o">.</span><span class="na">addNested</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>
    <span class="c1">// 外围抛出的异常</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 测试二, 内部方法抛出异常</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test2</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">User1</span> <span class="n">user1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User1</span><span class="o">();</span>
    <span class="n">user1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;张三&quot;</span><span class="o">);</span>
    <span class="c1">// 创建新事务, 插入成功</span>
    <span class="n">user1Service</span><span class="o">.</span><span class="na">addNested</span><span class="o">(</span><span class="n">user1</span><span class="o">);</span>

    <span class="n">User2</span> <span class="n">user2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User2</span><span class="o">();</span>
    <span class="n">user2</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;李四&quot;</span><span class="o">);</span>
    <span class="c1">// 创建新事务, 自己回滚事务, 插入失败</span>
    <span class="n">user2Service</span><span class="o">.</span><span class="na">addNestedWithException</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>外围方法开启事务</li>
</ul>
<div class="codehilite"><pre><span></span><span class="c1">// 测试一, 外围方法抛出异常</span>
<span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">User1</span> <span class="n">user1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User1</span><span class="o">();</span>
    <span class="n">user1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;张三&quot;</span><span class="o">);</span>
    <span class="c1">// 创建新事务, 嵌套在外围事务中, 插入失败</span>
    <span class="n">user1Service</span><span class="o">.</span><span class="na">addNested</span><span class="o">(</span><span class="n">user1</span><span class="o">);</span>

    <span class="n">User2</span> <span class="n">user2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User2</span><span class="o">();</span>
    <span class="n">user2</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;李四&quot;</span><span class="o">);</span>
      <span class="c1">// 创建新事务, 嵌套在外围事务中, 插入失败</span>
    <span class="n">user2Service</span><span class="o">.</span><span class="na">addNested</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>
    <span class="c1">// 外围事务的回滚影响内部方法的事务</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 测试二, 内部方法抛出异常</span>
<span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test2</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">User1</span> <span class="n">user1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User1</span><span class="o">();</span>
    <span class="n">user1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;张三&quot;</span><span class="o">);</span>
    <span class="c1">// 创建新事务, 嵌套在外围事务中, 插入失败</span>
    <span class="n">user1Service</span><span class="o">.</span><span class="na">addNested</span><span class="o">(</span><span class="n">user1</span><span class="o">);</span>

    <span class="n">User2</span> <span class="n">user2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User2</span><span class="o">();</span>
    <span class="n">user2</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;李四&quot;</span><span class="o">);</span>
      <span class="c1">// 内部方法的异常抛到了外围事务中, 所有的插入都失败</span>
    <span class="n">user2Service</span><span class="o">.</span><span class="na">addNestedWithException</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 测试三, 内部方法抛出异常并有外围捕获</span>
<span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test2</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">User1</span> <span class="n">user1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User1</span><span class="o">();</span>
    <span class="n">user1</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;张三&quot;</span><span class="o">);</span>
    <span class="c1">// 创建新事务, 嵌套在外围事务中, 插入成功</span>
    <span class="n">user1Service</span><span class="o">.</span><span class="na">addNested</span><span class="o">(</span><span class="n">user1</span><span class="o">);</span>

    <span class="n">User2</span> <span class="n">user2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User2</span><span class="o">();</span>
    <span class="n">user2</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;李四&quot;</span><span class="o">);</span>
      <span class="c1">// 内部方法的异常抛到了外围事务中并被处理, 内部方法插入失败</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">user2Service</span><span class="o">.</span><span class="na">addNestedWithException</span><span class="o">(</span><span class="n">user2</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>
</pre></div>


<h4 id="2-transactional">2. <code>@Transactional</code> 自调用类中方法失效问题</h4>
<p>Spring 的事务处理是基于 AOP, 通过动态代理生成一个类的代理对象, 而当我们在类的方法中再调用同一个类的事务方法, 其实际还是在同一个事务中, 是类自身的调用, 而不是代理调用, 这样就还是在同一次 AOP 中.</p>
<div class="codehilite"><pre><span></span><span class="nd">@Service</span><span class="o">(</span><span class="s">&quot;userService&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserServiceImple</span> <span class="kd">implements</span> <span class="n">IUserService</span> <span class="o">{</span>
        <span class="nd">@Override</span>
    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insertUsers</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">User</span> <span class="n">user</span> <span class="o">:</span> <span class="n">users</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 调用自已类自身的方法, 还是处于同一 AOP 处理中</span>
                <span class="n">insertUser</span><span class="o">(</span><span class="n">user</span><span class="o">);</span> 
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="n">Propagation</span><span class="o">.</span><span class="na">REQUIRES_NEW</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insertUser</span><span class="o">(</span><span class="n">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">userMapper</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">user</span><span class="o">);</span> 
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>也可以通过手动每次获取类的代理对象, 来手动调用类的方法</p>
<div class="codehilite"><pre><span></span><span class="nd">@Service</span><span class="o">(</span><span class="s">&quot;userService&quot;</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserServiceImple</span> <span class="kd">implements</span> <span class="n">IUserService</span><span class="o">,</span> <span class="n">ApplicationContextAware</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">ApplicationContext</span> <span class="n">applicationContext</span><span class="o">;</span>

        <span class="nd">@Override</span>
    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insertUsers</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 从 IoC 容器中取出代理对象</span>
        <span class="n">IUserService</span> <span class="n">userService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="n">IUserService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">User</span> <span class="n">user</span> <span class="o">:</span> <span class="n">users</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 使用代理对象来调用类方法, 这样总是能通过 AOP</span>
                <span class="n">userService</span><span class="o">.</span><span class="na">insertUser</span><span class="o">(</span><span class="n">user</span><span class="o">);</span> 
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="n">Propagation</span><span class="o">.</span><span class="na">REQUIRES_NEW</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insertUser</span><span class="o">(</span><span class="n">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">userMapper</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">user</span><span class="o">);</span> 
    <span class="o">}</span>

    <span class="c1">// spring 框架在扫描包时, 会对生成的 bean 检查其是否实现了 ApplicationContextAware 接口</span>
    <span class="c1">// 如果实际了则会调用 setApplicationContext 方法, 并把当前 Spring 上下文容器作为参数</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setApplicationContext</span><span class="o">(</span><span class="n">ApplicationContext</span> <span class="n">applicationContext</span><span class="o">)</span> 
                <span class="kd">throws</span> <span class="n">BeansException</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">applicationContext</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="./tag/spring-shi-wu.html">spring 事务</a>
      <a href="./tag/spring-kai-fa.html">spring 开发</a>
      <a href="./tag/shi-wu-chuan-bo.html">事务传播</a>
    </p>
  </div>





</article>

    <footer>
<p>
  &copy;  2018 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Powered by <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
           src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>




<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Ivicel's Ambertime ",
  "url" : ".",
  "image": "/images/favicon.ico",
  "description": "ivicel's thoughts and writings"
}
</script>

</body>
</html>