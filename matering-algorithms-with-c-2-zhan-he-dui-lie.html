
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index, follow" />

  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:300,400,400i,700" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="./theme/pygments/manni.min.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/font-awesome.min.css">

    <link href="./static/custom.css" rel="stylesheet">



    <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/images/favicon.ico" type="image/x-icon">

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-113622715-2', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->

<meta name="author" content="ivicel" />
<meta name="description" content="栈: 后进先出(LIFO) 队列: 先进先出(FIFO) 栈和队列的一些应用 信号量: 同步多个进程访问共享资源 事件处理 X Window 系统, 使用队列来存储事件 生产者-消费者问题, 生产者向队列中写入数据, 消费从队列中读出数据 C 函数的调用, 函数的调用会将一些信息压入程序栈, 程序结束时将信息出栈 栈最常用的是使用链表来实现, 以下是栈的抽象数据类型头文件 /* stack.h */ #ifndef STACK_H #define STACK_H /* 元素结点 */ typedef struct StackElmt_ { void *data; struct StackElmt_ *next; }StackElmt; /* 栈结构 */ typedef struct Stack_ { /* 栈大小 */ int size; /* 指向栈顶结点 */ StackElmt *top; void …" />
<meta name="keywords" content="算法, C, 栈, 队列, 数据结构">

<meta property="og:site_name" content="Ivicel\s Ambertime"/>
<meta property="og:title" content="Matering Algorithms with C-2: 栈和队列"/>
<meta property="og:description" content="栈: 后进先出(LIFO) 队列: 先进先出(FIFO) 栈和队列的一些应用 信号量: 同步多个进程访问共享资源 事件处理 X Window 系统, 使用队列来存储事件 生产者-消费者问题, 生产者向队列中写入数据, 消费从队列中读出数据 C 函数的调用, 函数的调用会将一些信息压入程序栈, 程序结束时将信息出栈 栈最常用的是使用链表来实现, 以下是栈的抽象数据类型头文件 /* stack.h */ #ifndef STACK_H #define STACK_H /* 元素结点 */ typedef struct StackElmt_ { void *data; struct StackElmt_ *next; }StackElmt; /* 栈结构 */ typedef struct Stack_ { /* 栈大小 */ int size; /* 指向栈顶结点 */ StackElmt *top; void …"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="./matering-algorithms-with-c-2-zhan-he-dui-lie.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2017-03-22 00:00:00+08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="./author/ivicel.html">
<meta property="article:section" content="Data Structure Algorithms"/>
<meta property="article:tag" content="算法"/>
<meta property="article:tag" content="C"/>
<meta property="article:tag" content="栈"/>
<meta property="article:tag" content="队列"/>
<meta property="article:tag" content="数据结构"/>
<meta property="og:image" content="/images/favicon.ico">

  <title>Ivicel\s Ambertime &ndash; Matering Algorithms with C-2: 栈和队列</title>

</head>
<body>
  <aside>
    <div>
      <a href=".">
        <img src="/images/favicon.ico" alt="Ambertime" title="Ambertime">
      </a>
      <h1><a href=".">Ambertime</a></h1>

<p>Make memory in past times</p>

      <ul class="social">
      </ul>
    </div>


  </aside>
  <main>

    <nav>
      <a href=".">Home</a>



    </nav>

<article class="single">
  <header>
      
    <h1 id="matering-algorithms-with-c-2-zhan-he-dui-lie">Matering Algorithms with C-2: 栈和队列</h1>
    <p>
      Posted on Wed 22 March 2017 in <a href="./category/data-structure-algorithms.html">Data Structure Algorithms</a>

    </p>
  </header>


  <div>
    <p>栈: 后进先出(LIFO)</p>
<p>队列: 先进先出(FIFO)</p>
<ul>
<li>栈和队列的一些应用<ol>
<li>信号量: 同步多个进程访问共享资源</li>
<li>事件处理</li>
<li>X Window 系统, 使用队列来存储事件</li>
<li>生产者-消费者问题, 生产者向队列中写入数据, 消费从队列中读出数据</li>
<li>C 函数的调用, 函数的调用会将一些信息压入程序栈, 程序结束时将信息出栈</li>
</ol>
</li>
</ul>
<p>栈最常用的是使用链表来实现, 以下是栈的抽象数据类型头文件</p>
<div class="highlight"><pre><span></span><span class="cm">/* stack.h */</span>
<span class="cp">#ifndef STACK_H</span>
<span class="cp">#define STACK_H</span>

<span class="cm">/* 元素结点 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">StackElmt_</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">StackElmt_</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="n">StackElmt</span><span class="p">;</span>

<span class="cm">/* 栈结构 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Stack_</span> <span class="p">{</span>
    <span class="cm">/* 栈大小 */</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="cm">/* 指向栈顶结点 */</span>
    <span class="n">StackElmt</span> <span class="o">*</span><span class="n">top</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">);</span>
<span class="p">}</span><span class="n">Stack</span><span class="p">;</span>

<span class="cm">/* 初始化 */</span>
<span class="kt">void</span> <span class="nf">stack_init</span><span class="p">(</span><span class="n">Stack</span> <span class="o">*</span><span class="n">stack</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">));</span>
<span class="cm">/* 销毁 */</span>
<span class="kt">void</span> <span class="nf">stack_destroy</span><span class="p">(</span><span class="n">Stack</span> <span class="o">*</span><span class="n">stack</span><span class="p">);</span>
<span class="cm">/* 插入结点 */</span>
<span class="kt">int</span> <span class="nf">stack_push</span><span class="p">(</span><span class="n">Stack</span> <span class="o">*</span><span class="n">stack</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* 弹出结点 */</span>
<span class="kt">int</span> <span class="nf">stack_pop</span><span class="p">(</span><span class="n">Stack</span> <span class="o">*</span><span class="n">stack</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* 空栈返回 NULL, 非空栈返回头指针指向数据 */</span>
<span class="cp">#define stack_peek(stack) ((stack)-&gt;top == NULL ? NULL : (stack)-&gt;top-&gt;data)</span>
<span class="cm">/* 返回栈大小 */</span>
<span class="cp">#define stack_size(stack) ((stack)-&gt;size)</span>

<span class="cp">#endif</span>
</pre></div>


<p>栈的实现</p>
<div class="highlight"><pre><span></span><span class="cm">/* stack.c */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;stack.h&quot;</span><span class="cp"></span>

<span class="cm">/* 初始化 */</span>
<span class="kt">void</span> <span class="nf">stack_init</span><span class="p">(</span><span class="n">Stack</span> <span class="o">*</span><span class="n">stack</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">stack</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">stack</span><span class="p">.</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">;</span>
    <span class="n">stack</span><span class="p">.</span><span class="n">top</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 销毁 */</span>
<span class="kt">void</span> <span class="nf">stack_destroy</span><span class="p">(</span><span class="n">Stack</span> <span class="o">*</span><span class="n">stack</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">stack</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">stack_pop</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">stack</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">stack</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Stack</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* 弹出结点 */</span>
<span class="kt">int</span> <span class="nf">stack_pop</span><span class="p">(</span><span class="n">Stack</span> <span class="o">*</span><span class="n">stack</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">StackElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">stack</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">element</span> <span class="o">=</span> <span class="n">stack</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
    <span class="n">stack</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
    <span class="n">stack</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 压入结点 */</span>
<span class="kt">int</span> <span class="nf">stack_push</span><span class="p">(</span><span class="n">Stack</span> <span class="o">*</span><span class="n">stack</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">StackElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">element</span> <span class="o">=</span> <span class="p">(</span><span class="n">StackElmt</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">StackElmt</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">element</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">stack</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">;</span>
    <span class="n">stack</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
    <span class="n">stack</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>队列其实就是一个链表结构, 但只提供了先进先出的接口
队列头文件定义</p>
<div class="highlight"><pre><span></span><span class="cm">/* queue.h */</span>
<span class="cp">#ifndef QUEUE_H</span>
<span class="cp">#define QUEUE_H</span>

<span class="cm">/* 元素结点 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">QueueElmt_</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">QueueElmt_</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="n">QueueElmt</span><span class="p">;</span>

<span class="cm">/* 队列结构 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Queue_</span> <span class="p">{</span>
    <span class="cm">/* 队列大小 */</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="cm">/* 指向队列头结点 */</span>
    <span class="n">QueueElmt</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="cm">/* 队列尾结点 */</span>
    <span class="n">QueueElmt</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">);</span>
<span class="p">}</span><span class="n">Queue</span><span class="p">;</span>

<span class="cm">/* 初始化 */</span>
<span class="kt">void</span> <span class="nf">queue_init</span><span class="p">(</span><span class="n">Queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">));</span>
<span class="cm">/* 销毁 */</span>
<span class="kt">void</span> <span class="nf">queue_destroy</span><span class="p">(</span><span class="n">Queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">);</span>
<span class="cm">/* 插入结点 */</span>
<span class="kt">int</span> <span class="nf">queue_enqueue</span><span class="p">(</span><span class="n">Queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* 弹出结点 */</span>
<span class="kt">int</span> <span class="nf">queue_dequeue</span><span class="p">(</span><span class="n">Queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* 空栈返回 NULL, 非空栈返回头指针指向数据 */</span>
<span class="cp">#define queue_peek(queue) ((queue)-&gt;head == NULL ? NULL : (queue)-&gt;top-&gt;data)</span>
<span class="cm">/* 返回栈大小 */</span>
<span class="cp">#define queue_size(queue) ((queue)-&gt;size)</span>


<span class="cp">#endif</span>
</pre></div>


<p>队列抽象数据类型的实现</p>
<div class="highlight"><pre><span></span><span class="cm">/* queue.h */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;queue.h&quot;</span><span class="cp"></span>

<span class="cm">/* 初始化 */</span>
<span class="kt">void</span> <span class="nf">queue_init</span><span class="p">(</span><span class="n">Stack</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">;</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 销毁 */</span>
<span class="kt">void</span> <span class="nf">queue_destroy</span><span class="p">(</span><span class="n">Stack</span> <span class="o">*</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">queue_dequeue</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">queue</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Queue</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* 入队 */</span>
<span class="kt">int</span> <span class="nf">queue_enqueue</span><span class="p">(</span><span class="n">Queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">QueueElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">element</span> <span class="o">=</span> <span class="p">(</span><span class="n">QueueElmt</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">QueueElmt</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">element</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 空队列 */</span>
        <span class="n">queue</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">queue</span><span class="o">-&gt;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">queue</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
    <span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">queue</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/* 出队 */</span>
<span class="kt">int</span> <span class="nf">queue_dequeue</span><span class="p">(</span><span class="n">Queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">QueueElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">element</span> <span class="o">=</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 队列中只有一个结点 */</span>
        <span class="n">queue</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">queue</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">queue</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
    <span class="n">queue</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="./tag/suan-fa.html">算法</a>
      <a href="./tag/c.html">C</a>
      <a href="./tag/zhan.html">栈</a>
      <a href="./tag/dui-lie.html">队列</a>
      <a href="./tag/shu-ju-jie-gou.html">数据结构</a>
    </p>
  </div>





</article>

    <footer>
<p>
  &copy;  2018 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Powered by <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
           src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>




<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Ivicel\s Ambertime ",
  "url" : ".",
  "image": "/images/favicon.ico",
  "description": "ivicel's thoughts and writings"
}
</script>

</body>
</html>