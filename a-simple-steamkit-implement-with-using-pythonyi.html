<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />


  <title>A Simple SteamKit implement with using Python(一)</title>


  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="referrer" content="origin" />
  <meta name="generator" content="Pelican" />
  <link href="./" rel="canonical" />

  <!-- Feed -->

  <link href="./theme/css/style.css" type="text/css" rel="stylesheet" />

  <!-- Code highlight color scheme -->
      <link href="./theme/css/code_blocks/github.css" rel="stylesheet">

    <!-- CSS specified by the user -->


    <link href="./assets/css/prism.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/base.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/base-control.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/github.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/codemirror.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/ivicel.css" type="text/css" rel="stylesheet" />

  <!-- Custom fonts -->
  <link href='https://fonts.googleapis.com/css?family=Montserrat:400,300' rel='stylesheet' type='text/css' />
  <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css" />

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->


  <link href="./a-simple-steamkit-implement-with-using-pythonyi.html" rel="canonical" />

    <meta name="description" content="1. 连接握手 与 steam 客户端进行通信的称为 CM Server, Steam 客户端首先要向发送一个连接请求 , 然后服务器会返回一个 CHANNEL_ENCRYPT_REQUEST, 这个消息包会带有一个 16 字节的 质询 challenge...">

    <meta name="author" content="ivicel">

    <meta name="tags" content="python">
    <meta name="tags" content="steam">
    <meta name="tags" content="steamkit">




<!-- Open Graph -->
<meta property="og:site_name" content="Ambertime"/>
<meta property="og:title" content="A Simple SteamKit implement with using Python(一)"/>
<meta property="og:description" content="1. 连接握手 与 steam 客户端进行通信的称为 CM Server, Steam 客户端首先要向发送一个连接请求 , 然后服务器会返回一个 CHANNEL_ENCRYPT_REQUEST, 这个消息包会带有一个 16 字节的 质询 challenge..."/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="./a-simple-steamkit-implement-with-using-pythonyi.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2018-07-18 00:00:00+08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="./author/ivicel.html">
<meta property="article:section" content="Python"/>
<meta property="article:tag" content="python"/>
<meta property="article:tag" content="steam"/>
<meta property="article:tag" content="steamkit"/>
<meta property="og:image" content="./theme/images/post-bg.jpg">

<!-- Twitter Card -->

<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "name": "A Simple SteamKit implement with using Python(一)",
  "headline": "A Simple SteamKit implement with using Python(一)",
  "datePublished": "2018-07-18 00:00:00+08:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "ivicel",
    "url": "./author/ivicel.html"
  },
  "image": "./theme/images/post-bg.jpg",
  "url": "./a-simple-steamkit-implement-with-using-pythonyi.html",
  "description": "1. 连接握手 与 steam 客户端进行通信的称为 CM Server, Steam 客户端首先要向发送一个连接请求 , 然后服务器会返回一个 CHANNEL_ENCRYPT_REQUEST, 这个消息包会带有一个 16 字节的 质询 challenge..."
}
</script>
</head>
<!-- TODO : Body class -->
<body class="home-template">

<nav id="menu">
  <a class="close-button">Close</a>
  <div class="nav-wrapper">
    <p class="nav-label">Menu</p>
    <ul>


    </ul>
  </div>
</nav>
    <!-- Progressbar -->
    <div class="progress-container">
        <span class="progress-bar"></span>
    </div>

    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
    <header id="blog-header" >
      <div class="inner">
        <nav id="navigation">
            <span id="home-button" class="nav-button">
                <a class="home-button" href="./" title="Home"><i class="ic ic-arrow-left"></i> Home</a>
            </span>
          <span id="menu-button" class="nav-button">
            <a class="menu-button"><i class="ic ic-menu"></i> Menu</a>
          </span>
        </nav>
        <h1 class="post-title">A Simple SteamKit implement with using Python(一)</h1>
        <!-- TODO : Proper class for headline -->
        <span class="post-meta">
                <a href="./author/ivicel.html">Ivicel</a>
            | <time datetime="Wed 18 July 2018">Wed 18 July 2018</time>
        </span>
        <!-- TODO : Modified check -->
      </div>
    </header>

  <section id="wrapper">
    <a class="hidden-close"></a>

    <!-- Post content -->
    <main class="content" role="main">
        <article class="post">
        <div class="inner">
            <section class="post-content">
                <h4 id="1">1. 连接握手 </h4>
<ol>
<li>
<p> 与 steam 客户端进行通信的称为 CM Server, Steam 客户端首先要向发送一个连接请求 , 然后服务器会返回一个 <code>CHANNEL_ENCRYPT_REQUEST</code>, 这个消息包会带有一个 16 字节的 质询 <code>challenge</code></p>
</li>
<li>
<p> 我们随机生生成一个 256 位长度的密钥 <code>session_key</code>,  使用 steam 的公钥对密钥加密后再发回给服务器 , 加密方法为 <code>RSA</code>, padding 为 <code>OAEP(mgf=MGF1(algorithm=SHA1), algorithm=SHA1)</code> </p>
</li>
</ol>
<blockquote>
<p> 这里可里选择只发送回 <code>session_key</code>(legacy mode), 或者回应质询 <code>session_key + challenge</code>, 发回后者表示在以后的通信中使用每次会生成一个 <code>SHA1-HMAC</code>. </p>
</blockquote>
<ol>
<li> 收到服务的 <code>session_key</code> 确认 , 结果为 <code>EResult.OK</code> 时 , 连接成功 . 以后的通信会基于 <code>session_key</code> 加密 </li>
</ol>
<blockquote>
<p> 如果我们启用了 <code>SHA1-HMAC</code> 消息认证 , 那么在 <code>CBC</code> 模式使用的初始向量 <code>iv</code> 会有不同 , 不是通过直接随机生成 , 而是对明文生成 HMAC 后 , 取其前 13 bytes, 再加上随机生成 3 bytes. 下面是发送 <code>HMAC</code> 时的步骤 </p>
<ol>
<li> 随机生成 3 bytes <code>prefix</code>, 把这三个字节加到明文的前面 , hash key 是 <code>session_key</code> 的前 16 bytes, 即 <code>hash_key = session_key[:16]</code>. 使用 <code>HMAC(hash_key=session[:16], hash_function=SHA1, message=prefix + need_to_encrypt_text)</code>, 生成的 <code>hmac_msg</code> 后 , <code>iv = hmac_msg[:13] + prefix</code></li>
<li> 使用 <code>AES-256-ECB</code>, 加密 <code>iv</code>, 分组长度为 128 bits. 得到 <code>enc_iv</code>, 一共是 16 个字节 </li>
<li> 使用 <code>AES-256-CBC</code>, 加密 <code>need_to_encrypt_text</code>, 分组长度为 <code>128 bits</code>, 填充模式为 <code>PKCS7</code>.  得到 <code>enc_msg</code></li>
<li> 返回的 <code>enc_iv + env_msg</code> 即是加密完成的的消息体 </li>
</ol>
<p> 如果没有启用 <code>HMAC</code>, 即不发送 <code>challenge</code>, 在第一步中把 <code>iv</code> 换成随机生成的 16 字节即可 .</p>
<p> 解密过程就是反向过程 , 消息包的前 16 个字节是 <code>env_iv</code>, 剩下的是加密后 message 本体 . 使用对应的加密方法进行解密即可 </p>
</blockquote>
<ol>
<li>
<p> 初始的 CM Server IP 地址和端口 可以在 <code>steam_installed_directory/config/config.vdf</code> 找到 , 在通信的过程 , 服务器会发回新 CM IP 地址和端口 </p>
</li>
<li>
<p>steam 客户端保持一个 TCP/UDP 长连接 , 用来与 CM Server 通信 , 并且要定时发送一个 <strong>"heartbeat"</strong> 用来告诉 CM 不要断开连接 </p>
</li>
<li>
<p> 通信的数据结构主要为 <a href="https://developers.google.com/protocol-buffers/">Protocol Buffer v2</a>, 在 proto 外包了一层 header, header 里指明了是否为 proto buffer</p>
</li>
</ol>
<h4 id="2-protocol-bufffer">2. 了解 Protocol Bufffer</h4>
<p> 根据 protobuf 的 <a href="https://github.com/google/protobuf"> 文档 </a>, 使用 protobuf 要三步走 </p>
<ol>
<li> 定义 <code>.proto</code> 文件原型 , steamdb 已经收集好了 , 从 <a href="https://github.com/SteamDatabase/SteamTracking">SteamDB github</a> 下载 , 另外这些都是定义都依赖 Google 定义的 <code>descriptor.proto</code>, 在 <a href="https://github.com/google/protobuf/blob/master/src/google/protobuf/descriptor.proto"> 这里 </a> 可以下载到这个文件 , 打包的编译器也带了这个 </li>
</ol>
<blockquote>
<p> 花 <a href="https://space.bilibili.com/423895/">5 分钟 </a> 了解一下 protobufs 是如何 <a href="https://developers.google.com/protocol-buffers/docs/proto"> 定义 </a></p>
</blockquote>
<ol>
<li> 使用 <code>protobuf</code> 编译器把 <code>.proto</code> 文件编译成对应语言文件 , 编译器在 <a href="https://github.com/google/protobuf/releases"> 这里 </a> 下载 , 下载对应系统的版本即可 , 带语言标签的是使用特定语言的实现源代码 </li>
</ol>
<blockquote>
<p> 花几分钟读下 <a href="https://developers.google.com/protocol-buffers/docs/pythontutorial">python tutorial</a></p>
</blockquote>
<ol>
<li> 使用 Python protocol buffer API 读写 , API 文档在 <a href="https://developers.google.com/protocol-buffers/docs/reference/python/"> 这里 </a></li>
</ol>
<h4 id="3-protobuf">3. 编译 protobuf</h4>
<pre class="highlight"><code class="language-shell linenums"># project 目录
mkdir python-steamkit &amp;&amp; cd python-steamkit
python3 -m venv venv
# 用于加密和 protobuf 的依赖包
pip install cryptography protobuf

# Protobufs 目录定义主要的通信格式
# 其他目录是对应的游戏通信格式
git clone https://github.com/SteamDatabase/SteamTracking
cd SteamTracking/Protobufs
mv renderer/rendermessages.proto .
# 删掉重复定义
rm -R steamdatagram_auth_messages.proto renderer
# 在每个 proto 文件的第一行加上 syntax = "proto2"; 语法定义避免编译警告
sed -s -i '1isyntax = "proto2";' *.proto
# optinal 查看来是否所有 .proto 文件都有 proto2 语法定义了 , 0 表示成功
test $(find . -type f -name '*.proto' | wc -l) -eq \
    $(grep -E '^syntax\s?=\s?"proto2";$' -R . | wc -l); echo $?

# 新建目录来存放编译后的 .py 文件
mkdir protobufs
# 如果文件名了带有点号 , 比如 a.b.proto, 编译后会生成 a/b_pb.py, 我们不需要独立的目录
# 把文件的中点号换成下划线 "_", 文件内的依赖路径相应的也需要更改
for n in `ls`; do; name=$(echo $n | sed -E 's/\./_/g; s/_proto$/\.proto/g'); mv $n $name; done
sed -E -i '/^import/s/\./_/; /^import/s/_proto/\.proto/' *.proto

# 下载的 protoc 编译包里包含了 descriptor.proto, 指定依赖路径即可
protoc --python_out=./protobufs -I. -I protoc/include *.proto
# 将 steam_proto 打包成 python package
touch protobufs/__init__.py
mv protobuf ../../
sed -E '/^import\s+"[^\/]*$/s/"(.*)";$/"steam\/protobufs\/\1";/' steam/protobufs/*.proto -i</code></pre>

<h4 id="4">4. 通信消息的格式 </h4>
<p> 通信是按 <strong>Little endian</strong> 传输的 , 通信包的定义主要有三种情况 :</p>
<ol>
<li> 前三个握手包 , 用来生成加密的通信 , 有自己特定的定义 </li>
<li>protobuf 包 , 包含一个 protobuf 消息 </li>
<li>multi message, (1) 根据 <code>CMsgMulti.size_unzipped</code> 是否 <strong> 大于 0</strong> 来判断 <code>CMsgMulti.message_body</code> 是否启用了  gzip 压缩 . (2) 如果是则要先先把 <code>message_body</code> 解压 , 然后再解读里 </li>
</ol>
<p> 这三种包都会包含以下三个字段 : </p>
<ul>
<li>4 bytes 的 包长度 </li>
<li> 固定的 4 bytes magic number, 为 <code>0x31305456</code></li>
<li>4 bytes 的 消息类型 , 消息的最高位为 protobuf 消息掩码位 , <code>0</code> 表示非 protobuf, <code>1</code> 为 protobuf</li>
</ul>
<pre class="highlight"><code class="linenums">1. handshake packet: &lt;ChannelEncryptRequest&gt;, &lt;ChannelEncryptResponse&gt;, &lt;ChannelEncryptResult&gt;
+ + + + + + + + + + + + + + +
|   4 bytes msg_len         |
+ - - - - - - - - - - - - - +
|   4 bytes magic_number    |
+ - - - - - - - - - - - - - +
|   4 bytes msg_type        |
+ - - - - - - - - - - - - - +
|   8 bytes target_job_id   |
+ - - - - - - - - - - - - - +
|   8 bytes source_job_id   |
+ - - - - - - - - - - - - - +             
|                           |       
|   body(msg_len - 20 bytes)| 
|                           |
+ + + + + + + + + + + + + + +

body 详细说明
I. recv &lt;ChannelEncryptRequest&gt;
    + - - - - - - - - - - - - - - - + 
    | (msg_len - 20)bytes challenge |
    + - - - - - - - - - - - - - - - + 

II. send &lt;ChannelEncryptResponse&gt;
    + - - - - - - - - - - - - - - - + 
    | 4 bytes protocol_version (1)  |
    + - - - - - - - - - - - - - - - + 
    | 4 bytes key_size (128)        |
    + - - - - - - - - - - - - - - - + 
    | 128 bytes session_key         |
    + - - - - - - - - - - - - - - - +  
    | 4 bytes crc32(session_key)    |       
    + - - - - - - - - - - - - - - - +  
    | 4 bytes end_flag (0)          |
    + + + + + + + + + + + + + + + + +

III. recv &lt;ChannelEncryptResult&gt;
    + - - - - - - - - - - - - - - - + 
    | 4 bytes EResult               |
    + - - - - - - - - - - - - - - - + 

2. Protobuf packet
+ + + + + + + + + + + + + + +
|   4 bytes msg_len         |
+ - - - - - - - - - - - - - +
|   4 bytes magic_number    |
+ - - - - - - - - - - - - - +
|   4 bytes msg_type        |
+ - - - - - - - - - - - - - +
|   4 bytes protobuf_len    |
+ - - - - - - - - - - - - - +          
|                           |       
|   Protobuf Message        |
|                           |
+ + + + + + + + + + + + + + +


3. mutil packet
+ + + + + + + + + + + + + + +
| 4 bytes msg_len           |
+ - - - - - - - - - - - - - +
| 4 bytes magic_number      |
+ - - - - - - - - - - - - - +
| 4 bytes msg_type          |
+ - - - - - - - - - - - - - +
| 1 byte header_size (32)   |
+ - - - - - - - - - - - - - +
| 2 bytes header_version (1)|
+ - - - - - - - - - - - - - +
| 8 bytes target_job_id     |
+ - - - - - - - - - - - - - +
| 8 bytes source_job_id     |
+ - - - - - - - - - - - - - +  
| 1 byte header_canary      |
+ - - - - - - - - - - - - - +
| 8 bytes steam_id          |
+ - - - - - - - - - - - - - + 
| 8 bytes source_job_id     |
+ - - - - - - - - - - - - - +   
| 8 bytes session_id        |
+ - - - - - - - - - - - - - +             
|                           |       
|Protobuf message&lt;CMsgMulti&gt;|
|                           |
+ + + + + + + + + + + + + + +

Multi 包含一个或多个 message, 每个结构为 , 前 4 个字节为消息长度 + message
+ - - - - - - - - - - - - - + 
| 4 bytes message_len       |
+ - - - - - - - - - - - - - +   
| message_len bytes message |
+ - - - - - - - - - - - - - +  
| 4 bytes message_len       |
+ - - - - - - - - - - - - - +   
| message_len bytes message |
+ - - - - - - - - - - - - - +


4. send protobuf message
+ + + + + + + + + + + + + + + + + + + +
|   4 bytes msg_len                   |
+ - - - - - - - - - - - - - - - - - - + 
|   4 bytes magic_number              |
+ - - - - - - - - - - - - - - - - - - + 
|   encrypted mesasge body            |
+ - - - - - - - - - - - - - - - - - - +

需要发送的 protobuf message 包含 message header 和 message body 主体
1&gt; 如果已经登录的情况下 , 把 header 里的 steamid, client_sessionid 改成对应的值
2&gt; 将这两个序列化生成字节串
3&gt; 使用 session_key 加密 , 根据前面的握手过程 , 依需要生成 hash message
4&gt; 组合成上面的包 . 注意的是包的主体消息长度是指加密后的字节数
+ - - - - - - - - - - - - - - - - - - +  
| Protobuf header&lt;CMsgProtoBufHeader&gt; |
+ - - - - - - - - - - - - - - - - - - +  
| Protobuf message                    |
+ - - - - - - - - - - - - - - - - - - +  </code></pre>

<h4 id="reference">Reference</h4>
<ol>
<li><a href="https://github.com/ValvePython/steam/issues/79">https://github.com/ValvePython/steam/issues/79</a></li>
<li><a href="https://github.com/ValvePython/steam">https://github.com/ValvePython/steam</a></li>
<li><a href="https://github.com/SteamRE/SteamKit/issues/555">https://github.com/SteamRE/SteamKit/issues/555</a></li>
</ol>
            </section>

            <section class="post-info">
                <div class="post-share">
                    <a class="twitter" href="https://twitter.com/share?text=A Simple SteamKit implement with using Python(一)&amp;url=./a-simple-steamkit-implement-with-using-pythonyi.html" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <i class="ic ic-twitter"></i><span class="hidden">Twitter</span>
                    </a>
                    <a class="facebook" href="https://www.facebook.com/sharer/sharer.php?u=./a-simple-steamkit-implement-with-using-pythonyi.html" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <i class="ic ic-facebook"></i><span class="hidden">Facebook</span>
                    </a>
                    <a class="googleplus" href="https://plus.google.com/share?url=./a-simple-steamkit-implement-with-using-pythonyi.html" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <i class="ic ic-googleplus"></i><span class="hidden">Google+</span>
                    </a>
                    <div class="clear"></div>
                </div>

                <aside class="post-tags">
<a href="./tag/python.html">python</a><a href="./tag/steam.html">steam</a><a href="./tag/steamkit.html">steamkit</a>                </aside>

                <div class="clear"></div>


                </section>


                <aside class="post-nav">
                    <div class="clear"></div>
                </aside>

            </div>
        </article>
    </main>
      <!-- TODO : Body class -->
    <div id="body-class" style="display: none;" class=""></div>

    <footer id="footer">
      <div class="inner">
        <section class="credits">


          <span class="credits-theme">Theme <a href="https://github.com/arulrajnet/attila" rel="nofollow">Attila</a></span>
          <span class="credits-software">Published with <a href="https://github.com/getpelican/pelican" rel="nofollow">Pelican</a></span>
        </section>
      </div>
    </footer>
  </section>

  <script type="text/javascript" src="./theme/js/script.js"></script>

    <!-- Script specified by the user -->
    <script type="text/javascript"  src="./assets/js/prism.js"></script>
</body>
</html>