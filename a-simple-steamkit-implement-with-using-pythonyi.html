<!DOCTYPE html>
<html lang="zh" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>A Simple SteamKit implement with using Python(一) - Amber time</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="./a-simple-steamkit-implement-with-using-pythonyi.html">

        <meta name="author" content="ivicel" />
        <meta name="keywords" content="python,steam,steamkit" />
        <meta name="description" content="1. 连接握手 与 steam 客户端进行通信的称为 CM Server, Steam 客户端首先要向发送一个连接请求, 然后服务器会返回一个 CHANNEL_ENCRYPT_REQUEST, 这个消息包会带有一个 16 字节的 质询 challenge 我们随机生生成一个 256 位长度的密钥 session_key, 使用 steam 的公钥对密钥加密后再发回给服务器, 加密方法为 RSA, padding 为 OAEP(mgf=MGF1(algorithm=SHA1), algorithm=SHA1) 这里可里选择只发送回 session_key(legacy mode), 或者回应质询 session_key + challenge, 发回后者表示在以后的通信中使用每次会生成一个 SHA1-HMAC. 收到服务的 session_key 确认, 结果为 EResult.OK 时 …" />

        <meta property="og:site_name" content="Amber time" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="A Simple SteamKit implement with using Python(一)"/>
        <meta property="og:url" content="./a-simple-steamkit-implement-with-using-pythonyi.html"/>
        <meta property="og:description" content="1. 连接握手 与 steam 客户端进行通信的称为 CM Server, Steam 客户端首先要向发送一个连接请求, 然后服务器会返回一个 CHANNEL_ENCRYPT_REQUEST, 这个消息包会带有一个 16 字节的 质询 challenge 我们随机生生成一个 256 位长度的密钥 session_key, 使用 steam 的公钥对密钥加密后再发回给服务器, 加密方法为 RSA, padding 为 OAEP(mgf=MGF1(algorithm=SHA1), algorithm=SHA1) 这里可里选择只发送回 session_key(legacy mode), 或者回应质询 session_key + challenge, 发回后者表示在以后的通信中使用每次会生成一个 SHA1-HMAC. 收到服务的 session_key 确认, 结果为 EResult.OK 时 …"/>
        <meta property="article:published_time" content="2018-07-18" />
            <meta property="article:section" content="Python" />
            <meta property="article:tag" content="python" />
            <meta property="article:tag" content="steam" />
            <meta property="article:tag" content="steamkit" />
            <meta property="article:author" content="ivicel" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="./theme/css/bootstrap.min.css" type="text/css"/>
    <link href="./theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="./theme/css/pygments/emacs.css" rel="stylesheet">
    <link rel="stylesheet" href="./theme/css/style.css" type="text/css"/>
        <link href="./theme/css/custom.css" rel="stylesheet">





</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="./" class="navbar-brand">
Amber time            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li >
                            <a href="./category/android.html">Android</a>
                        </li>
                        <li >
                            <a href="./category/c-language.html">C language</a>
                        </li>
                        <li >
                            <a href="./category/data-structure-algorithms.html">Data structure algorithms</a>
                        </li>
                        <li >
                            <a href="./category/database.html">Database</a>
                        </li>
                        <li >
                            <a href="./category/java.html">Java</a>
                        </li>
                        <li >
                            <a href="./category/javascript.html">Javascript</a>
                        </li>
                        <li class="active">
                            <a href="./category/python.html">Python</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-sm-9">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="./a-simple-steamkit-implement-with-using-pythonyi.html"
                       rel="bookmark"
                       title="Permalink to A Simple SteamKit implement with using Python(一)">
                        A Simple SteamKit implement with using Python(一)
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2018-07-18T00:00:00+08:00"> Wed 18 July 2018</time>
    </span>





<span class="label label-default">Tags</span>
	<a href="./tag/python.html">python</a>
        /
	<a href="./tag/steam.html">steam</a>
        /
	<a href="./tag/steamkit.html">steamkit</a>
        
</footer><!-- /.post-info -->                    </div>
                </div>
                <h4 id="1">1. 连接握手</h4>
<ol>
<li>
<p>与 steam 客户端进行通信的称为 CM Server, Steam 客户端首先要向发送一个连接请求, 然后服务器会返回一个 <code>CHANNEL_ENCRYPT_REQUEST</code>, 这个消息包会带有一个 16 字节的 质询 <code>challenge</code></p>
</li>
<li>
<p>我们随机生生成一个 256 位长度的密钥 <code>session_key</code>,  使用 steam 的公钥对密钥加密后再发回给服务器, 加密方法为 <code>RSA</code>, padding 为 <code>OAEP(mgf=MGF1(algorithm=SHA1), algorithm=SHA1)</code> </p>
</li>
</ol>
<blockquote>
<p>这里可里选择只发送回 <code>session_key</code>(legacy mode), 或者回应质询 <code>session_key + challenge</code>, 发回后者表示在以后的通信中使用每次会生成一个 <code>SHA1-HMAC</code>. </p>
</blockquote>
<ol>
<li>收到服务的 <code>session_key</code> 确认, 结果为 <code>EResult.OK</code> 时, 连接成功. 以后的通信会基于 <code>session_key</code> 加密</li>
</ol>
<blockquote>
<p>如果我们启用了 <code>SHA1-HMAC</code> 消息认证, 那么在 <code>CBC</code> 模式使用的初始向量 <code>iv</code> 会有不同, 不是通过直接随机生成, 而是对明文生成 HMAC 后, 取其前 13 bytes, 再加上随机生成 3 bytes. 下面是发送 <code>HMAC</code> 时的步骤</p>
<ol>
<li>随机生成 3 bytes <code>prefix</code>, 把这三个字节加到明文的前面, hash key 是 <code>session_key</code> 的前 16 bytes, 即 <code>hash_key = session_key[:16]</code>. 使用 <code>HMAC(hash_key=session[:16], hash_function=SHA1, message=prefix + need_to_encrypt_text)</code>, 生成的 <code>hmac_msg</code> 后, <code>iv = hmac_msg[:13] + prefix</code></li>
<li>使用 <code>AES-256-ECB</code>, 加密 <code>iv</code>, 分组长度为 128 bits. 得到 <code>enc_iv</code>, 一共是 16个字节</li>
<li>使用 <code>AES-256-CBC</code>, 加密 <code>need_to_encrypt_text</code>, 分组长度为 <code>128 bits</code>, 填充模式为 <code>PKCS7</code>.  得到 <code>enc_msg</code></li>
<li>返回的 <code>enc_iv + env_msg</code> 即是加密完成的的消息体</li>
</ol>
<p>如果没有启用 <code>HMAC</code>, 即不发送 <code>challenge</code>, 在第一步中把 <code>iv</code> 换成随机生成的 16 字节即可.</p>
<p>解密过程就是反向过程, 消息包的前 16 个字节是 <code>env_iv</code>, 剩下的是加密后 message 本体. 使用对应的加密方法进行解密即可</p>
</blockquote>
<ol>
<li>
<p>初始的 CM Server IP 地址和端口 可以在 <code>steam_installed_directory/config/config.vdf</code> 找到, 在通信的过程, 服务器会发回新 CM IP 地址和端口</p>
</li>
<li>
<p>steam 客户端保持一个 TCP/UDP 长连接, 用来与 CM Server 通信, 并且要定时发送一个 <strong>"heartbeat"</strong> 用来告诉 CM 不要断开连接</p>
</li>
<li>
<p>通信的数据结构主要为 <a href="https://developers.google.com/protocol-buffers/">Protocol Buffer v2</a>, 在 proto 外包了一层 header, header 里指明了是否为 proto buffer</p>
</li>
</ol>
<h4 id="2-protocol-bufffer">2. 了解 Protocol Bufffer</h4>
<p>根据 protobuf 的 <a href="https://github.com/google/protobuf">文档</a>, 使用 protobuf 要三步走</p>
<ol>
<li>定义 <code>.proto</code> 文件原型, steamdb 已经收集好了, 从 <a href="https://github.com/SteamDatabase/SteamTracking">SteamDB github</a> 下载, 另外这些都是定义都依赖 Google 定义的 <code>descriptor.proto</code>, 在 <a href="https://github.com/google/protobuf/blob/master/src/google/protobuf/descriptor.proto">这里</a> 可以下载到这个文件, 打包的编译器也带了这个</li>
</ol>
<blockquote>
<p>花 <a href="https://space.bilibili.com/423895/">5 分钟</a> 了解一下 protobufs 是如何 <a href="https://developers.google.com/protocol-buffers/docs/proto">定义</a></p>
</blockquote>
<ol>
<li>使用 <code>protobuf</code> 编译器把 <code>.proto</code> 文件编译成对应语言文件, 编译器在 <a href="https://github.com/google/protobuf/releases">这里</a> 下载, 下载对应系统的版本即可, 带语言标签的是使用特定语言的实现源代码</li>
</ol>
<blockquote>
<p>花几分钟读下 <a href="https://developers.google.com/protocol-buffers/docs/pythontutorial">python tutorial</a></p>
</blockquote>
<ol>
<li>使用 Python protocol buffer API 读写, API 文档在 <a href="https://developers.google.com/protocol-buffers/docs/reference/python/">这里</a></li>
</ol>
<h4 id="3-protobuf">3. 编译 protobuf</h4>
<div class="highlight"><pre><span></span><span class="c1"># project 目录</span>
mkdir python-steamkit <span class="o">&amp;&amp;</span> <span class="nb">cd</span> python-steamkit
python3 -m venv venv
<span class="c1"># 用于加密和 protobuf 的依赖包</span>
pip install cryptography protobuf

<span class="c1"># Protobufs 目录定义主要的通信格式</span>
<span class="c1"># 其他目录是对应的游戏通信格式</span>
git clone https://github.com/SteamDatabase/SteamTracking
<span class="nb">cd</span> SteamTracking/Protobufs
mv renderer/rendermessages.proto .
<span class="c1"># 删掉重复定义</span>
rm -R steamdatagram_auth_messages.proto renderer
<span class="c1"># 在每个 proto 文件的第一行加上 syntax = &quot;proto2&quot;; 语法定义避免编译警告</span>
sed -s -i <span class="s1">&#39;1isyntax = &quot;proto2&quot;;&#39;</span> *.proto
<span class="c1"># optinal 查看来是否所有 .proto 文件都有 proto2 语法定义了, 0 表示成功</span>
<span class="nb">test</span> <span class="k">$(</span>find . -type f -name <span class="s1">&#39;*.proto&#39;</span> <span class="p">|</span> wc -l<span class="k">)</span> -eq <span class="se">\</span>
    <span class="k">$(</span>grep -E <span class="s1">&#39;^syntax\s?=\s?&quot;proto2&quot;;$&#39;</span> -R . <span class="p">|</span> wc -l<span class="k">)</span><span class="p">;</span> <span class="nb">echo</span> <span class="nv">$?</span>

<span class="c1"># 新建目录来存放编译后的 .py 文件</span>
mkdir protobufs
<span class="c1"># 如果文件名了带有点号, 比如 a.b.proto, 编译后会生成 a/b_pb.py, 我们不需要独立的目录</span>
<span class="c1"># 把文件的中点号换成下划线 &quot;_&quot;, 文件内的依赖路径相应的也需要更改</span>
<span class="k">for</span> n in <span class="sb">`</span>ls<span class="sb">`</span><span class="p">;</span> <span class="k">do</span><span class="p">;</span> <span class="nv">name</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$n</span> <span class="p">|</span> sed -E <span class="s1">&#39;s/\./_/g; s/_proto$/\.proto/g&#39;</span><span class="k">)</span><span class="p">;</span> mv <span class="nv">$n</span> <span class="nv">$name</span><span class="p">;</span> <span class="k">done</span>
sed -E -i <span class="s1">&#39;/^import/s/\./_/; /^import/s/_proto/\.proto/&#39;</span> *.proto

<span class="c1"># 下载的 protoc 编译包里包含了 descriptor.proto, 指定依赖路径即可</span>
protoc --python_out<span class="o">=</span>./protobufs -I. -I protoc/include *.proto
<span class="c1"># 将 steam_proto 打包成 python package</span>
touch protobufs/__init__.py
mv protobuf ../../
sed -E <span class="s1">&#39;/^import\s+&quot;[^\/]*$/s/&quot;(.*)&quot;;$/&quot;steam\/protobufs\/\1&quot;;/&#39;</span> steam/protobufs/*.proto -i
</pre></div>


<h4 id="4">4. 通信消息的格式</h4>
<p>通信是按 <strong>Little endian</strong> 传输的, 通信包的定义主要有三种情况:</p>
<ol>
<li>前三个握手包, 用来生成加密的通信, 有自己特定的定义</li>
<li>protobuf 包, 包含一个 protobuf 消息</li>
<li>multi message, 使用 gzip 压缩后的多个 protobuf messages</li>
</ol>
<p>这三种包都会包含以下三个字段: </p>
<ul>
<li>4 bytes 的 包长度 </li>
<li>固定的 4 bytes magic number, 为 <code>0x31305456</code></li>
<li>4 bytes 的 消息类型, 消息的最高位为 protobuf 消息掩码位, <code>0</code> 表示非 protobuf, <code>1</code> 为 protobuf</li>
</ul>
<p>```plain 
1. handshake packet: <ChannelEncryptRequest>, <ChannelEncryptResponse>, <ChannelEncryptResult>
+ + + + + + + + + + + + + + +
|   4 bytes msg_len         |
+ - - - - - - - - - - - - - +
|   4 bytes magic_number    |
+ - - - - - - - - - - - - - +
|   4 bytes msg_type        |
+ - - - - - - - - - - - - - +
|   8 bytes target_job_id   |
+ - - - - - - - - - - - - - +
|   8 bytes source_job_id   |
+ - - - - - - - - - - - - - +           <br />
|                           |     <br />
|   body(msg_len - 20 bytes)| 
|                           |
+ + + + + + + + + + + + + + +</p>
<p>body 详细说明
I. recv <ChannelEncryptRequest>
    + - - - - - - - - - - - - - - - + 
    | (msg_len - 20)bytes challenge |
    + - - - - - - - - - - - - - - - + </p>
<p>II. send <ChannelEncryptResponse>
    + - - - - - - - - - - - - - - - + 
    | 4 bytes protocol_version (1)  |
    + - - - - - - - - - - - - - - - + 
    | 4 bytes key_size (128)        |
    + - - - - - - - - - - - - - - - + 
    | 128 bytes session_key         |
    + - - - - - - - - - - - - - - - +<br />
    | 4 bytes crc32(session_key)    |     <br />
    + - - - - - - - - - - - - - - - +<br />
    | 4 bytes end_flag (0)          |
    + + + + + + + + + + + + + + + + +</p>
<p>III. recv <ChannelEncryptResult>
    + - - - - - - - - - - - - - - - + 
    | 4 bytes EResult               |
    + - - - - - - - - - - - - - - - + </p>
<ol>
<li>
<p>Protobuf packet
+ + + + + + + + + + + + + + +
|   4 bytes msg_len         |
+ - - - - - - - - - - - - - +
|   4 bytes magic_number    |
+ - - - - - - - - - - - - - +
|   4 bytes msg_type        |
+ - - - - - - - - - - - - - +
|   4 bytes protobuf_len    |
+ - - - - - - - - - - - - - +        <br />
|                           |     <br />
|   Protobuf Message        |
|                           |
+ + + + + + + + + + + + + + +</p>
</li>
<li>
<p>mutil packet
+ + + + + + + + + + + + + + +
| 4 bytes msg_len           |
+ - - - - - - - - - - - - - +
| 4 bytes magic_number      |
+ - - - - - - - - - - - - - +
| 4 bytes msg_type          |
+ - - - - - - - - - - - - - +
| 1 byte header_size (32)   |
+ - - - - - - - - - - - - - +
| 2 bytes header_version (1)|
+ - - - - - - - - - - - - - +
| 8 bytes target_job_id     |
+ - - - - - - - - - - - - - +
| 8 bytes source_job_id     |
+ - - - - - - - - - - - - - +<br />
| 1 byte header_canary      |
+ - - - - - - - - - - - - - +
| 8 bytes steam_id          |
+ - - - - - - - - - - - - - + 
| 8 bytes source_job_id     |
+ - - - - - - - - - - - - - + <br />
| 8 bytes session_id        |
+ - - - - - - - - - - - - - +           <br />
|                           |     <br />
|Protobuf message<CMsgMulti>|
|                           |
+ + + + + + + + + + + + + + +</p>
</li>
<li>
<p>send protobuf message
+ + + + + + + + + + + + + + + + + + + +
|   4 bytes msg_len                   |
+ - - - - - - - - - - - - - - - - - - + 
|   4 bytes magic_number              |
+ - - - - - - - - - - - - - - - - - - + 
|   encrypted mesasge body            |
+ - - - - - - - - - - - - - - - - - - +</p>
</li>
</ol>
<p>需要发送的 protobuf message 包含 message header 和 message body 主体
1&gt; 如果已经登录的情况下, 把 header 里的 steamid, client_sessionid 改成对应的值
2&gt; 将这两个序列化生成字节串
3&gt; 使用 session_key 加密, 根据前面的握手过程, 依需要生成 hash message
4&gt; 组合成上面的包. 注意的是包的主体消息长度是指加密后的字节数
+ - - - - - - - - - - - - - - - - - - +<br />
| Protobuf header<CMsgProtoBufHeader> |
+ - - - - - - - - - - - - - - - - - - +<br />
| Protobuf message                    |
+ - - - - - - - - - - - - - - - - - - +<br />
```</p>
<h4 id="reference">Reference</h4>
<ol>
<li>https://github.com/ValvePython/steam/issues/79</li>
<li>https://github.com/ValvePython/steam</li>
<li>https://github.com/SteamRE/SteamKit/issues/555</li>
</ol>
            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
        <div class="col-sm-3" id="sidebar">
            <aside>

<section class="well well-sm">
    <ul class="list-group list-group-flush">
        <li class="list-group-item"><h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Social</span></h4>
              <ul class="list-group" id="social">
                <li class="list-group-item"><a href="#"><i class="fa fa-you-can-add-links-in-your-config-file-square fa-lg"></i> You can add links in your config file</a></li>
                <li class="list-group-item"><a href="#"><i class="fa fa-another-social-link-square fa-lg"></i> Another social link</a></li>
              </ul>
            </li>





    <li class="list-group-item"><h4><i class="fa fa-external-link-square fa-lg"></i><span class="icon-label">Links</span></h4>
      <ul class="list-group" id="links">
        <li class="list-group-item">
            <a href="http://getpelican.com/" target="_blank">
                Pelican
            </a>
        </li>
        <li class="list-group-item">
            <a href="http://python.org/" target="_blank">
                Python.org
            </a>
        </li>
        <li class="list-group-item">
            <a href="http://jinja.pocoo.org/" target="_blank">
                Jinja2
            </a>
        </li>
        <li class="list-group-item">
            <a href="#" target="_blank">
                You can modify those links in your config file
            </a>
        </li>
      </ul>
    </li>
    </ul>
</section>            </aside>
        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2018 ivicel
            &middot; Powered by <a href="https://github.com/getpelican/pelican-themes/tree/master/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="./theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="./theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="./theme/js/respond.min.js"></script>


</body>
</html>