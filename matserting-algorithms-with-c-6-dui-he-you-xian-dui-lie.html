<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />


  <title>Matserting Algorithms with C-6: 堆和优先队列</title>


  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="referrer" content="origin" />
  <meta name="generator" content="Pelican" />
  <link href="./" rel="canonical" />

  <!-- Feed -->

  <link href="./theme/css/style.css" type="text/css" rel="stylesheet" />

  <!-- Code highlight color scheme -->
      <link href="./theme/css/code_blocks/github.css" rel="stylesheet">

    <!-- CSS specified by the user -->


    <link href="./assets/css/prism.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/base.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/base-control.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/github.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/codemirror.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/ivicel.css" type="text/css" rel="stylesheet" />

  <!-- Custom fonts -->
  <link href='https://fonts.googleapis.com/css?family=Montserrat:400,300' rel='stylesheet' type='text/css' />
  <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css" />

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->


  <link href="./matserting-algorithms-with-c-6-dui-he-you-xian-dui-lie.html" rel="canonical" />

    <meta name="description" content="堆 (Heap) 堆是一棵二叉树 , 子结点存储的值比父结点的值大称为最小值堆 , 子结点存储的值比父结点小称为最大值堆 堆是有序的排列 , 父子结点存在大小关系 , 兄弟结点不存在直接的关系 , 堆是快速取得最大 / 小值的数据结构 堆的实现通常存储在一个连续的数组中...">

    <meta name="author" content="ivicel">

    <meta name="tags" content="算法">
    <meta name="tags" content="C">
    <meta name="tags" content="集合">
    <meta name="tags" content="数据结构">




<!-- Open Graph -->
<meta property="og:site_name" content="Ambertime"/>
<meta property="og:title" content="Matserting Algorithms with C-6: 堆和优先队列"/>
<meta property="og:description" content="堆 (Heap) 堆是一棵二叉树 , 子结点存储的值比父结点的值大称为最小值堆 , 子结点存储的值比父结点小称为最大值堆 堆是有序的排列 , 父子结点存在大小关系 , 兄弟结点不存在直接的关系 , 堆是快速取得最大 / 小值的数据结构 堆的实现通常存储在一个连续的数组中..."/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="./matserting-algorithms-with-c-6-dui-he-you-xian-dui-lie.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2017-04-01 00:00:00+08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="./author/ivicel.html">
<meta property="article:section" content="Data Structure Algorithms"/>
<meta property="article:tag" content="算法"/>
<meta property="article:tag" content="C"/>
<meta property="article:tag" content="集合"/>
<meta property="article:tag" content="数据结构"/>
<meta property="og:image" content="./theme/images/post-bg.jpg">

<!-- Twitter Card -->

<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "name": "Matserting Algorithms with C-6: 堆和优先队列",
  "headline": "Matserting Algorithms with C-6: 堆和优先队列",
  "datePublished": "2017-04-01 00:00:00+08:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "ivicel",
    "url": "./author/ivicel.html"
  },
  "image": "./theme/images/post-bg.jpg",
  "url": "./matserting-algorithms-with-c-6-dui-he-you-xian-dui-lie.html",
  "description": "堆 (Heap) 堆是一棵二叉树 , 子结点存储的值比父结点的值大称为最小值堆 , 子结点存储的值比父结点小称为最大值堆 堆是有序的排列 , 父子结点存在大小关系 , 兄弟结点不存在直接的关系 , 堆是快速取得最大 / 小值的数据结构 堆的实现通常存储在一个连续的数组中..."
}
</script>
</head>
<!-- TODO : Body class -->
<body class="home-template">

<nav id="menu">
  <a class="close-button">Close</a>
  <div class="nav-wrapper">
    <p class="nav-label">Menu</p>
    <ul>


    </ul>
  </div>
</nav>
    <!-- Progressbar -->
    <div class="progress-container">
        <span class="progress-bar"></span>
    </div>

    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
    <header id="blog-header" >
      <div class="inner">
        <nav id="navigation">
            <span id="home-button" class="nav-button">
                <a class="home-button" href="./" title="Home"><i class="ic ic-arrow-left"></i> Home</a>
            </span>
          <span id="menu-button" class="nav-button">
            <a class="menu-button"><i class="ic ic-menu"></i> Menu</a>
          </span>
        </nav>
        <h1 class="post-title">Matserting Algorithms with C-6: 堆和优先队列</h1>
        <!-- TODO : Proper class for headline -->
        <span class="post-meta">
                <a href="./author/ivicel.html">Ivicel</a>
            | <time datetime="Sat 01 April 2017">Sat 01 April 2017</time>
        </span>
        <!-- TODO : Modified check -->
      </div>
    </header>

  <section id="wrapper">
    <a class="hidden-close"></a>

    <!-- Post content -->
    <main class="content" role="main">
<div class="col-lg-3 hidden-xs hidden-sm">
    <div id="toc"><ul><li><a class="toc-href" href="#" title="Matserting Algorithms with C-6: 堆和优先队列">Matserting Algorithms with C-6: 堆和优先队列</a><ul><li><a class="toc-href" href="#heap" title="堆 (Heap)">堆 (Heap)</a></li><li><a class="toc-href" href="#priority-queues" title="优先队列(Priority Queues)">优先队列(Priority Queues)</a></li></ul></li></ul></div>
</div>
        <article class="post">
        <div class="inner">
            <section class="post-content">
                <h3 id="heap"> 堆 (Heap)</h3>
<p> 堆是一棵二叉树 , 子结点存储的值比父结点的值大称为最小值堆 , 子结点存储的值比父结点小称为最大值堆 </p>
<p> 堆是有序的排列 , 父子结点存在大小关系 , 兄弟结点不存在直接的关系 , 堆是快速取得最大 / 小值的数据结构 </p>
<p> 堆的实现通常存储在一个连续的数组中 , 从根结点为 <code>0</code> 位置 , 任意结点 <code>i</code> 其父结点的的位置是 <code>int((i-2)/2)</code>, 舍弃掉小数部分 </p>
<p> 堆是左平衡的树 , 随着结点的增加 , 树会逐级从左至右增长 .</p>
<p> 向堆中插入节点 </p>
<p><img alt=" 向堆中插入结点 " src="../images/ 向堆中插入结点 .png"/></p>
<p> 删除堆顶点 </p>
<p><img alt=" 删除堆顶点 " src="../images/ 删除堆顶点 .png"/></p>
<pre class="highlight"><code class="language-c linenums">/* heap.h */
#ifndef HEAP_H
#define HEAP_H
/* 堆的数据结构 */
typedef struct Heap_ {
    int size;
    /* 调用者自定义比较函数 , 符合返回 &gt; 0, 不符合返回 &lt; 0, 相等返回 = 0 */
    int (*compare)(const void *key1, const void *key2);
    void (*destroy)(void *data);

    void **tree;
} Heap;

void heap_init(Heap *heap, int (*compare)(const void *key1, const void *key2),
    void (*destroy)(void *data));

void heap_destroy(Heap *heap);
/* 插入结点 , 复杂度是 O(lg n) */
int heap_insert(Heap *heap, const void *data);
/* 释放堆顶部的结点  复杂度是 O(lg n) */
int heap_extract(Heap *heap, void **data);
#define heap_size(heap) ((heap)-&gt;size)

#endif</code></pre>
<p> 堆的实现 </p>
<pre class="highlight"><code class="language-c linenums">/* heap.c */
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "heap.h"
/* 父结点位置 */
#define heap_parent(npos) ((int)(((npos) - 1) / 2))
/* 左子结点位置 */
#define heap_left(npos) (((npos) * 2) + 1)
/* 右子结点位置 */
#define heap_right(npos) (((npos) * 2) + 2)
/* 初始化 */
void heap_init(Heap *heap, int (*compare)(const void *key1, const void *key2),
    void (*destroy)(void *data))
{
    heap-&gt;size = 0;
    heap-&gt;compare = compare;
    heap-&gt;destroy = destroy;
    heap-&gt;tree = NULL;
}

/* 销毁 */
void heap_destroy(Heap *heap)
{
    int i;

    if (heap-&gt;destroy != NULL) {
        for (i = 0; i &lt; heap_size(heap); i++) {
            heap-&gt;destroy(heap-&gt;tree[i]);
        }
    }
    free(heap-&gt;tree);
    memset(heap, 0, sizeof(Heap));
}

/* 插入结点 */
int heap_insert(Heap *heap, const void *data)
{
    void *temp;
    int ipos, ppos;
    /* 重新给树分配一个连续的内存 */
    if ((temp = (void *)realloc(heap-&gt;tree, (heap_size(heap) + 1) * sizeof(void *)))
        == NULL) {
        return -1;
    } else {
        heap-&gt;tree = temp;
    }
    /* 新数据插入到数组尾部 */
    heap-&gt;tree[heap_size(heap)] = (void *data);
    /* 新结点位置 */
    ipos = heap_size(heap);
    /* 新结点的父结点位置 */
    ppos = heap_parent(ipos);

    /* 比较新结点与父结点的大小 , 将大于 / 小于的值交换 , 以保持树的结构 
     * compare 为调用者自定义的比较函数
     */
    while (ipos &gt; 0 &amp;&amp; heap-&gt;compare(heap-&gt;tree[ppos], heap-&gt;tree[ipos]) &lt; 0) {
        temp = heap-&gt;tree[ppos];
        heap-&gt;tree[ppos] = heap-&gt;tree[ipos];
        heap-&gt;tree[ipos] = temp;
        ipos = ppos;
        ppos = heap_parent(ipos);
    }
    heap-&gt;size++;
    return 0;
}

/* 删除根结点 */
int heap_extract(Heap *heap, void **)
{
    void *save, *temp;
    int ipos, lpos, rpos, mpos;
    /* 空堆 */
    if (heap_size(heap) == 0) {
        return -1;
    }
    /* 根结点数据 */
    *data = heap-&gt;tree[0];
    /* 最右结点数据 */
    save = heap-&gt;tree[heap_size(heap) - 1];
    /* 原堆内只有一个数据时 */
    if (heap_size(heap) == 1) {
        free(heap-&gt;tree);
        heap-&gt;size = 0;
        heap-&gt;tree = NULL;
        return 0;
    }
    /* 多于一个数据时 , 重新申请内存 */
    if ((temp = (void **)realloc(heap-&gt;tree, (heap_size(heap) - 1) * sizeof(void *)))
        == NULL) {
        return -1;
    }
    heap-&gt;tree = temp;
    heap-&gt;size--;
    /* 原堆内尾结点调换成根结点 */
    heap-&gt;tree[0] = save;

    ipos = 0;
    // lpos = heap_left(ipos);
    // rpos = heap_right(ipos);

    while (1) {
        /* 比较根结点与其子结点的大小 , 以保持树的结构 */
        lpos = heap_left(ipos);
        rpos = heap_right(ipos);

        if (lpos &lt; heap_size(heap) &amp;&amp; heap-&gt;compare(heap-&gt;tree[lpos],
            heap-&gt;tree[ipos]) &gt; 0) {
            mpos = lpos;
        } else {
            mpos = ipos;
        }

        if (rpos &lt; heap_size(heap) &amp;&amp; heap-&gt;compare(heap-&gt;tree[rpos],
            heap-&gt;tree[mpos]) &gt; 0) {
            mpos = rpos;
        }
        /* 顶点条件为最大 / 小值时 */ 
        if (mpos == ipos) {
            break;
        } else {
            temp = heap-&gt;tree[mpos];
            heap-&gt;tree[mpos] = heap-&gt;tree[ipos];
            heap-&gt;tree[ipos] = temp;
            ipos = mpos;
        }
    }
    return 0;
}</code></pre>
<h3 id="priority-queues"> 优先队列 (Priority Queues)</h3>
<p> 优先队列将数据按照数据的优先级顺序排列 , 这样可以最快定位到优先级最高的元素 . 例如在服务器做负载均衡时 , 最空闲的服务器优先级最高 , 这样可以更好的处理请求服务 </p>
<p> 优先队列的实现 </p>
<pre class="highlight"><code class="language-c linenums">/* pqueue.h */
#ifndef PQUEUE_H
#define PQUEUE_H

#include "heap.h"
/* 使用堆来实现优先队列 */
typedef Heap PQueue;
/* 队列中的比较函数 compare , 当 key1 优先级大于 key2 时 , 返回 1, 小于返回 -1, 相等返回 0 */
#define pqueue_init heap_init
#define pqueue_insert heap_insert
#define pqueue_extract heap_extract
/* 返回优先级最高的元素 */
#define pqueue_peek(pqueue) ((pqueue)-&gt;tree == NULL ? NULL : ((pqueue)-&gt;tree[0]))
/* 队列大小 */
#define pqueue_size heap_size

#endif </code></pre>
<p> 优先队列的示例 : 包裹分拣 </p>
<pre class="highlight"><code class="language-c linenums">/* parels.c */
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "pqueue.h"

/* 包裹的优先级 */
typedef struct Parcel_ {
    int priority;
}Parcel;
/* 取得优先级最大的包裹 , 参数 parcel 指向取得的包裹 */
int get_parcel(PQueue *parcels, Parcel *parcel)
{
    Parcel *data;
    /* 队列中没有包裹或取包裹时出错 */
    if (pqueue_size(parcels) == 0 ||
        pqueue_extract(parcels, (void **)&amp;data) != 0) {
        return -1;
    }

    memcpy(parcel, data, sizeof(Parcel));
    free(data);
    return 0;
}
/* 将包裹加入到队列中 */
int put_parcel(PQueue *parcels, const Parcel *parcel)
{
    Parcel *data;
    /* 新包裹内存 */
    if ((data = (Parcel *)malloc(sizeof(Parcel))) == NULL) {
        return -1;
    }
    memcpy(data, parcel, sizeof(Parcel));
    if (pqueue_insert(parcels, data) != 0) {
        return -1;
    }
    return 0;
}</code></pre>
            </section>

            <section class="post-info">
                <div class="post-share">
                    <a class="twitter" href="https://twitter.com/share?text=Matserting Algorithms with C-6: 堆和优先队列&amp;url=./matserting-algorithms-with-c-6-dui-he-you-xian-dui-lie.html" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <i class="ic ic-twitter"></i><span class="hidden">Twitter</span>
                    </a>
                    <a class="facebook" href="https://www.facebook.com/sharer/sharer.php?u=./matserting-algorithms-with-c-6-dui-he-you-xian-dui-lie.html" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <i class="ic ic-facebook"></i><span class="hidden">Facebook</span>
                    </a>
                    <a class="googleplus" href="https://plus.google.com/share?url=./matserting-algorithms-with-c-6-dui-he-you-xian-dui-lie.html" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <i class="ic ic-googleplus"></i><span class="hidden">Google+</span>
                    </a>
                    <div class="clear"></div>
                </div>

                <aside class="post-tags">
<a href="./tag/suan-fa.html">算法</a><a href="./tag/c.html">C</a><a href="./tag/ji-he.html">集合</a><a href="./tag/shu-ju-jie-gou.html">数据结构</a>                </aside>

                <div class="clear"></div>


                </section>


                <aside class="post-nav">
                    <div class="clear"></div>
                </aside>

            </div>
        </article>
    </main>
      <!-- TODO : Body class -->
    <div id="body-class" style="display: none;" class=""></div>

    <footer id="footer">
      <div class="inner">
        <section class="credits">


          <span class="credits-theme">Theme <a href="https://github.com/arulrajnet/attila" rel="nofollow">Attila</a></span>
          <span class="credits-software">Published with <a href="https://github.com/getpelican/pelican" rel="nofollow">Pelican</a></span>
        </section>
      </div>
    </footer>
  </section>

  <script type="text/javascript" src="./theme/js/script.js"></script>

    <!-- Script specified by the user -->
    <script type="text/javascript"  src="./assets/js/prism.js"></script>
</body>
</html>