
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index, follow" />

  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:300,400,400i,700" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="./theme/pygments/manni.min.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/font-awesome.min.css">

    <link href="./static/custom.css" rel="stylesheet">



    <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/images/favicon.ico" type="image/x-icon">

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-113622715-2', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->

<meta name="author" content="ivicel" />
<meta name="description" content="使用自带的单线程 server 看源码 1. 从 WSGI 开始 一个最简单的 Flask 程序 from flask import Flask app = Flask(__file__) @app.route(&#39;/&#39;) def index(): return &#39;Hello, world&#39; if __name__ == &#39;__main__&#39;: app.run() 在 run() 方法中可以看到调用了 werkzeug.serving.run_simple() 来运行, 传入的的 WSGI 应用就是 self 也就是 Flask 对象. 根据 WSGI 协议, 其必定是一个 callable_appliaction(environ, start_response …" />
<meta name="keywords" content="flask, python, 源代码阅读, RTFSC">

<meta property="og:site_name" content="Ivicel\s Ambertime"/>
<meta property="og:title" content="RTFSC: Flask 的源码阅读(一)"/>
<meta property="og:description" content="使用自带的单线程 server 看源码 1. 从 WSGI 开始 一个最简单的 Flask 程序 from flask import Flask app = Flask(__file__) @app.route(&#39;/&#39;) def index(): return &#39;Hello, world&#39; if __name__ == &#39;__main__&#39;: app.run() 在 run() 方法中可以看到调用了 werkzeug.serving.run_simple() 来运行, 传入的的 WSGI 应用就是 self 也就是 Flask 对象. 根据 WSGI 协议, 其必定是一个 callable_appliaction(environ, start_response …"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="./rtfsc-flask-de-yuan-ma-yue-du-yi.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2018-09-18 00:00:00+08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="./author/ivicel.html">
<meta property="article:section" content="Python"/>
<meta property="article:tag" content="flask"/>
<meta property="article:tag" content="python"/>
<meta property="article:tag" content="源代码阅读"/>
<meta property="article:tag" content="RTFSC"/>
<meta property="og:image" content="/images/favicon.ico">

  <title>Ivicel\s Ambertime &ndash; RTFSC: Flask 的源码阅读(一)</title>

</head>
<body>
  <aside>
    <div>
      <a href=".">
        <img src="/images/favicon.ico" alt="Ambertime" title="Ambertime">
      </a>
      <h1><a href=".">Ambertime</a></h1>

<p>Make memory in past times</p>

      <ul class="social">
      </ul>
    </div>


  </aside>
  <main>

    <nav>
      <a href=".">Home</a>



    </nav>

<article class="single">
  <header>
      
    <h1 id="rtfsc-flask-de-yuan-ma-yue-du-yi">RTFSC: Flask 的源码阅读(一)</h1>
    <p>
      Posted on Tue 18 September 2018 in <a href="./category/python.html">Python</a>

    </p>
  </header>


  <div>
    <blockquote>
<p>使用自带的单线程 server 看源码</p>
</blockquote>
<h4 id="1-wsgi">1. 从 WSGI 开始</h4>
<p>一个最简单的 Flask 程序</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;Hello, world&#39;</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>


<p>在 <code>run()</code> 方法中可以看到调用了 <code>werkzeug.serving.run_simple()</code> 来运行, 传入的的 <code>WSGI</code> 应用就是 <code>self</code> 也就是 <code>Flask</code> 对象. 根据 <code>WSGI</code> 协议, 其必定是一个 <code>callable_appliaction(environ, start_response)</code>. 所以下来查看类对象的 <code>__call__()</code> 方法. 可以看到真正的 <code>WSGI</code> 定义是 <code>Flask.wsgi_app()</code> 方法. </p>
<p>代码文档也说明了这样定义的原因, 就是方便我们使用时做 <code>Middleware</code>, 只要 </p>
<div class="highlight"><pre><span></span><span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span> <span class="o">=</span> <span class="n">MyMiddleware</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span><span class="p">)</span>
</pre></div>


<p>这样我们依旧还能使用 <code>Flask</code> 来方便的处理各种 HTTP 请求.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">wsgi_app</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="c1"># 生成请求上下文</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request_context</span><span class="p">(</span><span class="n">environ</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># 将其入栈</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
            <span class="c1"># 派发请求 url 到对应的处理方法中</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_dispatch_request</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># 属于 HTTP 错误, 记录出错情况, 404, 501, 403...</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">e</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># 系统程序错误</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># 向上抛, 告知 WSGI server 程序产生了错误</span>
            <span class="k">raise</span>
        <span class="c1"># 有 HTTP 返回结果</span>
        <span class="k">return</span> <span class="n">response</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="c1"># </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_ignore_error</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
            <span class="n">error</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c1"># 请求完毕时, 将请求出栈</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">auto_pop</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
</pre></div>


<h4 id="2">2. 请求上下文都初看</h4>
<p>在进入到 WSGI 之后, 根据传入的环境变量 <code>environ</code> 生成一个请求上下文对象 <code>RequestContext</code>, 调用对象的 <code>push</code> 方法.</p>
<p>根据类的文档, 上下文把当前请求相当的东西都压入栈,  然后在请求完毕的时候把这些都出栈. 这个栈指的就是 <code>flask.global._request_ctx_stack</code>, 并且在弹出栈时, 调用所有在 <code>flask.Flask.teardown_request</code> 的注册方法.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RequestContext</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">app</span><span class="p">,</span> <span class="n">environ</span><span class="p">,</span> <span class="n">request</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c1"># app 就是 Flask() 对象</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">app</span> <span class="o">=</span> <span class="n">app</span>
        <span class="c1"># 默认的 flask.wrapper.Request 实现是从 werkzeug.wrappers.Request 继承 </span>
        <span class="c1"># 这样方便我们自己实现自己的 Request</span>
        <span class="k">if</span> <span class="n">request</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">request</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">request_class</span><span class="p">(</span><span class="n">environ</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">request</span> <span class="o">=</span> <span class="n">request</span>
        <span class="c1"># 创建一个 werkzeug.routing.MapAdapter 用于检测匹配 url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">url_adapter</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">create_url_adapter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">request</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flashes</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_app_ctx_stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preserved</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_preserved_exc</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_after_request_functions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># 在这里对 url 进行了匹配</span>
        <span class="c1"># self.request.url_rule 保存了匹配的 url</span>
        <span class="c1"># self.request.view_args 保存了匹配的 query_args</span>
        <span class="c1"># 匹配失败的话, self.request.routing_exception 保存了异常对象</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_request</span><span class="p">()</span>
</pre></div>


<h4 id="3-requestcontext-appcontext">3. 所以什么是上下文: RequestContext, AppContext</h4>
<p>flask 中实现了两个全局的上下文栈, <code>flask.globals</code> 文件内</p>
<p>1) 请求上下文 <code>_request_ctx_stack</code>, 用来保存每一次 <code>HTTP Request</code> 的大部分信息, 每次请求开始时都会压入栈中, 在请求结束时被弹出栈. </p>
<p>2) 应用上下文, 根据 <code>WSGI</code> 协议, <code>WSGI</code> 分为 <code>Server</code>, <code>Client</code>, <code>Middleware</code> 三种部件, 但这三种限定也是模糊的. 只要实现 <code>S</code> 和 <code>C</code> 端两个方向的都可以叫 <code>Middleware</code>. 所以我们可以把 <code>Flask</code> 请求再一次传给另一个 <code>WSGI Application</code> 来处理, 比如 <code>Django</code> 或者多个 <code>Flask</code> 程序, 或者处理完成再返还给 <code>Flask</code>, 这就有一个应用上下文. 而 flask 自己的应用上下文是在第一次收到 <code>request</code> 的时候生成的.</p>
<p>上下文指的是, 简单理解就是记录<strong>一定区域内的信息</strong>, 离开这个区域, 这个信息就不存在了, 在这个区域内保证了一定的操作. 比如<code>with open</code>, 我们可以保证 打开/关闭 操作, 在这之内是 可读/可写 的. </p>
<p><code>Flask</code> 内实现的上下文其实只是一个 Python 字典, 字典每一个值就对应一个 stack, 是一个 list. 因为请求是并发/并行的, 也有可能多个应用程序在同时运行.  所以字典的 key 是一个需要能区分不同线程/进程的值.</p>
<div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="c1"># 首选 greenlet 的当前运行 greenlet 对象的标识符</span>
    <span class="kn">from</span> <span class="nn">greenlet</span> <span class="kn">import</span> <span class="n">getcurrent</span> <span class="k">as</span> <span class="n">get_ident</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># 没有安装 greenlet 时, 使用当前线程的 thread_local 标识, 注意 py2/3 的兼容</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">thread</span> <span class="kn">import</span> <span class="n">get_ident</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">_thread</span> <span class="kn">import</span> <span class="n">get_ident</span>
</pre></div>


<p>两个上下文都是一个栈, 都定义在 <code>flask.globals</code></p>
<div class="highlight"><pre><span></span><span class="n">_request_ctx_stack</span> <span class="o">=</span> <span class="n">LocalStack</span><span class="p">()</span>
<span class="n">_app_ctx_stack</span> <span class="o">=</span> <span class="n">LocalStack</span><span class="p">()</span>
</pre></div>


<p>栈的实现在 <code>werkzeug.local</code> 中</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Local</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        实际底层的数据实现, 使用 __slots__ 避免占用大量内存</span>
<span class="sd">        __storage__ 为实际储存数据的字典</span>
<span class="sd">        __ident_func__ 为 __storage__ 的 key</span>
<span class="sd">        实现了一些 magic method 都很简单, 主要是要 get_ident</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;__storage__&#39;</span><span class="p">,</span> <span class="s1">&#39;__ident_func__&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;__storage__&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;__ident_func__&#39;</span><span class="p">,</span> <span class="n">get_ident</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__storage__</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proxy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a proxy for a name.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">LocalProxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proxy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__release_local__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__storage__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__ident_func__</span><span class="p">(),</span> <span class="bp">None</span><span class="p">)</span>
    <span class="c1"># 因为我们把数据存储到 __storage__ 中, 对应的 setter, getter 方法</span>
    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__storage__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__ident_func__</span><span class="p">()][</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">ident</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ident_func__</span><span class="p">()</span>
        <span class="n">storage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__storage__</span>
        <span class="c1"># 每个独立的线程或者 greentlet 对象都有一个保存自己的字典</span>
        <span class="c1"># 比如在多线程状态下多个 request 时, 就有</span>
        <span class="c1"># 每个 request 都在 storage[thread_identification] = {&#39;request&#39;: value}</span>
        <span class="c1"># 注意存进来的 name 其实是最后的 key</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">storage</span><span class="p">[</span><span class="n">ident</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">storage</span><span class="p">[</span><span class="n">ident</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">value</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__storage__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__ident_func__</span><span class="p">()][</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">LocalStack</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        栈的实现, 回过来看</span>
<span class="sd">        请求上下文: _request_ctx_stack = LocalStack()</span>
<span class="sd">        应用上下文: _app_ctx_stack = LocalStack()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_local</span> <span class="o">=</span> <span class="n">Local</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__release_local__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_local</span><span class="o">.</span><span class="n">__release_local__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            当在 RequestContext 里调用 _request_ctx_stack.push 时, 也就是相当</span>
<span class="sd">            Local.__storage__[Local.__ident_func__()][&#39;stack&#39;] = [RequestContext()]</span>
<span class="sd">            对于 _app_ctx_stack, 就是存了 AppContext 对象而已</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_local</span><span class="p">,</span> <span class="s1">&#39;stack&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rv</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_local</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="n">rv</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rv</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            弹出栈顶元素, 当最后只有一个元素在栈中的时候, 这时再弹出元素时, 会把这个栈置为 None</span>
<span class="sd">            原因应该是因为这个实现 Request 也是要用的, 请求结束了, 这线程也不需要了</span>
<span class="sd">            最终调用的是 Local.__release_local__</span>
<span class="sd">            其实就是 __storage__.pop(__ident_func__(), None)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_local</span><span class="p">,</span> <span class="s1">&#39;stack&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stack</span> <span class="ow">is</span> <span class="bp">None</span>        <span class="k">if</span> <span class="n">stack</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">release_local</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_local</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;返回栈顶&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span>
</pre></div>


<p>上下文其实是很简单的结构, 关键是怎么使用, 回过来, 我们知道, 请求到来时, 使用环境变量生成了一个请求上下文, 然后调用了对象的 <code>RequestContext.push()</code> 方法</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RequestContext</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 查找当前请求栈中顶端的请求, 这里的 top 是 RequestContext 对象, 第一次为 None,</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">_request_ctx_stack</span><span class="o">.</span><span class="n">top</span>
        <span class="c1"># RequestContext.preserved 代表这个请求是否保留,</span>
        <span class="c1"># 在下一个请求(同一线程中)到来时, 把保留的请求弹出</span>
        <span class="k">if</span> <span class="n">top</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">top</span><span class="o">.</span><span class="n">preserved</span><span class="p">:</span>
            <span class="n">top</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">_preserved_exc</span><span class="p">)</span>
        <span class="c1"># 确保这个请求栈带有应用上下文 AppContext 对象</span>
        <span class="c1"># 如果请求被保留的话那么 app_ctx 不为 None, 这时我们就不再创建新的 AppContext</span>
        <span class="n">app_ctx</span> <span class="o">=</span> <span class="n">_app_ctx_stack</span><span class="o">.</span><span class="n">top</span>
        <span class="k">if</span> <span class="n">app_ctx</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">app_ctx</span><span class="o">.</span><span class="n">app</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="p">:</span>
            <span class="n">app_ctx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">app_context</span><span class="p">()</span>
            <span class="n">app_ctx</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_app_ctx_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">app_ctx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_implicit_app_ctx_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="c1"># py3 移除了该方法, 清除当前线程的 exception 信息</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="s1">&#39;exc_clear&#39;</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exc_clear</span><span class="p">()</span>
        <span class="c1"># 压入 Request 栈中</span>
        <span class="n">_request_ctx_stack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># 第一次请求时, 创建一个新的 session</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">session_interface</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">session_interface</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">session_interface</span><span class="o">.</span><span class="n">open_session</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">request</span>
            <span class="p">)</span>
            <span class="c1"># 默认的 session 是实现在内存中的 python 对象</span>
            <span class="c1"># 当网站并发达到一定规模或者需要分布式时, 我们也可以使用 redis 这样的数据库来实现</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">session_interface</span><span class="o">.</span><span class="n">make_null_session</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="p">)</span>
</pre></div>


<p>这样我们就清楚了, <code>_request_ctx_stack</code> 为我们保存了每一次的请求对象, 而且这个 <code>RequestContext</code> 对象还有对应指 <code>WSGI</code> 应用上下文, 存在对应的 <code>_app_ct_stack</code> 相同的线程标识符里的字典. 另外还有从客户端发过来的对应 <code>session</code> 信息, 这样回应一个请求的信息都具备完了.</p>
<h4 id="reference">Reference:</h4>
<ol>
<li>https://github.com/pallets/flask</li>
<li>https://github.com/pallets/werkzeug</li>
<li>http://flask.pocoo.org</li>
<li>http://werkzeug.pocoo.org</li>
</ol>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="./tag/flask.html">flask</a>
      <a href="./tag/python.html">python</a>
      <a href="./tag/yuan-dai-ma-yue-du.html">源代码阅读</a>
      <a href="./tag/rtfsc.html">RTFSC</a>
    </p>
  </div>





</article>

    <footer>
<p>
  &copy;  2018 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Powered by <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
           src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>




<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Ivicel\s Ambertime ",
  "url" : ".",
  "image": "/images/favicon.ico",
  "description": "ivicel's thoughts and writings"
}
</script>

</body>
</html>