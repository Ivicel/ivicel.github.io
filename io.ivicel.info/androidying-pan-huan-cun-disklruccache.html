<!DOCTYPE html>
<html lang="zh" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>Android硬盘缓存DiskLrucCache - Amber time</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="./androidying-pan-huan-cun-disklruccache.html">

        <meta name="author" content="ivicel" />
        <meta name="keywords" content="缓存,磁盘缓存,lru,cache,disk cache" />
        <meta name="description" content="1. DiskLruCache 的使用 DiskLruCache 并不属于 Android 源码, 只是官方推荐的一种实现方式, 可以在 这里 找到源码, 这个源码使用了其他几个自定义类里的方法, 比如读行, 出错打印. Android Developer Sample 里关于 bitmap 的加载使用到了这个类来做缓存, 可直接使用, 可以在 这里 找到源码. 另外一个 GitHub 备份地址 Android Developer Sample 里的源码没有有效的初始化 redundantOpCount, 而是为 0. 这导致如果不断退出重进应用, 很难达到封顶的 2000 行, 即使 journal 已经超出 2000 行. GitHub 上已经添加 一般来说我们都会把磁盘放到 sdcard 上, 也就是 /sdcard …" />

        <meta property="og:site_name" content="Amber time" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="Android硬盘缓存DiskLrucCache"/>
        <meta property="og:url" content="./androidying-pan-huan-cun-disklruccache.html"/>
        <meta property="og:description" content="1. DiskLruCache 的使用 DiskLruCache 并不属于 Android 源码, 只是官方推荐的一种实现方式, 可以在 这里 找到源码, 这个源码使用了其他几个自定义类里的方法, 比如读行, 出错打印. Android Developer Sample 里关于 bitmap 的加载使用到了这个类来做缓存, 可直接使用, 可以在 这里 找到源码. 另外一个 GitHub 备份地址 Android Developer Sample 里的源码没有有效的初始化 redundantOpCount, 而是为 0. 这导致如果不断退出重进应用, 很难达到封顶的 2000 行, 即使 journal 已经超出 2000 行. GitHub 上已经添加 一般来说我们都会把磁盘放到 sdcard 上, 也就是 /sdcard …"/>
        <meta property="article:published_time" content="2018-04-04" />
            <meta property="article:section" content="Android" />
            <meta property="article:tag" content="缓存" />
            <meta property="article:tag" content="磁盘缓存" />
            <meta property="article:tag" content="lru" />
            <meta property="article:tag" content="cache" />
            <meta property="article:tag" content="disk cache" />
            <meta property="article:author" content="ivicel" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="./theme/css/bootstrap.min.css" type="text/css"/>
    <link href="./theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="./theme/css/pygments/emacs.css" rel="stylesheet">
    <link rel="stylesheet" href="./theme/css/style.css" type="text/css"/>
        <link href="./theme/css/custom.css" rel="stylesheet">





</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="./" class="navbar-brand">
Amber time            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li class="active">
                            <a href="./category/android.html">Android</a>
                        </li>
                        <li >
                            <a href="./category/c-language.html">C language</a>
                        </li>
                        <li >
                            <a href="./category/data-structure-algorithms.html">Data structure algorithms</a>
                        </li>
                        <li >
                            <a href="./category/database.html">Database</a>
                        </li>
                        <li >
                            <a href="./category/java.html">Java</a>
                        </li>
                        <li >
                            <a href="./category/javascript.html">Javascript</a>
                        </li>
                        <li >
                            <a href="./category/python.html">Python</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-sm-9">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="./androidying-pan-huan-cun-disklruccache.html"
                       rel="bookmark"
                       title="Permalink to Android硬盘缓存DiskLrucCache">
                        Android硬盘缓存DiskLrucCache
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2018-04-04T00:00:00+08:00"> Wed 04 April 2018</time>
    </span>





<span class="label label-default">Tags</span>
	<a href="./tag/huan-cun.html">缓存</a>
        /
	<a href="./tag/ci-pan-huan-cun.html">磁盘缓存</a>
        /
	<a href="./tag/lru.html">lru</a>
        /
	<a href="./tag/cache.html">cache</a>
        /
	<a href="./tag/disk-cache.html">disk cache</a>
        
</footer><!-- /.post-info -->                    </div>
                </div>
                <h3 id="1-disklrucache">1. DiskLruCache 的使用</h3>
<p>DiskLruCache 并不属于 Android 源码, 只是官方推荐的一种实现方式, 可以在 <a href="https://android.googlesource.com/platform/libcore/+/jb-mr2-release/luni/src/main/java/libcore/io/StrictLineReader.java">这里</a> 找到源码, 这个源码使用了其他几个自定义类里的方法, 比如读行, 出错打印. Android Developer Sample 里关于 bitmap 的加载使用到了这个类来做缓存, 可直接使用, 可以在 <a href="https://developer.android.com/samples/DisplayingBitmaps/src/com.example.android.displayingbitmaps/util/DiskLruCache.html">这里</a> 找到源码. 另外一个 <a href="https://gist.github.com/ivicel/f98f9ba4420c9d2c5274f151b625f677">GitHub 备份地址</a></p>
<blockquote>
<p>Android Developer Sample 里的源码没有有效的初始化 redundantOpCount, 而是为 0. 这导致如果不断退出重进应用, 很难达到封顶的 2000 行, 即使 journal 已经超出 2000 行. </p>
<p>GitHub 上已经添加</p>
</blockquote>
<p>一般来说我们都会把磁盘放到 sdcard 上, 也就是 <code>/sdcard/Android/data/app_package_name/cache</code> 里, 在 <strong>SDK 19</strong> 之前, 外部存储需要声明权限 <code>WRITE_EXTERNAL_STORAGE</code>. </p>
<p>在使用外部存储之前, 还有一样需要注意的是<strong>判断是否存在外部存储</strong>. </p>
<div class="highlight"><pre><span></span><span class="kd">private</span> <span class="n">File</span> <span class="nf">getCacheDirectoryFile</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">,</span> <span class="n">String</span> <span class="n">dirName</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">File</span> <span class="n">cacheFile</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">Environment</span><span class="o">.</span><span class="na">isExternalStorageRemovable</span> <span class="o">||</span>
        <span class="n">Environment</span><span class="o">.</span><span class="na">MEDIA_MOUNTED</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">Environment</span><span class="o">.</span><span class="na">getExternalStorageState</span><span class="o">()))</span> <span class="o">{</span>
        <span class="c1">// 外部 cache</span>
        <span class="n">cacheFile</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getExternalCacheDir</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// 内部 cache</span>
        <span class="n">cacheFile</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getCacheDir</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">cacheFile</span><span class="o">,</span> <span class="n">dirName</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>


<blockquote>
<p>DiskLruCache 的缓存目录里不要跟别的缓存相互混合, 以免导致缓存出错</p>
</blockquote>
<p>DiskLruCache 构造方法是 <code>private</code>, 提供了一个 <code>DiskLruCache#open()</code> 方法来获得一个新的对象.</p>
<div class="highlight"><pre><span></span><span class="c1">// @param directory 缓存目录</span>
<span class="c1">// @param appVersion 版本号, 当版本号发生改变时, 缓存会被清空重建</span>
<span class="c1">// @param valueCount 每个节点对应该对应的数据个数, 一般传 1, 一个节点一个数据</span>
<span class="c1">// @param maxSize 缓存大小</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nf">open</span><span class="o">(</span><span class="n">File</span> <span class="n">directory</span><span class="o">,</span> <span class="kt">int</span> <span class="n">appVersion</span><span class="o">,</span> <span class="kt">int</span> <span class="n">valueCount</span><span class="o">,</span> <span class="kt">long</span> <span class="n">maxSize</span><span class="o">);</span>

<span class="c1">// 80M 缓存</span>
<span class="n">DiskLruCache</span> <span class="n">lruCache</span> <span class="o">=</span> <span class="n">DiskLruCache</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="n">getCacheDirectoryFile</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="s">&quot;images&quot;</span><span class="o">,</span>
        <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">80</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="o">);</span>
</pre></div>


<p>向缓存中写入数据, 由 <code>DiskLruCache.Editor</code> 类负责. 使用 <code>DiskLruCache#edit()</code> 方法获得一个 <code>DiskLruCache.Editor</code> 对象, 便可以打开文件输入和输出流来进行读写. 这里的 <code>newInputStream()</code> 只能读到最后一次 <code>commit</code></p>
<div class="highlight"><pre><span></span><span class="c1">// 由 key 值获得 Editor 对象, key 值一般也使用 url 的 MD5 值</span>
<span class="n">DiskLruCache</span><span class="o">.</span><span class="na">Editor</span> <span class="n">editor</span> <span class="o">=</span> <span class="n">lruCache</span><span class="o">.</span><span class="na">edit</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
<span class="c1">// 获得输出流, 参数是数据的数组下标, 指的是在 open 时传入的 valueCount 的值</span>
<span class="c1">// 这个值为一个 node 节点以数组的形式来存储多少个数据, 只存一个数据, 其下标为 0</span>
<span class="n">OutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="n">editor</span><span class="o">.</span><span class="na">newOutputStream</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="c1">// 将 bitmap 压缩成 png 写入到流中, 然后将写入结果记到日志中</span>
<span class="k">if</span> <span class="o">(</span><span class="n">bitmap</span><span class="o">.</span><span class="na">compress</span><span class="o">(</span><span class="n">Bitmap</span><span class="o">.</span><span class="na">CompressFormat</span><span class="o">.</span><span class="na">PNG</span><span class="o">,</span> <span class="mi">50</span><span class="o">,</span> <span class="n">out</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">editor</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="n">editor</span><span class="o">.</span><span class="na">abort</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>


<p>通过 <code>DiskLruCache#get()</code> 方法可以得到一个 <code>DiskLruCache.Snapshot</code> 对象, 通过这个对象可以得到缓存文件的输入流</p>
<div class="highlight"><pre><span></span><span class="c1">// 根据 key 找到对应的缓存文件</span>
<span class="n">DiskLruCache</span><span class="o">.</span><span class="na">Snapshot</span> <span class="n">snapShot</span> <span class="o">=</span> <span class="n">lruCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
<span class="n">InputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="n">snapShot</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="c1">// InputStream 是一种有序的流, 第一次读完后指针便指向流末尾. 用文件描述符即可, 或者重置指针位置</span>
<span class="n">FileDescriptor</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">getFD</span><span class="o">();</span>
<span class="c1">// 根据需要的宽高进行压缩</span>
<span class="n">bitmap</span> <span class="o">=</span> <span class="n">loadSpecifyImage</span><span class="o">(</span><span class="n">fd</span><span class="o">,</span> <span class="n">destWidth</span><span class="o">,</span> <span class="n">destHeight</span><span class="o">);</span>
</pre></div>


<h3 id="2-disklrucache">2. DiskLruCache 源码解析</h3>
<h4 id="21">2.1 头部</h4>
<p>DiskLruCache 的缓存记录最主要是对其日志文件 journal 进行操作, 一但 journal 文件遭到破坏, 缓存被会被重建. 其格式说明如下:</p>
<blockquote>
<p>```
libcore.io.DiskLruCache
1
1
2</p>
<p>DIRTY 335c4c6028171cfddfbaae1a9c313c52
CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342
REMOVE 335c4c6028171cfddfbaae1a9c313c52
DIRTY 1ab96a171faeeee38496d8b330771a7a
CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234
READ 1ab96a171faeeee38496d8b330771a7a
```</p>
</blockquote>
<ul>
<li>头部, 每一次打开(<code>DiskLruCache#open</code>)时都会验证头部是否相符, 如果存在 <strong>journal</strong> 但不相符的, 缓存被清空然后重建. 不存在 <strong>journal</strong> 的, 重建缓存:</li>
<li>第一行是文件标识 <code>MAGIC</code>, 默认为 <code>libcore.io.DiskLruCache</code></li>
<li>第二行是 DiskLruCache 类的版本号(<code>CACHE_VERSION</code>), 默认是 <code>1</code></li>
<li>第三行是传入的 App 版本号(<code>APP_VERSION</code>), 当应用版本号变动时缓存被清空. 要想在应用变更时不清空缓存传入一个<strong>固定值</strong>便可</li>
<li>第四行是 <code>valueCount</code>, 代表的是一个 <code>Node</code> 结点对应的是几个数据节点. 上面的是 <strong>两</strong> 个</li>
<li>第五行是一个空行分隔行</li>
<li>主体记录, 格式为 <code>status key value[0].length….value[N - 1].length</code>, 每列值以<strong>空格</strong>分隔</li>
<li><code>status</code> 的值有:<ul>
<li><code>DIRTRY</code> 脏数据, 代表对这条数据进行操作, 每一行 <code>DIRTY</code> 后都应该跟着一条 <code>CLEAN</code> 或者 <code>REMOVE</code>, 代表对数据的操作结束. 如果没有则这条数据为无效数据, 将被删除</li>
<li><code>CLEAN</code> 代表这条数据已经写入到磁盘中, 可以进行读写</li>
<li><code>REMOVE</code> 代表这条数据已经被删除</li>
<li><code>READ</code> 代表读取一条数据</li>
</ul>
</li>
<li><code>status</code> 后面跟着 <code>key</code>, <code>CLEAN</code> 操作后面跟着节点内每条数据的大小, 单位为 <code>byte</code>, 上面例子每个节点有两条. 这些<strong>数据的合</strong>代表当前缓存使用的大小</li>
</ul>
<h4 id="22-entry">2.2 缓存文件的内部摘要类 Entry</h4>
<p>与 LruCache 类似, DiskLruCache 也是一个最近访问最多算法, 其类内部也一样持一个 <code>LinkedHashMap</code> 对象 <code>lruEntries</code> 来记录其数据被访问记录, 结构为 <code>&lt;String, DiskLruCache#Entry&gt;</code>, <code>key</code> 是我们传入的, <code>Entry</code> 对象为内部私有类, 记录在磁盘上名为 <code>key</code> 的文件的一些信息. 比如可读, 可写, 对应 <code>key</code> 等</p>
<div class="highlight"><pre><span></span><span class="c1">// DiskLruCache#Entry</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Entry</span> <span class="o">{</span>
    <span class="c1">// 对应的 key</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">key</span><span class="o">;</span>
    <span class="c1">// 节点数据的字节数</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span><span class="o">[]</span> <span class="n">lengths</span><span class="o">;</span>
    <span class="c1">// 当一条数据有 CLEAN, 即被写到磁盘里时, 为 true</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">readable</span><span class="o">;</span>
    <span class="c1">// The ongoing edit or null if this entry is not being edited.</span>
    <span class="kd">private</span> <span class="n">Editor</span> <span class="n">currentEditor</span><span class="o">;</span>
    <span class="c1">// The sequence number of the most recently committed edit to this entry.</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">sequenceNumber</span><span class="o">;</span>

    <span class="cm">/* ... */</span>

    <span class="c1">// 一个 node 对应多个数据时, 是以 key.i 的格式为名字来保存文件</span>
    <span class="kd">public</span> <span class="n">File</span> <span class="nf">getCleanFile</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">directory</span><span class="o">,</span> <span class="n">key</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">File</span> <span class="nf">getDirtyFile</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">directory</span><span class="o">,</span> <span class="n">key</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">&quot;.tmp&quot;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h4 id="23">2.3 打开缓存</h4>
<p>DiskLruCache 的构造方法是 <code>private</code> 的, 通过静态方法 <code>DiskLruCache#open()</code> 来创建一个缓存对象. 构造方法只是简单的保存了一些属性值. 而 <code>open()</code> 方法里对 journal 文件进行了判断和验证</p>
<p>创建缓存方法</p>
<div class="highlight"><pre><span></span><span class="c1">// DiskLruCache#open()</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="n">DiskLruCache</span> <span class="nf">open</span><span class="o">(</span><span class="n">File</span> <span class="n">directory</span><span class="o">,</span> <span class="kt">int</span> <span class="n">appVersion</span><span class="o">,</span> <span class="kt">int</span> <span class="n">valueCount</span><span class="o">,</span> 
        <span class="kt">long</span> <span class="n">maxSize</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="cm">/* ... */</span>   
    <span class="c1">// prefer to pick up where we left off</span>
    <span class="n">DiskLruCache</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DiskLruCache</span><span class="o">(</span><span class="n">directory</span><span class="o">,</span> <span class="n">appVersion</span><span class="o">,</span> <span class="n">valueCount</span><span class="o">,</span> 
            <span class="n">maxSize</span><span class="o">);</span>
    <span class="c1">// 如果已经存在了 journal 文件, 读取头部进行对比</span>
    <span class="c1">// 对比失败会删除该缓存目录, 然后再重建一个缓存目录</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="na">journalFile</span><span class="o">.</span><span class="na">exists</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 验证头部, 读取日志中的每一行</span>
            <span class="c1">// 跳过 REMOVE 记录, 只保存 READ, DIRTY, CLEAN. 到 LinkedHashMap 中</span>
            <span class="c1">// CLEAN 设置 readable = true, 节点每个数据的大小到 lenghts 数组</span>
            <span class="c1">// DIRTY 设置 currentEditor = new Editor(entry)</span>
            <span class="c1">// READ 不作改变</span>
            <span class="n">cache</span><span class="o">.</span><span class="na">readJournal</span><span class="o">();</span>
            <span class="c1">// </span>
            <span class="n">cache</span><span class="o">.</span><span class="na">processJournal</span><span class="o">();</span>
            <span class="n">cache</span><span class="o">.</span><span class="na">journalWriter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedWriter</span><span class="o">(</span>
                    <span class="k">new</span> <span class="n">FileWriter</span><span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="na">journalFile</span><span class="o">,</span> <span class="kc">true</span><span class="o">),</span> <span class="n">IO_BUFFER_SIZE</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">cache</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">journalIsCorrupt</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">cache</span><span class="o">.</span><span class="na">delete</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// create a new empty cache</span>
    <span class="n">directory</span><span class="o">.</span><span class="na">mkdirs</span><span class="o">();</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DiskLruCache</span><span class="o">(</span><span class="n">directory</span><span class="o">,</span> <span class="n">appVersion</span><span class="o">,</span> <span class="n">valueCount</span><span class="o">,</span> <span class="n">maxSize</span><span class="o">);</span>
    <span class="n">cache</span><span class="o">.</span><span class="na">rebuildJournal</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">cache</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<p><code>open()</code> 里即使传入的目录不存在, DiskLruCache 也是会帮我们重建一个缓存目录的. </p>
<div class="highlight"><pre><span></span><span class="c1">// DiskLruCache#rebuildJournal()</span>
<span class="kd">private</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">rebuildJournal</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">journalWriter</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">journalWriter</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// 使用临时 journal 文件来重建缓存, 重建完成后再更名为正式的 journal 文件名</span>
    <span class="c1">// 按格式写入头部</span>
    <span class="cm">/* ... */</span>

    <span class="c1">// 将内存中已经读取的缓存记录写到文件里</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Entry</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">lruEntries</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">currentEditor</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">DIRTY</span> <span class="o">+</span> <span class="sc">&#39; &#39;</span> <span class="o">+</span> <span class="n">entry</span><span class="o">.</span><span class="na">key</span> <span class="o">+</span> <span class="sc">&#39;\n&#39;</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">CLEAN</span> <span class="o">+</span> <span class="sc">&#39; &#39;</span> <span class="o">+</span> <span class="n">entry</span><span class="o">.</span><span class="na">key</span> <span class="o">+</span> <span class="n">entry</span><span class="o">.</span><span class="na">getLengths</span><span class="o">()</span> <span class="o">+</span> <span class="sc">&#39;\n&#39;</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 关闭文件, 重命名, 将 journalWriter 指向新文件</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="n">journalFileTmp</span><span class="o">.</span><span class="na">renameTo</span><span class="o">(</span><span class="n">journalFile</span><span class="o">);</span>
    <span class="n">journalWriter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="n">FileWriter</span><span class="o">(</span><span class="n">journalFile</span><span class="o">,</span> <span class="kc">true</span><span class="o">),</span> <span class="n">IO_BUFFER_SIZE</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>


<p><code>readJournal()</code>, <code>readJournalLine()</code>, <code>processJournal()</code> 这三个方法是重要的操作 journal 文件的方法. <code>readJournal()</code> 处理好正确的头部匹配, 然后调用  <code>readJournalLine()</code> 来读取每一行主体内容. 处理的步骤为: 
1. 每读到一个 REMOVE 就删除 <code>lruEntries</code> 里对应 key 的 entry
2. 如果这一行不为 REMOVE, 并且其不在 <code>lruEntries</code> 里, 就将为其创建一个 entry 加入到链表中
3. 如果这一行为 CLEAN, 那表示这条数据已确保写到磁盘了, 设置为 <code>readable = true</code>, <code>currentEditor = null</code>, 并将该节点的数据大小进行保存
4. 如果这一行为 DIRTY, 表示这条数据有过编辑(<code>DiskLruCache#.edit()</code>), 为其创建一个编辑器
5. 如果这一行为 READ, 已经在 2 里处理过了</p>
<p>这样就处理了所有的标记符. 在 <code>processJournal()</code> 方法里, 删除掉 DIRTY 记录. 因为一条 DIRTY 只对应一条 CLEAN 或 REMOVE, REMOVE 对应的 DIRTY 我们已经在第一次读到时已经删除过. 另外在每次读到 CLEAN 时, 我们都会把其对应的 DIRTY 的 <code>currentEditor</code> 设置为 <code>null</code>, 所以只要查找 <code>currentEditor = null</code> 记录便可</p>
<div class="highlight"><pre><span></span><span class="c1">// DiskLruCache#readJournal()</span>
<span class="c1">// 这个方法主要是验证头部正确后, 把日志时的每条记录都读到 lruEntries 中</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">readJournal</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="n">InputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedInputStream</span><span class="o">(</span><span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="n">journalFile</span><span class="o">),</span> <span class="n">IO_BUFFER_SIZE</span><span class="o">);</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// 验证头部, 每次读一行, 分别与传入的值对比</span>
        <span class="cm">/* ... */</span>

        <span class="c1">// 如果头部无误, 将除 REMOVE 之外的记录读到 lruEntries 中</span>
        <span class="kt">int</span> <span class="n">lineCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">readJournalLine</span><span class="o">(</span><span class="n">readAsciiLine</span><span class="o">(</span><span class="n">in</span><span class="o">));</span>
                <span class="n">lineCount</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">EOFException</span> <span class="n">endOfJournal</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">redundantOpCount</span> <span class="o">=</span> <span class="n">lineCount</span> <span class="o">-</span> <span class="n">lruEnties</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">closeQuietly</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="c1">// DiskLruCache#readJournalLine()</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">readJournalLine</span><span class="o">(</span><span class="n">String</span> <span class="n">line</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="n">String</span><span class="o">[]</span> <span class="n">parts</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">parts</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IOException</span><span class="o">(</span><span class="s">&quot;unexpected journal line: &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 当读到 REMOVE 表示我们要删除该条对应的 DIRTY 记录</span>
    <span class="n">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">parts</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">parts</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="n">REMOVE</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">parts</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">lruEntries</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 过滤掉 REMOVE 匹配的一次 DIRTY 记录后, 剩下的记录都会读到 lruEntries</span>
    <span class="n">Entry</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">lruEntries</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">entry</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">entry</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Entry</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="n">lruEntries</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">entry</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">parts</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="n">CLEAN</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">parts</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">valueCount</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// CLEAN 表示保存了文件, 是可读的</span>
        <span class="n">entry</span><span class="o">.</span><span class="na">readable</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">entry</span><span class="o">.</span><span class="na">currentEditor</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="c1">// 设置其节点有多少份数据, copyOfRange 同 Arrays.copyOfRange</span>
        <span class="n">entry</span><span class="o">.</span><span class="na">setLengths</span><span class="o">(</span><span class="n">copyOfRange</span><span class="o">(</span><span class="n">parts</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="n">parts</span><span class="o">.</span><span class="na">length</span><span class="o">));</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">parts</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="n">DIRTY</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">parts</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 为 DIRTY 记录设置一个可写对象</span>
        <span class="n">entry</span><span class="o">.</span><span class="na">currentEditor</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Editor</span><span class="o">(</span><span class="n">entry</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">parts</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="n">READ</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">parts</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// this work was already done by calling lruEntries.get()</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IOException</span><span class="o">(</span><span class="s">&quot;unexpected journal line: &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="c1">// DiskLruCache#processJournal()</span>
<span class="c1">// 再把日志的数据都读到 lruEntries 后, 删除其中的 DIRTY 数据</span>
<span class="c1">// 因为每一条 DIRTY 至少匹配 REMOVE</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">processJournal</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="n">deleteIfExists</span><span class="o">(</span><span class="n">journalFileTmp</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Entry</span><span class="o">&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lruEntries</span><span class="o">.</span><span class="na">values</span><span class="o">().</span><span class="na">iterator</span><span class="o">();</span> <span class="n">i</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();</span> <span class="o">)</span> <span class="o">{</span>
        <span class="n">Entry</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">currentEditor</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 删除到记录不正确的 DIRTY 后, 才计算现在使用了多少容量</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">valueCount</span><span class="o">;</span> <span class="n">t</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">size</span> <span class="o">+=</span> <span class="n">entry</span><span class="o">.</span><span class="na">lengths</span><span class="o">[</span><span class="n">t</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 删除 DIRTY 记录</span>
            <span class="n">entry</span><span class="o">.</span><span class="na">currentEditor</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">valueCount</span><span class="o">;</span> <span class="n">t</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">deleteIfExists</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getCleanFile</span><span class="o">(</span><span class="n">t</span><span class="o">));</span>
                <span class="n">deleteIfExists</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getDirtyFile</span><span class="o">(</span><span class="n">t</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="n">i</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h4 id="24">2.4 写入缓存</h4>
<p>在将日志记录读到 <code>lruEntries</code> 后, 便可以进行读写操作. 写操作是获得一个 <code>DiskLruCache#Editor</code> 对象.</p>
<div class="highlight"><pre><span></span><span class="kd">private</span> <span class="kd">synchronized</span> <span class="n">Editor</span> <span class="nf">edit</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">long</span> <span class="n">expectedSequenceNumber</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="c1">// 检测文件没有关闭和 key 的有效性, 不能包含空格和换行: &#39; &#39;, &#39;\r&#39;, &#39;\n&#39;</span>
    <span class="n">checkNotClosed</span><span class="o">();</span>
    <span class="n">validateKey</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="c1">// lruEntries 中取出该记录, 如果不为 null, 说明不是新记录; 并且如果其</span>
    <span class="c1">// 保存了 currentEditor 的话说明有其他线程在编辑, 因为我们会把完成的 DIRTY 记录</span>
    <span class="c1">// 从 lruEntries 中删除掉</span>
    <span class="n">Entry</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">lruEntries</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">expectedSequenceNumber</span> <span class="o">!=</span> <span class="n">ANY_SEQUENCE_NUMBER</span>
            <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">entry</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">entry</span><span class="o">.</span><span class="na">sequenceNumber</span> <span class="o">!=</span> <span class="n">expectedSequenceNumber</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// snapshot is stale</span>
    <span class="o">}</span>
    <span class="c1">// 这里要注意如果我们获取了一次 Editor 对象, 再次获取前没有 commit/abort 操作则返回 null</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">entry</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">entry</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Entry</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="n">lruEntries</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">entry</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">currentEditor</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// another edit is in progress</span>
    <span class="o">}</span>
    <span class="c1">// 获取一个新的编辑状态</span>
    <span class="n">Editor</span> <span class="n">editor</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Editor</span><span class="o">(</span><span class="n">entry</span><span class="o">);</span>
    <span class="n">entry</span><span class="o">.</span><span class="na">currentEditor</span> <span class="o">=</span> <span class="n">editor</span><span class="o">;</span>

    <span class="c1">// 写入 DIRTY 状态</span>
    <span class="n">journalWriter</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">DIRTY</span> <span class="o">+</span> <span class="sc">&#39; &#39;</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="sc">&#39;\n&#39;</span><span class="o">);</span>
    <span class="n">journalWriter</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">editor</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<p>在拿到 <code>Editor</code> 对象之后, 便可以获得输出流, 将图片之类写到磁盘作缓存. </p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Editor</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Entry</span> <span class="n">entry</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">hasErrors</span><span class="o">;</span>

    <span class="c1">// 返回的是一个 FilterOutputStream, 如果出错就把标志位 hasErrors 设为 true</span>
    <span class="c1">// 在写完后 commit 时检查标志位, 有错误会放弃该缓存</span>
    <span class="kd">public</span> <span class="n">OutputStream</span> <span class="nf">newOutputStream</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">DiskLruCache</span><span class="o">.</span><span class="na">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">currentEditor</span> <span class="o">!=</span> <span class="k">this</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="c1">// FileOutputStream 会帮我们自动创建文件</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">FaultHidingOutputStream</span><span class="o">(</span>
                    <span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getDirtyFile</span><span class="o">(</span><span class="n">index</span><span class="o">)));</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/* ... */</span>
<span class="o">}</span>
</pre></div>


<p>调用 <code>DiskLruCache.Editor#commit()</code> 时会调用 <code>DiskLruCache#completeEdit()</code> 完成最终编辑</p>
<div class="highlight"><pre><span></span><span class="kd">private</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">completeEdit</span><span class="o">(</span><span class="n">Editor</span> <span class="n">editor</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">success</span><span class="o">)</span> 
        <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="c1">// 检查 DIRTY 文件是否创建了</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">success</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">entry</span><span class="o">.</span><span class="na">readable</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">valueCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">entry</span><span class="o">.</span><span class="na">getDirtyFile</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">exists</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">editor</span><span class="o">.</span><span class="na">abort</span><span class="o">();</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="s">&quot;edit didn&#39;t create file &quot;</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 重命名文件, 减去老的缓存大小</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">valueCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">File</span> <span class="n">dirty</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getDirtyFile</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">success</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">dirty</span><span class="o">.</span><span class="na">exists</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">File</span> <span class="n">clean</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getCleanFile</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                    <span class="n">dirty</span><span class="o">.</span><span class="na">renameTo</span><span class="o">(</span><span class="n">clean</span><span class="o">);</span>
                    <span class="kt">long</span> <span class="n">oldLength</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                    <span class="kt">long</span> <span class="n">newLength</span> <span class="o">=</span> <span class="n">clean</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
                    <span class="n">entry</span><span class="o">.</span><span class="na">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">newLength</span><span class="o">;</span>
                    <span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">oldLength</span> <span class="o">+</span> <span class="n">newLength</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">deleteIfExists</span><span class="o">(</span><span class="n">dirty</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 操作行数增加 1</span>
        <span class="n">redundantOpCount</span><span class="o">++;</span>
        <span class="c1">// 操作完成时重置为 null</span>
        <span class="n">entry</span><span class="o">.</span><span class="na">currentEditor</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">readable</span> <span class="o">|</span> <span class="n">success</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">entry</span><span class="o">.</span><span class="na">readable</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">journalWriter</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">CLEAN</span> <span class="o">+</span> <span class="sc">&#39; &#39;</span> <span class="o">+</span> <span class="n">entry</span><span class="o">.</span><span class="na">key</span> <span class="o">+</span> <span class="n">entry</span><span class="o">.</span><span class="na">getLengths</span><span class="o">()</span> <span class="o">+</span> <span class="sc">&#39;\n&#39;</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">success</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// sequenceNumber 用来记录该 entry 是否过期, 在获取 Shapshot 时会与</span>
                <span class="c1">// entry.sequenceNumber 对比, 如果不相等则是过期的</span>
                <span class="n">entry</span><span class="o">.</span><span class="na">sequenceNumber</span> <span class="o">=</span> <span class="n">nextSequenceNumber</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">lruEntries</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
            <span class="n">journalWriter</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">REMOVE</span> <span class="o">+</span> <span class="sc">&#39; &#39;</span> <span class="o">+</span> <span class="n">entry</span><span class="o">.</span><span class="na">key</span> <span class="o">+</span> <span class="sc">&#39;\n&#39;</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// 判断是否超出设定的缓存容量, 是否操作行数记录大于 2000, </span>
        <span class="c1">// 或者 redundantOpCount &gt; lruEntries.size()</span>
        <span class="c1">// 以便来决定是否在释放一些缓存</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">maxSize</span> <span class="o">||</span> <span class="n">journalRebuildRequired</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">executorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">cleanupCallable</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
</pre></div>


<h4 id="25">2.5 读取缓存</h4>
<p>通过 <code>DiskLruCache#get()</code> 获得一个 <code>Snapshot</code> 缓存对象. 该对象主要是 <code>InputStream</code> 的再封装</p>
<div class="highlight"><pre><span></span><span class="c1">// DiskLruCache#get</span>
<span class="kd">public</span> <span class="kd">synchronized</span> <span class="nf">Snapshot</span>  <span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="c1">// 检查文件是否打开, key 是否正确</span>
    <span class="cm">/* ... */</span>

    <span class="c1">// 一次性打开所有的数据以保证一个 key 即使对应多个数据也只有一个 snapshot</span>
    <span class="n">InputStream</span><span class="o">[]</span> <span class="n">ins</span> <span class="o">=</span> <span class="k">new</span> <span class="n">InputStream</span><span class="o">[</span><span class="n">valueCount</span><span class="o">];</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">valueCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">ins</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getCleanFile</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">FileNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// a file must have been deleted manually!</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 记录操作数, 写入操作记录, 之后要再检查操作记录是否超出设定</span>
    <span class="n">redundantOpCount</span><span class="o">++;</span>
    <span class="n">journalWriter</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">READ</span> <span class="o">+</span> <span class="sc">&#39; &#39;</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="sc">&#39;\n&#39;</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">journalRebuildRequired</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">executorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">cleanupCallable</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="k">new</span> <span class="n">Snapshot</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">entry</span><span class="o">.</span><span class="na">sequenceNumber</span><span class="o">,</span> <span class="n">ins</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>


<h4 id="26">2.6 删除缓存</h4>
<p>每次读, 写, 删除缓存后, 都要再次判断操作记录或者缓存大小已经超出设置的值. 删除操作主要是由一个</p>
<div class="highlight"><pre><span></span><span class="c1">// 调用 remove</span>
<span class="c1">// DiskLruCache#remove</span>
<span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="n">checkNotClosed</span><span class="o">();</span>
    <span class="n">validateKey</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="n">Entry</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">lruEntries</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">entry</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">entry</span><span class="o">.</span><span class="na">currentEditor</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 删除对应 key 的所有文件</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">valueCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">File</span> <span class="n">file</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getCleanFile</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">file</span><span class="o">.</span><span class="na">delete</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IOException</span><span class="o">(</span><span class="s">&quot;failed to delete &quot;</span> <span class="o">+</span> <span class="n">file</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">size</span> <span class="o">-=</span> <span class="n">entry</span><span class="o">.</span><span class="na">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="n">entry</span><span class="o">.</span><span class="na">lengths</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 是否要重建 journal 文件</span>
    <span class="n">redundantOpCount</span><span class="o">++;</span>
    <span class="n">journalWriter</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">REMOVE</span> <span class="o">+</span> <span class="sc">&#39; &#39;</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="sc">&#39;\n&#39;</span><span class="o">);</span>
    <span class="n">lruEntries</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">journalRebuildRequired</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">executorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">cleanupCallable</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">final</span> <span class="n">ExecutorService</span> <span class="n">executorService</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">60L</span><span class="o">,</span>
        <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">,</span> <span class="k">new</span> <span class="n">LinkBlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;());</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">Callable</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">cleanupCallable</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Callable</span><span class="o">&lt;&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Void</span> <span class="nf">call</span><span class="o">()</span> <span class="k">throw</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">DiskLruCache</span><span class="o">.</span><span class="na">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">journalWriter</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">trimeToSize</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">journalRebuildRequired</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">rebuildJournal</span><span class="o">();</span>
                <span class="n">redundantOpCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">};</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">trimToSize</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
    <span class="c1">// 循环迭代删除超出的空间</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">maxSize</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Entry</span><span class="o">&gt;</span> <span class="n">toEvict</span> <span class="o">=</span> 
            <span class="n">lruEntries</span><span class="o">.</span><span class="na">entrySet</span><span class="o">().</span><span class="na">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="n">remove</span><span class="o">(</span><span class="n">toEvict</span><span class="o">.</span><span class="na">getKey</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h3 id="reference">Reference</h3>
<ol>
<li>&lt;<Android开发艺术探索>&gt;</li>
<li><a href="https://blog.csdn.net/shakespeare001/article/details/51695358">https://blog.csdn.net/shakespeare001/article/details/51695358</a></li>
<li><a href="https://www.jianshu.com/p/b282140acc20">https://www.jianshu.com/p/b282140acc20</a></li>
<li><a href="http://nirvanawoody.com/2016/05/05/Android-DiskLruCache">http://nirvanawoody.com/2016/05/05/Android-DiskLruCache</a></li>
</ol>
            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
        <div class="col-sm-3" id="sidebar">
            <aside>

<section class="well well-sm">
    <ul class="list-group list-group-flush">
        <li class="list-group-item"><h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Social</span></h4>
              <ul class="list-group" id="social">
                <li class="list-group-item"><a href="#"><i class="fa fa-you-can-add-links-in-your-config-file-square fa-lg"></i> You can add links in your config file</a></li>
                <li class="list-group-item"><a href="#"><i class="fa fa-another-social-link-square fa-lg"></i> Another social link</a></li>
              </ul>
            </li>





    <li class="list-group-item"><h4><i class="fa fa-external-link-square fa-lg"></i><span class="icon-label">Links</span></h4>
      <ul class="list-group" id="links">
        <li class="list-group-item">
            <a href="http://getpelican.com/" target="_blank">
                Pelican
            </a>
        </li>
        <li class="list-group-item">
            <a href="http://python.org/" target="_blank">
                Python.org
            </a>
        </li>
        <li class="list-group-item">
            <a href="http://jinja.pocoo.org/" target="_blank">
                Jinja2
            </a>
        </li>
        <li class="list-group-item">
            <a href="#" target="_blank">
                You can modify those links in your config file
            </a>
        </li>
      </ul>
    </li>
    </ul>
</section>            </aside>
        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2018 ivicel
            &middot; Powered by <a href="https://github.com/getpelican/pelican-themes/tree/master/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="./theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="./theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="./theme/js/respond.min.js"></script>


</body>
</html>