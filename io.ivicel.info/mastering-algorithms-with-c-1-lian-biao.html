
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index, follow" />

  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:300,400,400i,700" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="./theme/pygments/manni.min.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/font-awesome.min.css">

    <link href="./static/custom.css" rel="stylesheet">



    <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/images/favicon.ico" type="image/x-icon">

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-113622715-2', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->

<meta name="author" content="ivicel" />
<meta name="description" content="函数的实现在判断元素结点是否为头结点或尾结点时, 并未使用 list-&gt;head list-&gt;tail 指针 而是判断该结点是否存在前一结点element-&gt;prev或后一结点element-&gt;next是否为空 这样从而导致在向指定结点前面或后面插入元素时, 不能过早将element-prev element-&gt;next 指向新结点new_element 以避免判断头尾结点失败 单链表(Linked List) /* list.h */ #ifndef LIST_H #define LIST_H #include &lt;stdlib.h&gt; /* 链表元素结构 */ typedef struct ListElmt_ { /* 指向实际数据地址 */ void *data; /* 指向下一个结点元素的指针 */ struct ListElmt_ *next; }ListElmt; /* 链表的结构定义 */ typedef struct List_ …" />
<meta name="keywords" content="算法, 数据结构, C, 链表">

<meta property="og:site_name" content="Ivicel's Ambertime"/>
<meta property="og:title" content="Mastering Algorithms with C-1: 链表"/>
<meta property="og:description" content="函数的实现在判断元素结点是否为头结点或尾结点时, 并未使用 list-&gt;head list-&gt;tail 指针 而是判断该结点是否存在前一结点element-&gt;prev或后一结点element-&gt;next是否为空 这样从而导致在向指定结点前面或后面插入元素时, 不能过早将element-prev element-&gt;next 指向新结点new_element 以避免判断头尾结点失败 单链表(Linked List) /* list.h */ #ifndef LIST_H #define LIST_H #include &lt;stdlib.h&gt; /* 链表元素结构 */ typedef struct ListElmt_ { /* 指向实际数据地址 */ void *data; /* 指向下一个结点元素的指针 */ struct ListElmt_ *next; }ListElmt; /* 链表的结构定义 */ typedef struct List_ …"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="./mastering-algorithms-with-c-1-lian-biao.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2017-03-21 00:00:00+08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="./author/ivicel.html">
<meta property="article:section" content="Data Structure Algorithms"/>
<meta property="article:tag" content="算法"/>
<meta property="article:tag" content="数据结构"/>
<meta property="article:tag" content="C"/>
<meta property="article:tag" content="链表"/>
<meta property="og:image" content="/images/favicon.ico">

  <title>Ivicel's Ambertime &ndash; Mastering Algorithms with C-1: 链表</title>

</head>
<body>
  <aside>
    <div>
      <a href=".">
        <img src="/images/favicon.ico" alt="Ambertime" title="Ambertime">
      </a>
      <h1><a href=".">Ambertime</a></h1>

<p>Make memory in past times</p>

      <ul class="social">
      </ul>
    </div>


  </aside>
  <main>

    <nav>
      <a href=".">Home</a>



    </nav>

<article class="single">
  <header>
      
    <h1 id="mastering-algorithms-with-c-1-lian-biao">Mastering Algorithms with C-1: 链表</h1>
    <p>
      Posted on Tue 21 March 2017 in <a href="./category/data-structure-algorithms.html">Data Structure Algorithms</a>

    </p>
  </header>


  <div>
    <blockquote>
<p>函数的实现在判断元素结点是否为头结点或尾结点时, 并未使用 <code>list-&gt;head</code> <code>list-&gt;tail</code> 指针<br>
而是判断该结点是否存在前一结点<code>element-&gt;prev</code>或后一结点<code>element-&gt;next</code>是否为空<br>
这样从而导致在向指定结点前面或后面插入元素时, 不能过早将<code>element-prev</code> <code>element-&gt;next</code> 指向新结点<code>new_element</code> 以避免判断头尾结点失败</p>
</blockquote>
<h4 id="linked-list"><strong>单链表</strong>(Linked List)</h4>
<div class="codehilite"><pre><span></span><span class="cm">/* list.h */</span>

<span class="cp">#ifndef LIST_H</span>
<span class="cp">#define LIST_H</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cm">/* 链表元素结构 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ListElmt_</span> <span class="p">{</span>
    <span class="cm">/* 指向实际数据地址 */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>    
    <span class="cm">/* 指向下一个结点元素的指针 */</span>
    <span class="k">struct</span> <span class="n">ListElmt_</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>         
<span class="p">}</span><span class="n">ListElmt</span><span class="p">;</span>

<span class="cm">/* 链表的结构定义 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">List_</span> <span class="p">{</span>
    <span class="cm">/* 链表中元素的个数 */</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="cm">/* 该函数由从链表结构派生而来的新类型使用 */</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">);</span>
    <span class="cm">/* 销毁链表时调用的析构函数 */</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="cm">/* 头结点 */</span>
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="cm">/* 末尾结点 */</span>
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
<span class="p">}</span><span class="n">List</span><span class="p">;</span>

<span class="cm">/* 初始化 list 指定的链表，提供一个函数 destroy 以便在调用 list_destory 来销毁链表时做些必要的工作，如释放数据内存等 */</span>
<span class="kt">void</span> <span class="nf">list_init</span><span class="p">(</span><span class="n">List</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destory</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">));</span>

<span class="cm">/* 销毁链表 */</span>
<span class="kt">void</span> <span class="nf">list_destroy</span><span class="p">(</span><span class="n">List</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>

<span class="cm">/* 单链表由于不清楚某一结点的前一结点，所以插入和删除只能操作该结点后的元素 */</span>
<span class="cm">/* 在element后插入一个元素，如果element为NULL，则在链表头头插入。成功返回0，失败返回-1 */</span>
<span class="kt">int</span> <span class="nf">list_ins_next</span><span class="p">(</span><span class="n">List</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">ListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/* 移除element后的那个元素，如果element为NULL，则移除链表头元素。</span>
<span class="cm">调用返回后，data指向已移除元素中存储的数据。成功0，失败-1 */</span>
<span class="kt">int</span> <span class="nf">list_rem_next</span><span class="p">(</span><span class="n">List</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">ListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">);</span>

<span class="cm">/* 返回元素个数 */</span>
<span class="cp">#define list_size(list) ((list)-&gt;size)</span>

<span class="cm">/* 返回链表头元素指针 */</span>
<span class="cp">#define list_head(list) ((list)-&gt;head)</span>

<span class="cm">/* 判断是否是头结点，是返回1，否则返回0 */</span>
<span class="cp">#define list_is_head(list, element) ((element) == (list)-&gt;head ? 1 : 0)</span>

<span class="cm">/* 判断链表末尾结点，是返回1，否则返回0 */</span>
<span class="cp">#define list_is_tail(element) ((element)-&gt;next == NULL ? 1 : 0)</span>

<span class="cm">/* 返回结点中保存的数据 */</span>
<span class="cp">#define list_data(element) ((element)-&gt;data)</span>

<span class="cm">/* 返回element的下一个结点 */</span>
<span class="cp">#define list_next(element) ((element)-&gt;next)</span>

<span class="cp">#endif</span>
</pre></div>


<p>元素插入链表</p>
<p><img alt="元素插入链表" src="../images/元素插入链表.png" /></p>
<p>函数实现</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&quot;list.h&quot;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">list_init</span><span class="p">(</span><span class="n">List</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">))</span> 
<span class="p">{</span>
    <span class="cm">/* 初始化链表 */</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">;</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">list_destroy</span><span class="p">(</span><span class="n">List</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="cm">/* 移除链表中所有元素 */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">list_size</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list_rem_next</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* 当 destroy 不为 NULL 时，对数据调用 */</span>
            <span class="n">list</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* 清空置0链表内存 */</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">list</span><span class="p">));</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">list_ins_next</span><span class="p">(</span><span class="n">List</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">ListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">new_element</span><span class="p">;</span>
    <span class="cm">/* 为新元素申请内存 */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">new_element</span> <span class="o">=</span> <span class="p">(</span><span class="n">ListElmt</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ListElmt</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">new_element</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 空链表时，新插入元素是末尾元素 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list_size</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">new_element</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">new_element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">new_element</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* element 是末尾元素时，新插入元素是末尾元素 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">new_element</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">new_element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_element</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* 链表长度增加1 */</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">list_rem_next</span><span class="p">(</span><span class="n">List</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">ListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">old_element</span><span class="p">;</span>

    <span class="cm">/* 空链表 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">old_element</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">old_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

        <span class="cm">/* 链表中只有一个元素时，删除后，head 和 tail 均指向 NULL */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list_size</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">lsit</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* element 是末尾结点时，返回 -1 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">old_element</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">old_element</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">old_element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

        <span class="cm">/* element 下一结点为末尾结点时，删除后 element 为末尾结点 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* 更改链表长度 */</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>单链表应用：页帧管理(Frame Management)</p>
<ul>
<li>使用链表管理一个页表(page table)，链表大小预设为页表的大小</li>
<li>假定页表在系统启动的时候已经被初始化，并且页表中的元素数据 <code>frame_number</code> 已经映射到真正的物理内存</li>
<li>链表是虚拟内存和物理内存的映射，页表的操作总是在头结点</li>
<li>当需要申请一个真正的物理内存地址时，总是检查页表的大小，页表大小为 0 时即映射的内存已使用完;</li>
<li>如果有可用的页表，<code>alloc_frame</code> 返回其页表号码，并释放其<code>data</code>指向的内存以便令程序可能使用</li>
<li>释放页表时，重新为页表元素数据申请一个内存，如果没有可用内存，释放失败</li>
</ul>
<p><img alt="页帧映射" src="https://ivicel.github.io/images/页表映射.png" /></p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;list.h&quot;</span><span class="cp"></span>

<span class="cm">/* 申请空闲页帧 */</span>
<span class="kt">int</span> <span class="nf">alloc_frame</span><span class="p">(</span><span class="n">List</span> <span class="o">*</span><span class="n">frames</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">frame_number</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">list_size</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 无可用物理内存 */</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list_rem_next</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* 页表号是内存映射地址 */</span>
            <span class="n">frame_number</span> <span class="o">=</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
            <span class="cm">/* 释放该内存以及令程序使用 */</span>
            <span class="n">free</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">frmae_number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">free_frame</span><span class="p">(</span><span class="n">List</span> <span class="o">*</span><span class="n">frames</span><span class="p">,</span> <span class="kt">int</span> <span class="n">frame_number</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

    <span class="cm">/* 重新申请一个内存来作页表的映射，避免程序申请页表时导致</span>
<span class="cm">       有空闲的页帧，实际却没有空闲的内存可用 */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">frame_number</span><span class="p">;</span>
    <span class="cm">/* 将数据插入链表头结点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">list_ins_next</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<ul>
<li><strong>双向链表</strong>(Doubly-Linked List)</li>
</ul>
<p><img alt="双向链表" src="https://ivicel.github.io./images/双向链表.png" /></p>
<p>头文件</p>
<div class="codehilite"><pre><span></span><span class="cm">/* dlist.h */</span>
<span class="cp">#ifndef DLIST_H</span>
<span class="cp">#define DLIST_H</span>

<span class="cm">/* 双向链表元素结构 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">DListElmt_</span> <span class="p">{</span>
    <span class="cm">/* 指向存储的数据 */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="cm">/* 指向前一结点 */</span>
    <span class="k">struct</span> <span class="n">DListElmt_</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
    <span class="cm">/* 指向后一个结点 */</span>
    <span class="k">struct</span> <span class="n">DListElmt_</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="n">DListElmt</span><span class="p">;</span>

<span class="cm">/* 双向链表 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">DList_</span> <span class="p">{</span>
    <span class="cm">/* 链表大小 */</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">);</span>
    <span class="cm">/* 销毁时数据回调函数 */</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="cm">/* 头结点 */</span>
    <span class="n">DListElmt</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="n">DListElmt</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
<span class="p">}</span><span class="n">DList</span><span class="p">;</span>

<span class="cm">/* 链表初始化 */</span>
<span class="kt">void</span> <span class="nf">dlist_init</span><span class="p">(</span><span class="n">DList</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">));</span>
<span class="cm">/* 销毁链表 */</span>
<span class="kt">void</span> <span class="nf">destroy</span><span class="p">(</span><span class="n">DList</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>
<span class="cm">/* 向element后插入一个结点，element为NULL时表示向空链表插入新结点 */</span>
<span class="kt">int</span> <span class="nf">dlist_ins_next</span><span class="p">(</span><span class="n">DList</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">DListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* 向element前插入一个结点，element为NULL时删除失败 */</span>
<span class="n">inst</span> <span class="nf">dlist_ins_prev</span><span class="p">(</span><span class="n">DList</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">DListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* 由于有指向前一结点和后一结点的指针，所以双向链表可以直接删除指定结点 */</span>
<span class="kt">int</span> <span class="nf">dlist_remove</span><span class="p">(</span><span class="n">DList</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">DListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* 返回链表大小 */</span>
<span class="cp">#define dlist_size(list) ((list)-&gt;size)</span>
<span class="cm">/* 返回链表头结点 */</span>
<span class="cp">#define dlist_head(list) ((list)-&gt;head)</span>
<span class="cm">/* 返回链表尾结点 */</span>
<span class="cp">#define dlist_tail(list) ((list)-&gt;tail)</span>
<span class="cm">/* 判断是否是头结点 */</span>
<span class="cp">#define dlist_is_head(element) ((element)-&gt;prev == NULL ? 1 : 0)</span>
<span class="cm">/* 判断是否是尾结点 */</span>
<span class="cp">#define dlist_is_tail(element) ((element)-&gt;next == NULL ? 1 : 0)</span>
<span class="cm">/* 返回结点指向数据 */</span>
<span class="cp">#define dlist_data(element) ((element)-&gt;data)</span>
<span class="cm">/* 返回结点的前一结点 */</span>
<span class="cp">#define dlist_prev(element) ((element)-&gt;prev)</span>
<span class="cm">/* 返回结点的后一结点 */</span>
<span class="cp">#define dlist_next(element) ((element)-&gt;next)</span>

<span class="cp">#endif</span>
</pre></div>


<p>函数实现</p>
<div class="codehilite"><pre><span></span><span class="cm">/* dlist.c */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;dlist.h&quot;</span><span class="cp"></span>

<span class="cm">/* 初始化 */</span>
<span class="kt">void</span> <span class="nf">dlist_init</span><span class="p">(</span><span class="n">DList</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">;</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span>

    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 销毁 */</span>
<span class="kt">void</span> <span class="nf">dlist_destroy</span><span class="p">(</span><span class="n">DList</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="cm">/* 删除所有结点 */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">dlist</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dlist_remove</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">dlist_tail</span><span class="p">(</span><span class="n">list</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* 调用数据回调函数 */</span>
            <span class="n">list</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">(</span><span class="n">DList</span><span class="p">));</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 向后插入一结点 */</span>
<span class="kt">int</span> <span class="nf">dlist_ins_next</span><span class="p">(</span><span class="n">DList</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">DListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DListElmt</span> <span class="o">*</span><span class="n">new_element</span><span class="p">;</span>
    <span class="cm">/* 为避免混淆, NULL 仅用向空链表插入元素 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">dlist_size</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* 申请结点内存 */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">new_element</span> <span class="o">=</span> <span class="p">(</span><span class="n">DListElmt</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">DListElmt</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">new_element</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dlist_size</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 当链表为空时 */</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">new_element</span><span class="p">;</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">new_element</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* 无论 element 情况如何, new_element 的 prev 和 next 指向不会变</span>
<span class="cm">        只会指向 element 和其后一结点 */</span>
        <span class="n">new_element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">new_element</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* 当链表中只有一个结点时, 新结点是末尾结点 */</span>
            <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">new_element</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">new_element</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_element</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 向结点前插入 */</span>
<span class="kt">int</span> <span class="nf">dlist_ins_prev</span><span class="p">(</span><span class="n">DList</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">DListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DListElmt</span> <span class="o">*</span><span class="n">new_element</span><span class="p">;</span>
    <span class="cm">/* NULL 用作向空链表插入结点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">dlist_size</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* 申请结点内存 */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">new_element</span> <span class="o">=</span> <span class="p">(</span><span class="n">DListElmt</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">DListElmt</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">new_element</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dlist_size</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 空链表 */</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">new_element</span><span class="p">;</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">new_element</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* 无论 element 情况如何, new_element 的 next 和 prev 指向不会变</span>
<span class="cm">        只会指向 element 和其前一结点 */</span>
        <span class="n">new_element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
        <span class="n">new_element</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* element 是头结点时, 重新调整头结头指向 */</span>
            <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">new_element</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* 非头结点时, 将前一结点的后结点指向 new_element */</span>
            <span class="n">new_element</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_element</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">element</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">new_element</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">dlist</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 删除结点 */</span>
<span class="kt">int</span> <span class="nf">dlist_remove</span><span class="p">(</span><span class="n">DList</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">DListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 无法删除 NULL 或者空链表 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">list_size</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">==</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 删除头结点 */</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* 头结点也是末尾结点 */</span>
            <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">element</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* element 是末尾结点 */</span>
            <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
    <span class="n">dlist</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<ul>
<li><strong>循环链表</strong>(Circular Lists)</li>
</ul>
<p><img alt="循环链表" src="../images/循环链表.png" /></p>
<div class="codehilite"><pre><span></span><span class="cm">/* clist.h */</span>
<span class="cp">#ifndef CLIST_H</span>
<span class="cp">#define CLIST_H</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="cm">/* 结点定义 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">CListElmt_</span> <span class="p">{</span>
    <span class="cm">/* 指向数据 */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="cm">/* 指向下一结点 */</span>
    <span class="k">struct</span> <span class="n">CListElmt</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="n">CListElmt</span><span class="p">;</span>

<span class="cm">/* 链表定义 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">CList_</span> <span class="p">{</span>
    <span class="cm">/* 链表大小 */</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">);</span>
    <span class="cm">/* 链表销毁回调函数 */</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="cm">/* 头结点 */</span>
    <span class="n">CListElmt</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span><span class="n">CList</span><span class="p">;</span>
<span class="cm">/* 初始化链表 */</span>
<span class="kt">void</span> <span class="nf">clist_init</span><span class="p">(</span><span class="n">CList</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">));</span>
<span class="cm">/* 销毁链表 */</span>
<span class="kt">void</span> <span class="nf">clist_destroy</span><span class="p">(</span><span class="n">CList</span> <span class="o">*</span><span class="n">list</span><span class="p">);</span>
<span class="cm">/* 向 element 后插入结点, 向空链表插入元素时, element 可以是任何值, 但避免混乱最好为 NULL */</span>
<span class="kt">int</span> <span class="nf">clist_ins_next</span><span class="p">(</span><span class="n">CList</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">CListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* 删除 element 后一结点, element 传入 NULL 返回-1 */</span>
<span class="kt">int</span> <span class="nf">clist_rem_next</span><span class="p">(</span><span class="n">CList</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">CListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* 返回链表大小 */</span>
<span class="cp">#define clist_size(list) ((list)-&gt;size)</span>
<span class="cm">/* 返回头结点 */</span>
<span class="cp">#define clist_head(list) ((list)-&gt;head)</span>
<span class="cm">/* 返回结点数据 */</span>
<span class="cp">#define clist_data(element) ((element)-&gt;data)</span>
<span class="cm">/* 返回结点的下一结点 */</span>
<span class="cp">#define clist_next(element) ((element)-&gt;next)</span>

<span class="cp">#endif</span>
</pre></div>


<p>函数实现</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;clist.h&quot;</span><span class="cp"></span>

<span class="cm">/* 初始化 */</span>
<span class="kt">void</span> <span class="nf">clist_init</span><span class="p">(</span><span class="n">CList</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">;</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 销毁 */</span>
<span class="kt">void</span> <span class="nf">clist_destroy</span><span class="p">(</span><span class="n">CList</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">clist_size</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">clist_rem_next</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">list</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CList</span><span class="p">));</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 插入结点 */</span>
<span class="kt">int</span> <span class="nf">clist_ins_next</span><span class="p">(</span><span class="n">CList</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">CListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CListElmt</span> <span class="o">*</span><span class="n">new_element</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">new_element</span> <span class="o">=</span> <span class="p">(</span><span class="n">CListElmt</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">CListElmt</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">new_element</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 向空链表插入元素 */</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">new_element</span><span class="p">;</span>
        <span class="n">new_element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_element</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">new_element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_element</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 删除结点 */</span>
<span class="kt">int</span> <span class="nf">clist_rem_next</span><span class="p">(</span><span class="n">CList</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">CListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CListElmt</span> <span class="o">*</span><span class="n">old_element</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">list_size</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">element</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 链表只有一个元素 */</span>
        <span class="n">old_element</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">old_element</span> <span class="o">=</span> <span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">element</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">old_element</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list_head</span><span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="o">==</span> <span class="n">old_element</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">old_element</span><span class="o">-&gt;</span><span class="n">next</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">old_element</span><span class="p">);</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="./tag/suan-fa.html">算法</a>
      <a href="./tag/shu-ju-jie-gou.html">数据结构</a>
      <a href="./tag/c.html">C</a>
      <a href="./tag/lian-biao.html">链表</a>
    </p>
  </div>





</article>

    <footer>
<p>
  &copy;  2018 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Powered by <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
           src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>




<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Ivicel's Ambertime ",
  "url" : ".",
  "image": "/images/favicon.ico",
  "description": "ivicel's thoughts and writings"
}
</script>

</body>
</html>