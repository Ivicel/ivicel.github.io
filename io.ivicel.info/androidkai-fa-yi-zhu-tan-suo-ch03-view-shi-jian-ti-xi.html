<!DOCTYPE html>
<html lang="zh" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>Android开发艺术探索Ch03 - View 事件体系 - Amber time</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="./androidkai-fa-yi-zhu-tan-suo-ch03-view-shi-jian-ti-xi.html">

        <meta name="author" content="ivicel" />
        <meta name="keywords" content="view事件,view坐标,view滑动,view触摸" />
        <meta name="description" content="一. view坐标和滑动方法 View的坐标系 屏幕的坐标原点为屏幕的左上角, 往右为正向x轴, 往下为正向y轴. 坐标参数顺序一般为左, 上, 右, 下 子view可以获取其相对于父ViewGroup的坐标. 这个要跟点击事件MotionEvent的坐标获取方法区别开来 view由于是一个框模型, 所以当确定左上点和右下点的位置, 我们便可以确定一个view的大小和位置. 获得左上点坐标为 (View.getLeft(), View.getTop()) 获得右下点坐标 (View.getRight(), View.getBottom()) 所以一个view的大小便可以这样计算 宽度width = getRight() - getLeft() 高度height = getBottom() - getTop …" />

        <meta property="og:site_name" content="Amber time" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="Android开发艺术探索Ch03 - View 事件体系"/>
        <meta property="og:url" content="./androidkai-fa-yi-zhu-tan-suo-ch03-view-shi-jian-ti-xi.html"/>
        <meta property="og:description" content="一. view坐标和滑动方法 View的坐标系 屏幕的坐标原点为屏幕的左上角, 往右为正向x轴, 往下为正向y轴. 坐标参数顺序一般为左, 上, 右, 下 子view可以获取其相对于父ViewGroup的坐标. 这个要跟点击事件MotionEvent的坐标获取方法区别开来 view由于是一个框模型, 所以当确定左上点和右下点的位置, 我们便可以确定一个view的大小和位置. 获得左上点坐标为 (View.getLeft(), View.getTop()) 获得右下点坐标 (View.getRight(), View.getBottom()) 所以一个view的大小便可以这样计算 宽度width = getRight() - getLeft() 高度height = getBottom() - getTop …"/>
        <meta property="article:published_time" content="2018-02-22" />
            <meta property="article:section" content="Android" />
            <meta property="article:tag" content="view事件" />
            <meta property="article:tag" content="view坐标" />
            <meta property="article:tag" content="view滑动" />
            <meta property="article:tag" content="view触摸" />
            <meta property="article:author" content="ivicel" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="./theme/css/bootstrap.min.css" type="text/css"/>
    <link href="./theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="./theme/css/pygments/default.css" rel="stylesheet">
    <link rel="stylesheet" href="./theme/css/style.css" type="text/css"/>





</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="./" class="navbar-brand">
Amber time            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li class="active">
                            <a href="./category/android.html">Android</a>
                        </li>
                        <li >
                            <a href="./category/c-language.html">C language</a>
                        </li>
                        <li >
                            <a href="./category/data-structure-algorithms.html">Data structure algorithms</a>
                        </li>
                        <li >
                            <a href="./category/database.html">Database</a>
                        </li>
                        <li >
                            <a href="./category/java.html">Java</a>
                        </li>
                        <li >
                            <a href="./category/javascript.html">Javascript</a>
                        </li>
                        <li >
                            <a href="./category/python.html">Python</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-sm-9">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="./androidkai-fa-yi-zhu-tan-suo-ch03-view-shi-jian-ti-xi.html"
                       rel="bookmark"
                       title="Permalink to Android开发艺术探索Ch03 - View 事件体系">
                        Android开发艺术探索Ch03 - View 事件体系
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2018-02-22T00:00:00+08:00"> Thu 22 February 2018</time>
    </span>





<span class="label label-default">Tags</span>
	<a href="./tag/viewshi-jian.html">view事件</a>
        /
	<a href="./tag/viewzuo-biao.html">view坐标</a>
        /
	<a href="./tag/viewhua-dong.html">view滑动</a>
        /
	<a href="./tag/viewhong-mo.html">view触摸</a>
        
</footer><!-- /.post-info -->                    </div>
                </div>
                <h4 id="view">一.  <code>view</code>坐标和滑动方法</h4>
<ul>
<li><code>View</code>的坐标系</li>
</ul>
<p>屏幕的坐标原点为屏幕的左上角, 往右为<strong>正向x轴</strong>, 往下为<strong>正向y轴</strong>. 坐标参数顺序一般为<code>左</code>, <code>上</code>, <code>右</code>, <code>下</code></p>
<p>子<code>view</code>可以获取其相对于父<code>ViewGroup</code>的坐标.  这个要跟点击事件<code>MotionEvent</code>的坐标获取方法区别开来</p>
<blockquote>
<p><code>view</code>由于是一个框模型, 所以当确定左上点和右下点的位置, 我们便可以确定一个<code>view</code>的大小和位置.</p>
<p>获得左上点坐标为 <strong>(<code>View.getLeft()</code>, <code>View.getTop()</code>)</strong></p>
<p>获得右下点坐标 <strong>(<code>View.getRight()</code>, <code>View.getBottom()</code>)</strong></p>
<p>所以一个<code>view</code>的大小便可以这样计算</p>
<p>宽度<code>width = getRight() - getLeft()</code></p>
<p>高度<code>height = getBottom() - getTop()</code></p>
<p>这4个方法获得是<code>view</code>布局时的原始坐标, 其值在测量布局后不会再改变. 而一个<code>view</code>真正在屏幕显示的位置是其偏移量<code>translate</code>和<strong>原始位置</strong>共同决定的. 这其中我们只要确定左上点的位置便可. 其实际左上点位置关系为:</p>
<p>左上点横坐标: <code>float View.getX() = int View.getLeft() + float View.getTranslationX()</code></p>
<p>左上点纵坐标: <code>float View.getY() = int View.getTop() + float View.getTranslationY()</code></p>
<p>在引入了<code>Z轴</code>之后(<strong>API 21</strong>), <code>Z轴</code>关系为: <code>float View.getZ() = int View.getElevation() + float View.getTranslationZ()</code></p>
</blockquote>
<p>特别需要注意的是, 在<code>activity</code>中调用这些方法时, 得到的值是0, 因为此时<code>view</code>还未布局, 需要等要<code>view.onMeasure</code>之后才会进行赋值. 有4种方法来获取这些值.</p>
<ol>
<li>使用 <code>ViewTreeObserver</code>监听<code>view</code>的 Draw/Layout 事件</li>
<li>将一个runnable添加到Layout队列中, 使用 <code>View.post</code></li>
<li>重写<code>view.onLayout</code>方法</li>
<li>重写<code>Activity.onWindowFocusChange</code>方法</li>
</ol>
<p><img alt="view坐标" src="../images/view坐标.png" /></p>
<ul>
<li>触摸事件<code>MotionEvent</code>和<code>TouchSlop</code></li>
</ul>
<p>单指触摸屏幕时, 一般会产生<code>MotionEvent.ACTION_DOWN</code>(手指接触屏幕时), <code>MotionEvent.ACTION_MOVE</code>(手指移动时), <code>MotionEvent.ACTION_UP</code>(手指离开屏幕时). </p>
<p>触摸事件产生时, 可以获取其位置.</p>
<p>获取其相对<strong>当前<code>View</code></strong>的位置: 相对左边<code>MotionEvent.getX()</code>, 相对上边<code>MotionEvent.getY()</code></p>
<p>获取共相对<strong>屏幕</strong>的位置: 相对屏幕左边<code>MotionEvent.getRawX()</code>, 相对屏幕上边<code>MotionEvent.getRawY()</code></p>
<p><code>TouchSlop</code>为系统所能识别出的最小的距离, 其值由系统决定. 可以通过<code>ViewConfiguration.getScaledTouchSlop()</code>来获得</p>
<p>​</p>
<ul>
<li>滑动速度追踪<code>VelocityTracker</code></li>
</ul>
<p>滑动速度指的是在某一个时间段内的速度. </p>
<p><code>java
  /* 首先可以在 View 中的 onTouchEvent 内获得追踪事件 */
  VelocityTracker vt = VelocityTracker.obtain();
  vt.addMovement(event);
  /* 然后必须要先设定时间段以便计算出该时间内的速度, 最后再获取速度, 速度为负时表示向左滑动 */
  vt.computeCurrentVelocity(1000);          //计算1000ms内的速度
  int xVelocity = (int)vt.getXVelocity();       //横向速度, 手指向左滑动为负
  int yVelocity = (int)vt.getYVelocity();       //纵向速度, 手指向上滑动为负
  /* 回收内存 */
  vt.clear();
  vt.recycle();</code></p>
<ul>
<li>手势检测<code>GestureDetector</code>, 单击, 滑动, 长按, 双击</li>
</ul>
<p><code>java
  // 在view 里onTouchEvent中截断事件来进行监听
  GestureDetector mGestureDetector = new GestureDetector(context);
  // 设置是否需要长按
  mGestureDetector.setIsLongpressEnabled(false);
  return mGestureDetector.onTouchEvent(event);</code></p>
<ul>
<li><code>GestureDetector.OnGestureListener</code>接口<ol>
<li><code>onDown</code>手指触摸到屏幕时.由一个<code>ACTION_DOWN</code>触发</li>
<li><code>onShowPress</code>手指触摸到屏但没有松开或者是移动, 一般用来给用户触摸找反馈, 高亮文本.由一个<code>ACTION_DOWN</code>触发.</li>
<li><code>onSingleTapUp</code>手指(在触摸后)松开, 单击行为. 伴随一个<code>MotionEvent.ACTION_UP</code></li>
<li><code>onScroll</code>手指触摸屏幕后滚动, 由一个<code>ACTION_DOWN</code>和多个<code>ACTION_MOVE</code>触发</li>
<li><code>onLongPress</code>触摸后长按</li>
<li><code>onFling</code>按下屏幕后, 快速滑动后松开. 由一个<code>ACTION_DOWN</code>和多个<code>ACTION_MOVE</code>和一个<code>ACTION_UP</code>触发</li>
</ol>
</li>
<li>
<p><code>GestureDetector.OnDoubleTapListener</code>接口</p>
<ol>
<li><code>onDoubleTap</code>双击. 不能和<code>onSingleTapConfirmed</code>共存</li>
<li><code>onSingleTapConfirmed</code>严格的单击行为. 如果触发了这个, 即使接下快速第二次触击也会被认为是一次单击而不是产生双击行为.</li>
<li><code>onDoubleTapEvent</code>表示发生了双击行为. 会依次调用<code>ACTION_DOWN</code>, <code>ACTION_MOVE</code>, <code>ACTION_UP</code></li>
</ol>
</li>
<li>
<p><code>view</code>的滑动方法. </p>
</li>
</ul>
<ol>
<li>
<p>通过<code>view.scrollTo</code>和<code>view.scrollBy</code>方法滑动</p>
<p>注意这两个方法滚动的<strong>并非<code>view</code>本身</strong>而是<strong><code>view</code>的内容</strong>, 所以要想滑动某个<code>view</code>, 需要获取到其父<code>view</code>然后到父<code>view</code>进行滑动. 即<code>((View)childView.getParent()).scrollX</code>如此.</p>
<p><code>scrollBy</code>其中也是调用<code>scrollTo</code>来滑动, 只不过中内部进行了计算<code>scrollTo(offsetX + mScrollX, offsetY + mScrollY)</code>. 而<code>scrollTo</code>在内部调用了<code>invalidateInternal(left - mScrollX, top - mScrollY, right - mScrollX, bottom - mScrollY, true, false)</code>, 其中<code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>为上次的坐标点. 所以当传入<strong>负数</strong>的时候才是向右移动</p>
<p><code>mScrollX</code>和<code>mScrollY</code>分别左内容边框到view左边框, 上内容边框到view上边框的大小, 可以通过<code>view.getScrollX()</code>, <code>view.getScrollY()</code>获得该值</p>
</li>
<li>
<p>通过动画给<code>view</code>施加平移效果</p>
<p>这种方法便是通过改变<code>view</code>的<code>translationX</code>和<code>translationY</code>值. </p>
<p>老旧的动画方法并没有真的改变了<code>view</code>的位置, 所以在<code>view</code>"移动"到新位置时, 其一些比如单击事件并不能通过点击新位置产生. 这些可以使用属性动画解决, 而现在也只使用属性动画(Property Animator)</p>
</li>
<li>
<p>通过改变<code>view</code>的<code>LayoutParams</code>参数使得<code>view</code>重新布局</p>
<p>比如发变<code>view</code>的<code>margin</code>等等, 或者通其一些关联的<code>view</code>做变化, 以便影响到目标<code>view</code>. </p>
<p>比如在一个垂直的<code>LinearLayout</code>, 上边是一个高度为0的<code>view</code>, 下面为目标<code>view</code>, 通过改变上边<code>view</code>的高度来使用目标<code>view</code>的高度发生变化</p>
</li>
<li>
<p>使用<code>Scroller</code>类.</p>
<p><code>Scroller</code>类是一个滑动的<code>Helper</code>类, 其本质上是使用<code>view.scrollTo</code>方法来滑动, 但内部有一个可定义<code>Interpolator</code>类, 即插值属性来提供滑动变动曲线, 使得滑动更加的流畅.</p>
<p>```java
 /<em> 一般使用 Scroller 类来滚动 View 时, 都使用在自定义 View 中 
  * 在自定义 View 的构造方法获取一个 Scroller 实例
  * 然后重写 View.computeScroll 方法, 该方法会在重绘 view 时被调用
  * 在 View.computeScroll 中使用 Scroller.computeScrollOffset 来确认是否完成滑动
  * 若是没有完成, 则调用 View.scrollTo 来滑动 View 内容的位置, 然后再次调用 View.postInvalidate 方法促使 View 重绘以便再次检查滑动是否完成
  * 如此的反复回调直到滑动的完成
  </em>/
 public class CustomView extends View {
    private Scroller mScroller;</p>
<div class="highlight"><pre><span></span>public CustomView(Context context, AttributeSet attrs, int defStyleAttr) {
   super(context, attrs, defStyleAtrr);
   mScroller = new Scroller(context);
 }

/* 提供一个外部使用的滚动方法, 参数为滚动的目标坐标, 同 view.scrollTo */
public void smoothScrollTo(int destX, int destY) {
    int deltaX = destX - getScrollX();
    int deltaY = destY - getScrollY();
    /* 该方法并没有产生滑动, 而只是设置了一变量值, 比如初始位置和滑动距离, 滑动时间等 */
    mScroller.startScroll(getScrollX(), getScrollY(), deltaX, deltaY);
    /* 促使 view 进行重绘 */
    invalidate();
 }

public void smoothScrollBy(int deltaX, int deltaY) {
    smoothScrollTo(mScroller.getCurrX() + deltaX, mScroller.getCurrY() + deltaY);  
 }

@Override
public void computeScroll() {
     /* view 在绘制的时候会调用该方法
      * 此时我们调用 scroller.computeScrollOffset 来确认是否已经滑动到目标位置
      * 若是没有的话, 返回 true. 然后我们继续滑动 view 的位置 
      */
    if (mScroller.computeScrollOffset()) {
        /* 真正的滑动调用, mScroller.getCurrX(), getCurrY() 方法获得的是在设计时间 duration 时计算后的位置, 而 getFinalX() 则获得最终位置. */
        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
        /* 因为滑动可能还没有完成, 所以再次调用一次 view 重绘 */
        postInvalidate();
     }
 }
</pre></div>


<p>}
 ```</p>
</li>
</ol>
<hr />
<h4 id="view_1">二. <code>view</code>事件的分发体系</h4>
<p>同一事件序列是指手指接触屏幕的那一刻起, 到手指离开屏幕的进结束, 这其中产的一系列事件. 这包括<code>ACTION_DOWN</code>和0个或多个<code>ACTION_MOVE</code>和<code>ACTION_UP</code>事件. </p>
<p>在默认不做特殊处理的情况下一个事件序列只能被一个<code>view</code>处理</p>
<p><code>view</code>的事件分发首先由<code>Activity</code>最先捕获, 然后一层一层的分发到具体的子<code>view</code>, 如果中途没有被截断的话;</p>
<p>子<code>view</code>如果没有处理这个事件的话, 最后再沿路返回到<code>Activity</code>中.</p>
<p>首先看<code>Activity#dispatchTouchEvent</code>和<code>PhoneWindow#superDispatchTouchEvent</code>代码</p>
<div class="highlight"><pre><span></span><span class="c1">// Activity#dispatchTouchEvent</span>

<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">dispatchTouchEvent</span><span class="o">(</span><span class="n">MotionEvent</span> <span class="n">ev</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ev</span><span class="o">.</span><span class="na">getAction</span><span class="o">()</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_DOWN</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/*</span>
<span class="cm">         * onUserInteraction() 是一个空方法, 可以覆写这个方法来检测用户与手机产生的交互</span>
<span class="cm">         * 对应的还有 onUserLeaveHint() 来检测用户手指离开了屏幕</span>
<span class="cm">         */</span>
        <span class="n">onUserInteraction</span><span class="o">();</span> 
    <span class="o">}</span>
    <span class="cm">/*</span>
<span class="cm">     * Window 是一个抽象类, 其只有一个惟一的实现 PhoneWindow. </span>
<span class="cm">     * PhoneWindow#superDispatchTouchEvent() 方法惟一作用就是把事件继续向下传递到 DecorView</span>
<span class="cm">     *</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">getWindow</span><span class="o">().</span><span class="na">superDispatchTouchEvent</span><span class="o">(</span><span class="n">ev</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">onTouchEvent</span><span class="o">(</span><span class="n">ev</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/******************************************************/</span>
<span class="c1">// DecorView#superDispatchTouchEvent</span>

<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">superDispatchTouchEvent</span><span class="o">(</span><span class="n">MotionEvent</span> <span class="n">ev</span><span class="o">)</span> <span class="o">{</span>
    <span class="cm">/* mDecor 即 DecorView 类 */</span>
    <span class="k">return</span> <span class="n">mDecor</span><span class="o">.</span><span class="na">superDispatchTouchEvent</span><span class="o">(</span><span class="n">ev</span><span class="o">);</span> 
<span class="o">}</span>
</pre></div>


<p><code>DecorView</code>继承了<code>FrameLayout</code>并实现了<code>RootViewSurfaceTracker</code>, <code>WindowCallbacks</code>. <code>DecorView</code>即是屏幕的总父<code>view</code>, 包括了标题栏和内容部分, 即是<code>setContentView</code>的父<code>view</code>. 其在接收到<code>view</code>事件后, 会继续向下派发, 由于<code>FrameLayout</code>并没覆写这个方法, 所以最终传到父<code>ViewGroup</code>来处理.   (~~这火传的2333333~~)</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">superDispatchTouchEvent</span><span class="o">(</span><span class="n">MotionEvent</span> <span class="n">ev</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">dispatchTouchEvent</span><span class="o">(</span><span class="n">ev</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>


<p><code>ViewGroup#dispatchTouchEvent</code>. <code>ViewGroup</code>会判断是否要向下一层<code>view</code>传递事件, 这样一层一层如此循环, 最终完成整个事件的分发.</p>
<div class="highlight"><pre><span></span><span class="c1">// ViewGroup#dispatchTouchEvent</span>

<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">dispatchTouchEvent</span><span class="o">(</span><span class="n">MotionEvent</span> <span class="n">ev</span><span class="o">)</span> <span class="o">{</span>
    <span class="cm">/* ..... */</span>
    <span class="cm">/* 省略前面是一些事件的判断 */</span>
    <span class="kt">boolean</span> <span class="n">handled</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">onFilterTouchEventForSecurity</span><span class="o">(</span><span class="n">ev</span><span class="o">))</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">action</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="na">getAction</span><span class="o">();</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">actionMasked</span> <span class="o">=</span> <span class="n">action</span> <span class="o">&amp;</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_MASK</span><span class="o">;</span>

        <span class="c1">// Handle an initial down.</span>
        <span class="c1">// ACTION_DOWN 事件时, 重置所有的标志位</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">actionMasked</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_DOWN</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Throw away all previous state when starting a new touch gesture. </span>
            <span class="c1">// The framework may have dropped the up or cancel event for the previous gesture</span>
            <span class="c1">// due to an app switch, ANR, or some other state change.</span>
            <span class="n">cancelAndClearTouchTargets</span><span class="o">(</span><span class="n">ev</span><span class="o">);</span>
            <span class="n">resetTouchState</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">intercepted</span><span class="o">;</span>
        <span class="cm">/* 这里检查 ViewGroup 是否要中断事件向下分发和调用 onIterceptTouchEvent</span>
<span class="cm">         * 当手指刚接触屏幕时为 ACTION_DOWN, 所以条件必然成立, 也就是说在不设置标志位下, </span>
<span class="cm">         * ViewGroup 一定可以中断事件继续分发. 第二条件是 mFirstTouchTarget 的值.</span>
<span class="cm">         * 该变量指的是消费事件的 view, ACTION_DOWN时必为null, 如果派发成功, </span>
<span class="cm">         * 在接下来的 ACTION_MOVE, ACTION_UP 则不会为 null 值</span>
<span class="cm">         *</span>
<span class="cm">         * 接下来则要判断拦截标志位. FLAG_DISALLOW_INTERCEPT 是由 </span>
<span class="cm">         * ViewGroup#requestDisallowInterceptTouchEvent 方法进行设置的,</span>
<span class="cm">         * 这样一来 ViweGroup 就不再拦截到该事件</span>
<span class="cm">         * 但 ACTION_DOWN 为例外, 因为 ViewGroup 会对该类事件做标志重置, 所以不管子 View 如何请求</span>
<span class="cm">         * ViewGroup 依然可以拦截到 ACTION_DOWN</span>
<span class="cm">         * </span>
<span class="cm">         */</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">actionMasked</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_DOWN</span> <span class="o">||</span> <span class="n">mFirstTouchTarget</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">disallowIntercept</span> <span class="o">=</span> <span class="o">(</span><span class="n">mGroupFlags</span> <span class="o">&amp;</span> <span class="n">FLAG_DISALLOW_INTERCEPT</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">disallowIntercept</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">intercepted</span> <span class="o">=</span> <span class="n">onInterceptTouchEvent</span><span class="o">(</span><span class="n">ev</span><span class="o">);</span>
                <span class="n">ev</span><span class="o">.</span><span class="na">setActoin</span><span class="o">(</span><span class="n">action</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">intercepted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">intercepted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="cm">/* ......... */</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>由以上可以看出, <code>ViewGroup#onInterceptTouchEvent</code>并不是每次都会被调用到</p>
<ul>
<li>
<p>如果事件是<code>ACTION_DOWN</code>, 则一定会被调用</p>
</li>
<li>
<p>如果不是<code>ACTION_DOWN</code>, 则要考虑:</p>
</li>
</ul>
<ol>
<li>
<p>是否有了接收事件的目标子<code>view</code>. 没有的话,直接设置中断事件派发, 并且不会调用<code>onInterceptTouchEvent</code></p>
</li>
<li>
<p>有了接收事件<code>view</code>, 则查看子<code>view</code>是否请求设置不要中断事件标志<code>ViewGroup#requestDisallowInterceptTouchEvent</code>.</p>
<p>设置后则不调用; 没有设置则会调用<code>onInterceptTouchEvent</code></p>
</li>
</ol>
<p><code>ViewGroup</code>只在<strong>当为鼠标的左键(主按键)的按下事件并且屏幕能滚动时</strong>才会中断事件的派发, 否则默认不中断分发事件 </p>
<div class="highlight"><pre><span></span><span class="c1">// ViewGroup#onInterceptTouchEvent</span>

<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">onInterceptTouchEvent</span><span class="o">(</span><span class="n">ev</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ev</span><span class="o">.</span><span class="na">isFromSource</span><span class="o">(</span><span class="n">InputDevice</span><span class="o">.</span><span class="na">SOURCE_MOUSE</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
        <span class="n">ev</span><span class="o">.</span><span class="na">getAction</span><span class="o">()</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_DOWN</span> <span class="o">&amp;&amp;</span>
        <span class="n">ev</span><span class="o">.</span><span class="na">isButtonPressed</span><span class="o">(</span><span class="n">MotionEvent</span><span class="o">.</span><span class="na">BUTTON_PRIMARY</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
        <span class="n">isOnScrollbarThumb</span><span class="o">(</span><span class="n">ev</span><span class="o">.</span><span class="na">getX</span><span class="o">(),</span> <span class="n">ev</span><span class="o">.</span><span class="na">getY</span><span class="o">()))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<p><code>ViewGroup#dispatchTouchEvent</code>中如果没有中断派发时, 查找接收的子<code>view</code>, 如果查找到了, 就调用其<code>dispatchTouchEvent</code>, 没有找到则调用<code>super.dispatchTouchEvent</code>, 其实就是<code>View#dispatchTouchEvent</code></p>
<p>来看<code>View#dispatchTouchEvent</code>的代码. 由于<code>View</code>作为<code>ViewGroup</code>的父类, 所以该方法作用在于两方面.</p>
<ul>
<li>一是作为子<code>view</code>即像<code>TextView</code>之类时处理从<code>ViewGroup</code>派发下来的事件</li>
<li>二是作为<code>ViewGroup</code>的父类, 处理<code>ViewGroup#dispatchTouchEvent</code>(实际是在<code>ViewGroup#dispatchTransformedTouchEvent</code>)调用父类的<code>dispatchTouchEvent</code>时</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1">// View#dispatchTouchEvent</span>

<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">dispatchTouchEvent</span><span class="o">(</span><span class="n">MotionEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">isTargetAccessibilityFocus</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// We don&#39;t have focus or no virtual descendant has it, do not handle the event.</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">isAccessibilityFocusedViewOrHost</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// We have focus and got the event, then use normal event dispatch.</span>
        <span class="n">event</span><span class="o">.</span><span class="na">setTargetAccessibilityFocus</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">boolean</span> <span class="n">result</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">mInputEventConsistencyVerifier</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mInputEventConsistencyVerifier</span><span class="o">.</span><span class="na">onTouchEvent</span><span class="o">(</span><span class="n">event</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">final</span> <span class="kt">int</span> <span class="n">actionMasked</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="na">getActionMasked</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">actionMasked</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_DOWN</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Defensive cleanup for new gesture</span>
        <span class="n">stopNestedScroll</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">onFilterTouchEventForSeCurity</span><span class="o">(</span><span class="n">event</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">mViewFlags</span> <span class="o">&amp;</span> <span class="n">ENABLED_MASK</span><span class="o">)</span> <span class="o">==</span> <span class="n">ENABLED</span> <span class="o">&amp;&amp;</span> <span class="n">handleScrollBarDragging</span><span class="o">(</span><span class="n">event</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> 
        <span class="o">}</span>
        <span class="cm">/* </span>
<span class="cm">         * 这里会检查几个地方</span>
<span class="cm">         * 如果 view 在 enable (默认) 状态下</span>
<span class="cm">         * 并且设置了 onTouchListener 回调, 则调用 listener 的 onTouch 方法 </span>
<span class="cm">         *</span>
<span class="cm">         * 如果调用了 onTouch 方法, 该方法的返回值会对 View#onTouchEvent 方法产生影响</span>
<span class="cm">         * onTouch 返回 true 时则不会再调用 View#onTouchEvent </span>
<span class="cm">         * 反之才会调用, 这样方便在 View 之外中断默认的处理方法, onTouch 方法优先级更高</span>
<span class="cm">         */</span>
        <span class="c1">// noinspection SimplifiableIfStatement</span>
        <span class="n">ListenerInfo</span> <span class="n">li</span> <span class="o">=</span> <span class="n">mListenerInfo</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">li</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">li</span><span class="o">.</span><span class="na">mOnTouchListener</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
            <span class="o">(</span><span class="n">mViewFlags</span> <span class="o">&amp;</span> <span class="n">ENABLED_MASK</span><span class="o">)</span> <span class="o">==</span> <span class="n">ENABLED</span> <span class="o">&amp;&amp;</span>
            <span class="n">li</span><span class="o">.</span><span class="na">mOnTouchListener</span><span class="o">.</span><span class="na">onTouch</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">event</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> 
        <span class="o">}</span>
        <span class="c1">// onTouch(如果调用了) 返回 false 则在这里回调了 View#onTouchEvent 方法</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">onTouchEvent</span><span class="o">(</span><span class="n">event</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span> 
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(!</span><span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">mInputEventConsistencyVerifier</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mInputEventConsistencyVerifier</span><span class="o">.</span><span class="na">onUnhandledEvent</span><span class="o">(</span><span class="n">event</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Clean up after nested scrolls if this is the end of a gesture</span>
    <span class="c1">// alse cancel it if we tried an ACTION_DOWN but we didn&#39;t want the rest</span>
    <span class="c1">// of the gesture</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">actionMasked</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_UP</span> <span class="o">||</span>
        <span class="n">actionMasked</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTIOIN_CANCEL</span> <span class="o">||</span>
        <span class="o">(</span><span class="n">actionMasked</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_DOWN</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">result</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">stopNestedScroll</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<p>来看 <code>View#onTouchEvent</code></p>
<div class="highlight"><pre><span></span><span class="c1">// View#onTouchEvent</span>

<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">onTouchEvent</span><span class="o">(</span><span class="n">MotionEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="na">getX</span><span class="o">();</span>
    <span class="kd">final</span> <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="na">getY</span><span class="o">();</span>
    <span class="kd">final</span> <span class="kt">int</span> <span class="n">viewFlags</span> <span class="o">=</span> <span class="n">mViewFlags</span><span class="o">;</span>
    <span class="kd">final</span> <span class="kt">int</span> <span class="n">action</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="na">getAction</span><span class="o">();</span>

    <span class="c1">// 检查是否可以单击或者长按或者是长按弹出菜单(类似鼠标右健)</span>
    <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">clickable</span> <span class="o">=</span> <span class="o">((</span><span class="n">viewFlags</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">CLICKABLE</span><span class="o">)</span> <span class="o">==</span> <span class="n">CLICKABLE</span><span class="o">)</span> <span class="o">||</span>
        <span class="o">(</span><span class="n">viewFlags</span> <span class="o">&amp;</span> <span class="n">LONG_CLICKABLE</span><span class="o">)</span> <span class="o">==</span> <span class="n">LONG_CLICKABLE</span><span class="o">)</span> <span class="o">||</span>
        <span class="o">(</span><span class="n">viewFlags</span> <span class="o">&amp;</span> <span class="n">CONTEXT_CLICKABLE</span><span class="o">)</span> <span class="o">==</span> <span class="n">CONTEXT_CLICKABLE</span><span class="o">);</span>

    <span class="c1">// 检查 view 是否是 disable 状态, 但即使 view 是 disable </span>
    <span class="c1">// 但是可 clickable 状态下也会消费掉该事件, 只是没任何反应而已</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">viewFlags</span> <span class="o">&amp;</span> <span class="n">ENABLED_MASK</span><span class="o">)</span> <span class="o">==</span> <span class="n">DISABLED</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_UP</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">mPrivateFlags</span> <span class="o">&amp;</span> <span class="n">PFLAG_PRESSED</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">setPressed</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">mPrivateFlags3</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PFLAG3_FINGER_DOWN</span><span class="o">;</span>
        <span class="c1">// A disabled view that is clickable still consume the touch</span>
        <span class="c1">// events, it just doesn&#39;t respond to them</span>
        <span class="k">return</span> <span class="n">clickable</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 如果使用 setTouchDelegate 代理方法, 则执行该方法, 和 setOnTouchListener 一样</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mTouchDelegate</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mTouchDelegate</span><span class="o">.</span><span class="na">onTouchEvent</span><span class="o">(</span><span class="n">event</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">ture</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// TOOLTIP类似 hover 或者右键鼠标的状态</span>
    <span class="c1">// 在这要注意一些如 ImageView 默认是不可点击的, 所以直接返回的 false</span>
    <span class="c1">// 然后事件会回退到 ViewGroup 由 ViewGroup 来处理</span>
    <span class="c1">// 但该 view 还是捕获到 ACTION_DOWN </span>
    <span class="c1">// 这里就要注意一个坑, 因为事件序列只会由某一个 View/ViewGroup 来处理掉,</span>
    <span class="c1">// 所以像 ImageView 这样的不可点击时, 事件回退来 ViewGroup</span>
    <span class="c1">// 这样一来, ACTION_DOWN 之后的该序列里的事件就不会再传递到 ImageView 来</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">clickable</span> <span class="o">||</span> <span class="o">(</span><span class="n">viewFlags</span> <span class="o">&amp;</span> <span class="n">TOOLTIP</span><span class="o">)</span> <span class="o">==</span> <span class="n">TOOLTIP</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">action</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">case</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_UP</span><span class="o">:</span>
                <span class="n">mPrivateFlags3</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PFLAG3_FINGER_DOWN</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">viewFlags</span> <span class="o">&amp;</span> <span class="n">TOOLTIP</span><span class="o">)</span> <span class="o">==</span> <span class="n">TOOLTIP</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">handleTooltipUp</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">clickable</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">removeTapCallback</span><span class="o">();</span>
                    <span class="n">removeLongPressCallback</span><span class="o">();</span>
                    <span class="n">mInContextButtonPress</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="n">mHasPerformedLongPress</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="n">mIgnoreNextUpEvent</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="kt">boolean</span> <span class="n">prepressed</span> <span class="o">=</span> <span class="o">(</span><span class="n">mPrivateFlags</span> <span class="o">&amp;</span> <span class="n">PFLAG_PREPRESSED</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">((</span><span class="n">mPrivateFlags</span> <span class="o">&amp;</span> <span class="n">PFLAG_PRESSED</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">prepressed</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// take focus if we don&#39;t have it already and we should in</span>
                    <span class="c1">// touch mode.</span>
                    <span class="kt">boolean</span> <span class="n">focusTaken</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">isFocusable</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">isFocusableInTouchMode</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isFocused</span><span class="o">())</span> <span class="o">{</span>
                        <span class="n">focusTaken</span> <span class="o">=</span> <span class="n">requestFocus</span><span class="o">();</span>
                    <span class="o">}</span>

                    <span class="k">if</span> <span class="o">(</span><span class="n">prepressed</span><span class="o">)</span> <span class="o">{</span>
                        <span class="c1">// The button is being released before we actually</span>
                        <span class="c1">// showed it as pressed.  Make it show the pressed</span>
                        <span class="c1">// state now (before scheduling the click) to ensure</span>
                        <span class="c1">// the user sees it.</span>
                        <span class="n">setPressed</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
                    <span class="o">}</span>

                    <span class="k">if</span> <span class="o">(!</span><span class="n">mHasPerformedLongPress</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mIgnoreNextUpEvent</span><span class="o">)</span> <span class="o">{</span>
                        <span class="c1">// This is a tap, so remove the longpress check</span>
                        <span class="n">removeLongPressCallback</span><span class="o">();</span>

                        <span class="c1">// Only perform take click actions if we were in the pressed state</span>
                        <span class="k">if</span> <span class="o">(!</span><span class="n">focusTaken</span><span class="o">)</span> <span class="o">{</span>
                            <span class="c1">// Use a Runnable and post this rather than calling</span>
                            <span class="c1">// performClick directly. This lets other visual state</span>
                            <span class="c1">// of the view update before click actions start.</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">mPerformClick</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                                <span class="n">mPerformClick</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PerformClick</span><span class="o">();</span>
                            <span class="o">}</span>
                            <span class="k">if</span> <span class="o">(!</span><span class="n">post</span><span class="o">(</span><span class="n">mPerformClick</span><span class="o">))</span> <span class="o">{</span>
                                <span class="n">performClick</span><span class="o">();</span>
                            <span class="o">}</span>
                        <span class="o">}</span>
                    <span class="o">}</span>

                    <span class="k">if</span> <span class="o">(</span><span class="n">mUnsetPressedState</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">mUnsetPressedState</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UnsetPressedState</span><span class="o">();</span>
                    <span class="o">}</span>

                    <span class="k">if</span> <span class="o">(</span><span class="n">prepressed</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">postDelayed</span><span class="o">(</span><span class="n">mUnsetPressedState</span><span class="o">,</span>
                                <span class="n">ViewConfiguration</span><span class="o">.</span><span class="na">getPressedStateDuration</span><span class="o">());</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(!</span><span class="n">post</span><span class="o">(</span><span class="n">mUnsetPressedState</span><span class="o">))</span> <span class="o">{</span>
                        <span class="c1">// If the post failed, unpress right now</span>
                        <span class="n">mUnsetPressedState</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
                    <span class="o">}</span>

                    <span class="n">removeTapCallback</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="n">mIgnoreNextUpEvent</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>

            <span class="k">case</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_DOWN</span><span class="o">:</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getSource</span><span class="o">()</span> <span class="o">==</span> <span class="n">InputDevice</span><span class="o">.</span><span class="na">SOURCE_TOUCHSCREEN</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">mPrivateFlags3</span> <span class="o">|=</span> <span class="n">PFLAG3_FINGER_DOWN</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">mHasPerformedLongPress</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

                <span class="k">if</span> <span class="o">(!</span><span class="n">clickable</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">checkForLongClick</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">performButtonActionOnTouchDown</span><span class="o">(</span><span class="n">event</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// Walk up the hierarchy to determine if we&#39;re inside a scrolling container.</span>
                <span class="kt">boolean</span> <span class="n">isInScrollingContainer</span> <span class="o">=</span> <span class="n">isInScrollingContainer</span><span class="o">();</span>

                <span class="c1">// For views inside a scrolling container, delay the pressed feedback for</span>
                <span class="c1">// a short period in case this is a scroll.</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">isInScrollingContainer</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">mPrivateFlags</span> <span class="o">|=</span> <span class="n">PFLAG_PREPRESSED</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">mPendingCheckForTap</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">mPendingCheckForTap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CheckForTap</span><span class="o">();</span>
                    <span class="o">}</span>
                    <span class="n">mPendingCheckForTap</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="na">getX</span><span class="o">();</span>
                    <span class="n">mPendingCheckForTap</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="na">getY</span><span class="o">();</span>
                    <span class="n">postDelayed</span><span class="o">(</span><span class="n">mPendingCheckForTap</span><span class="o">,</span> <span class="n">ViewConfiguration</span><span class="o">.</span><span class="na">getTapTimeout</span><span class="o">());</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// Not inside a scrolling container, so show the feedback right away</span>
                    <span class="n">setPressed</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
                    <span class="n">checkForLongClick</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">break</span><span class="o">;</span>

            <span class="k">case</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_CANCEL</span><span class="o">:</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">clickable</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">setPressed</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">removeTapCallback</span><span class="o">();</span>
                <span class="n">removeLongPressCallback</span><span class="o">();</span>
                <span class="n">mInContextButtonPress</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="n">mHasPerformedLongPress</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="n">mIgnoreNextUpEvent</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="n">mPrivateFlags3</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PFLAG3_FINGER_DOWN</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>

            <span class="k">case</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_MOVE</span><span class="o">:</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">clickable</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">drawableHotspotChanged</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
                <span class="o">}</span>

                <span class="c1">// Be lenient about moving outside of buttons</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">pointInView</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">mTouchSlop</span><span class="o">))</span> <span class="o">{</span>
                    <span class="c1">// Outside button</span>
                    <span class="c1">// Remove any future long press/tap checks</span>
                    <span class="n">removeTapCallback</span><span class="o">();</span>
                    <span class="n">removeLongPressCallback</span><span class="o">();</span>
                    <span class="k">if</span> <span class="o">((</span><span class="n">mPrivateFlags</span> <span class="o">&amp;</span> <span class="n">PFLAG_PRESSED</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">setPressed</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="n">mPrivateFlags3</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PFLAG3_FINGER_DOWN</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<p>事件分发的一些总结:</p>
<blockquote>
<ol>
<li><code>ACTION_DOWN</code> 是一个<strong>特殊</strong>的事件. 如果<code>View</code>只消耗了<code>ACTION_DOWN</code>事件(<strong>返回<code>true</code></strong>), 那么序列里接下来的事件全都交给该<code>View</code>来消耗.</li>
</ol>
<p>如果<code>View</code>没有消耗掉接下来比如<code>ACTION_MOVE</code>, <code>ACTION_UP</code>之类的事件(<strong>返回<code>false</code></strong>), 那这些事件也不会回退给上一层父<code>ViewGroup</code>, 这些事件便会消失</p>
<ol>
<li>如果某个<code>View</code>没有消耗掉<code>ACTION_DOWN</code>事件(返回了<code>false</code>), 那么同一个序列中的其他事件就不会再交给这个<code>View</code>了. 所有的事件包括第一个<code>ACTION_DOWN</code>都会被一层一层回退, 如果一直没有<code>View/ViewGroup</code>消耗掉, 最终会回退到<code>Activity</code>. 但在这一层层中, 我们可以检测到第一次的<code>ACTION_DOWN</code>调用, 然后决定是否要消耗事件序列. 原因同1</li>
</ol>
<p>​</p>
<p>一种特殊情况的举例: </p>
<p>正常情况下, 一个事件序列只能被一个 <code>View</code> 拦截消耗, 但如果最后接收事件的 <code>View</code> 是不可<code>clickable</code>(包括单击, 长按), 那这个<code>View</code>只能在<code>onTouch</code>(如果调用<code>View#setOnTouchListener</code>设置了的话)捕获到, 然后会把这个序列事件(包括<code>ACTION_DOWN</code>)回退给父<code>ViewGroup</code>, 这个也证实第1点</p>
<p>​</p>
<ol>
<li>
<p><code>View</code>没有<code>onInterceptTouchEvent</code>方法的, 一但有事件传给它, 在没有设置<code>setTouchEventListener</code>或者该方法里的<code>onTouch</code>返回<code>false</code>时, 会调用<code>onTouchEvent</code>方法</p>
</li>
<li>
<p><code>view</code>如果不是<code>clickable</code>的, 默认情况下是不能消耗事件的, 非<code>clickable</code>的<code>view</code>可以设置<code>setTouchEventListener</code>来返回<code>true</code>截断被消耗事件</p>
</li>
<li>
<p><code>View</code>的<code>enable</code>属性并不影响<code>onTouchEvent</code>的默认返回值(<code>true</code>), 只有<code>clickable</code>才是</p>
</li>
<li>
<p><code>onClick</code>调用发生的前提是<code>view</code>是<code>clickable</code>, 并且在它的<code>View#onTouchEvent</code>消耗了<code>ACTION_DOWN</code>和<code>ACTION_UP</code>事件, 如果这其中一个被<code>setTouchEventListener</code>拦截消耗了, <code>click</code>事件不会被调用 </p>
</li>
<li>
<p><code>ViewGroup#requestDisallowInterceptTouchEvent</code>可以请求不拦截<code>ACTION_DOWN</code>以外的事件</p>
</li>
</ol>
</blockquote>
<p><strong>Reference</strong>:</p>
<ol>
<li>http://blog.csdn.net/yanbober/article/details/50419117</li>
<li>https://juejin.im/entry/571a591a2e958a006be9f473</li>
<li>http://blog.csdn.net/carson_ho/article/details/54136311</li>
<li>​</li>
</ol>
            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
        <div class="col-sm-3" id="sidebar">
            <aside>

<section class="well well-sm">
    <ul class="list-group list-group-flush">
        <li class="list-group-item"><h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Social</span></h4>
              <ul class="list-group" id="social">
                <li class="list-group-item"><a href="#"><i class="fa fa-you-can-add-links-in-your-config-file-square fa-lg"></i> You can add links in your config file</a></li>
                <li class="list-group-item"><a href="#"><i class="fa fa-another-social-link-square fa-lg"></i> Another social link</a></li>
              </ul>
            </li>





    <li class="list-group-item"><h4><i class="fa fa-external-link-square fa-lg"></i><span class="icon-label">Links</span></h4>
      <ul class="list-group" id="links">
        <li class="list-group-item">
            <a href="http://getpelican.com/" target="_blank">
                Pelican
            </a>
        </li>
        <li class="list-group-item">
            <a href="http://python.org/" target="_blank">
                Python.org
            </a>
        </li>
        <li class="list-group-item">
            <a href="http://jinja.pocoo.org/" target="_blank">
                Jinja2
            </a>
        </li>
        <li class="list-group-item">
            <a href="#" target="_blank">
                You can modify those links in your config file
            </a>
        </li>
      </ul>
    </li>
    </ul>
</section>            </aside>
        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2018 ivicel
            &middot; Powered by <a href="https://github.com/getpelican/pelican-themes/tree/master/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="./theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="./theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="./theme/js/respond.min.js"></script>


</body>
</html>