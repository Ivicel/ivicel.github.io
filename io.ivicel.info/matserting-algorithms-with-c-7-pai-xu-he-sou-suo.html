
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index, follow" />

  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:300,400,400i,700" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="./theme/pygments/manni.min.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/font-awesome.min.css">

    <link href="./static/custom.css" rel="stylesheet">



    <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/images/favicon.ico" type="image/x-icon">

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-113622715-2', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->

<meta name="author" content="ivicel" />
<meta name="description" content="插入排序(选择排序, 冒泡排序Insertion Sort) 插入排序每次从数组里选出一个元素, 和新数组里的元素一一进行对比, 然后将新元素排到比它最大/小的元素的左或右边, 时间复杂度为 O(n2) /* issort.c */ #include &lt;stdlib.h&gt; #include &lt;string.h&gt; /* data 指向数组, size 是数组中元素个数, esize 是每个元素的大小, compare 是元素之间的比较函数 */ iint issort(void *data, int size, int esize, int (*compare)(const void *key1, const void *key2)) { /* char指针是 1 字节大小的指向, a[i * esize …" />
<meta name="keywords" content="算法, C, 数据结构, 排序, 搜索">

<meta property="og:site_name" content="Ivicel's Ambertime"/>
<meta property="og:title" content="Matserting Algorithms with C-7: 排序和搜索"/>
<meta property="og:description" content="插入排序(选择排序, 冒泡排序Insertion Sort) 插入排序每次从数组里选出一个元素, 和新数组里的元素一一进行对比, 然后将新元素排到比它最大/小的元素的左或右边, 时间复杂度为 O(n2) /* issort.c */ #include &lt;stdlib.h&gt; #include &lt;string.h&gt; /* data 指向数组, size 是数组中元素个数, esize 是每个元素的大小, compare 是元素之间的比较函数 */ iint issort(void *data, int size, int esize, int (*compare)(const void *key1, const void *key2)) { /* char指针是 1 字节大小的指向, a[i * esize …"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="./matserting-algorithms-with-c-7-pai-xu-he-sou-suo.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2017-04-02 00:00:00+08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="./author/ivicel.html">
<meta property="article:section" content="Data Structure Algorithms"/>
<meta property="article:tag" content="算法"/>
<meta property="article:tag" content="C"/>
<meta property="article:tag" content="数据结构"/>
<meta property="article:tag" content="排序"/>
<meta property="article:tag" content="搜索"/>
<meta property="og:image" content="/images/favicon.ico">

  <title>Ivicel's Ambertime &ndash; Matserting Algorithms with C-7: 排序和搜索</title>

</head>
<body>
  <aside>
    <div>
      <a href=".">
        <img src="/images/favicon.ico" alt="Ambertime" title="Ambertime">
      </a>
      <h1><a href=".">Ambertime</a></h1>

<p>Make memory in past times</p>

      <ul class="social">
      </ul>
    </div>


  </aside>
  <main>

    <nav>
      <a href=".">Home</a>



    </nav>

<article class="single">
  <header>
      
    <h1 id="matserting-algorithms-with-c-7-pai-xu-he-sou-suo">Matserting Algorithms with C-7: 排序和搜索</h1>
    <p>
      Posted on Sun 02 April 2017 in <a href="./category/data-structure-algorithms.html">Data Structure Algorithms</a>

    </p>
  </header>


  <div>
    <h4 id="insertion-sort">插入排序(选择排序, 冒泡排序Insertion Sort)</h4>
<p>插入排序每次从数组里选出一个元素, 和新数组里的元素一一进行对比, 然后将新元素排到比它最大/小的元素的左或右边, 时间复杂度为 O(n<sup>2</sup>)</p>
<div class="codehilite"><pre><span></span><span class="cm">/* issort.c */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="cm">/* data 指向数组, size 是数组中元素个数, esize 是每个元素的大小, compare 是元素之间的比较函数 */</span>
<span class="n">iint</span> <span class="nf">issort</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">esize</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">))</span>
<span class="p">{</span>
    <span class="cm">/* char指针是 1 字节大小的指向, a[i * esize]则引用到了第 i 个大小为 esize 的地址 */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

    <span class="cm">/* allocate storage for the key element */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">esize</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">j</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">esize</span><span class="p">);</span>

        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span><span class="n">esize</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">esize</span><span class="p">);</span>
            <span class="n">i</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/*</span>
<span class="cm">        等同上面的 while</span>
<span class="cm">        for (i = j - 1; i &gt;= 0; i--) {</span>
<span class="cm">            if (compare(&amp;a[i *esize], key) &gt; 0) {</span>
<span class="cm">                memcpy(&amp;a[(i + 1) * esize], &amp;a[i * esize], esize);</span>
<span class="cm">            } else {</span>
<span class="cm">                break;</span>
<span class="cm">            }</span>
<span class="cm">        }</span>
<span class="cm">        */</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">key</span><span class="p">,</span> <span class="n">esize</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="quick-sort">快速排序(Quick sort)</h4>
<ol>
<li>每次选择一个数据, 然后所有的数据和这个数对比, 小的放在左边, 大的放在右边</li>
<li>然后对左, 右两边的新数组继续重复第一步, 一直到左, 右数组都为空, 依次返回数组</li>
</ol>
<p>快速排序的时间复杂度依赖于每次所选的数, 最坏为<code>O(n&lt;sup&gt;2&gt;&lt;/sup&gt;)</code>, 平均是<code>O(nlog n)</code></p>
<p>为最大可能接近<code>O(nlog n)</code>, 每次都随机从数组中选择三个数, 取这三个数的中间值</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;sort.h&quot;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compare_int</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">int1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">int2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">int1</span> <span class="o">&gt;</span> <span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">int2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">int1</span> <span class="o">&lt;</span> <span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">int2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">partition</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">esize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">))</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">pval</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">pval</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">esize</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">esize</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">pval</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* 随机选取三个位置, 排序后取中间的值, 尽量保证左右两边的值是均匀的 */</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">issort</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">compare_int</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">pval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">esize</span><span class="p">);</span>

    <span class="n">i</span><span class="o">--</span><span class="p">;</span>
    <span class="n">k</span><span class="o">++</span><span class="p">;</span>
    <span class="cm">/* 每选中一个数, 在调换位置之后都保证其左边的数不会符合 compare() &lt; 0 */</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="n">k</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span><span class="k">while</span> <span class="p">(</span><span class="n">compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">k</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">pval</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">do</span> <span class="p">{</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span><span class="k">while</span> <span class="p">(</span><span class="n">compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">pval</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">esize</span><span class="p">);</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">k</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">esize</span><span class="p">);</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">k</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">temp</span><span class="p">,</span> <span class="n">esize</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">pval</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">k</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * data 是数组指向</span>
<span class="cm"> * size 是数组大小</span>
<span class="cm"> * esize 是每个元素的大小</span>
<span class="cm"> * i 是数组的头结点下标, 初始为 0</span>
<span class="cm"> * k 是数组末尾结点下标, 初始为 size - 1</span>
<span class="cm"> * compare 是比较函数, 大于返回 1, 小于返回 -1, 等于返回 0</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">qksort</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">esize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">))</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">j</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">esize</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">compare</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/* 每次递归都先处理上个 key 的位置的左边的数据 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">qksort</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">esize</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">compare</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/* 将位置改到位置 */</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="_1">快速排序的例子: 目录列表</h4>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdi.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;dirent.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;sort.h&quot;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Directory_</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">MAXNAMLEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span><span class="n">Directory</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compare_dir</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">strcmp</span><span class="p">(((</span><span class="k">const</span> <span class="n">Directory</span> <span class="o">*</span><span class="p">)</span><span class="n">key1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
        <span class="p">((</span><span class="k">const</span> <span class="n">Directory</span> <span class="o">*</span><span class="p">)</span><span class="n">key2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">directls</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">Directory</span> <span class="o">**</span><span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">DIR</span> <span class="o">*</span><span class="n">dirptr</span><span class="p">;</span>
    <span class="n">Directory</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">dirent</span> <span class="o">*</span><span class="n">curdir</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
    <span class="cm">/* 打开目录 */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">dirptr</span> <span class="o">=</span> <span class="n">opendir</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">dir</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">;</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">((</span><span class="n">curdir</span> <span class="o">=</span> <span class="n">readdir</span><span class="p">(</span><span class="n">dirptr</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Directory</span> <span class="o">*</span><span class="p">)</span><span class="n">realloc</span><span class="p">(</span><span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Directory</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="n">dir</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">strcpy</span><span class="p">(((</span><span class="o">*</span><span class="n">dir</span><span class="p">)[</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]).</span><span class="n">name</span><span class="p">,</span> <span class="n">curdir</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">closedir</span><span class="p">(</span><span class="n">dirptr</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">qksort</span><span class="p">(</span><span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Directory</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">compare_dir</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="merge-sort">归并排序(Merge Sort)</h4>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;sort.h&quot;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">merge</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">esize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">))</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span>
         <span class="o">*</span><span class="n">m</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ipos</span><span class="p">,</span> <span class="n">jpos</span><span class="p">,</span> <span class="n">mpos</span><span class="p">;</span>

    <span class="n">ipos</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">jpos</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">mpos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">esize</span> <span class="o">*</span> <span class="p">((</span><span class="n">k</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">ipos</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">||</span> <span class="n">jpos</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ipos</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">jpos</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">[</span><span class="n">mpos</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">jpos</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">esize</span><span class="p">);</span>
                <span class="n">jpos</span><span class="o">++</span><span class="p">;</span>
                <span class="n">mpos</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">jpos</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">ipos</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">[</span><span class="n">mpos</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">ipos</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">esize</span><span class="p">);</span>
                <span class="n">ipos</span><span class="o">++</span><span class="p">;</span>
                <span class="n">mpos</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">ipos</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">jpos</span> <span class="o">*</span> <span class="n">esize</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">[</span><span class="n">mpos</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">ipos</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">esize</span><span class="p">);</span>
            <span class="n">ipos</span><span class="o">++</span><span class="p">;</span>
            <span class="n">mpos</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">[</span><span class="n">mpos</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">jpos</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">esize</span><span class="p">);</span>
            <span class="n">jpos</span><span class="o">++</span><span class="p">;</span>
            <span class="n">mpos</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">m</span><span class="p">,</span> <span class="n">esize</span> <span class="o">*</span> <span class="p">((</span><span class="n">k</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">free</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * data 是数组指向</span>
<span class="cm"> * size 是数组大小</span>
<span class="cm"> * esize 是每个元素的大小</span>
<span class="cm"> * i 是数组的头结点下标, 初始为 0</span>
<span class="cm"> * k 是数组末尾结点下标, 初始为 size - 1</span>
<span class="cm"> * compare 是比较函数, 大于返回 1, 小于返回 -1, 等于返回 0</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">mgsort</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">esize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">))</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(((</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">mgsort</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">esize</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">compare</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mgsort</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">esize</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">compare</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">merge</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">esize</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">compare</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<div class="codehilite"><pre><span></span><span class="cm">/* 一种排序数组的方法, 每次会使用新的内存来保存左右值, 写回原数组后再释放 */</span>
<span class="kt">int</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">esize</span><span class="p">,</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">))</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span>
        <span class="n">pos_left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">pos_right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">esize</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>


    <span class="k">if</span> <span class="p">((</span><span class="n">left</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">length</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
        <span class="p">(</span><span class="n">right</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">length</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
        <span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">esize</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 随机确定某个数的位置 */</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">issort</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">compare_int</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">esize</span><span class="p">);</span>
    <span class="cm">/* 比较大小, 分到左右数组 */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* right */</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">right</span><span class="p">[</span><span class="n">pos_right</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">esize</span><span class="p">);</span>
                <span class="n">pos_right</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="cm">/* left */</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">left</span><span class="p">[</span><span class="n">pos_left</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">esize</span><span class="p">);</span>
                <span class="n">pos_left</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* 分好的数组写回原数组, 然后释放左右数组 */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pos_left</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">left</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">esize</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">[(</span><span class="n">pos_left</span><span class="p">)</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">key</span><span class="p">,</span> <span class="n">esize</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pos_right</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">[(</span><span class="n">pos_left</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">right</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">esize</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="cm">/* 在原数组上继续比较分好的左右两边 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pos_left</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">pos_left</span><span class="p">,</span> <span class="n">esize</span><span class="p">,</span> <span class="n">compare</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pos_right</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">merge_sort</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">[(</span><span class="n">pos_left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">esize</span><span class="p">],</span> <span class="n">pos_right</span><span class="p">,</span>
        <span class="n">esize</span><span class="p">,</span> <span class="n">compare</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="counting-sort">计数排序(Counting Sort)</h4>
<p>计数排序只能用于整型或者那些可以用整型来表示的数据集合, 通过计算一个集合中元素出现的次数来确定集合如何排列</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;sort.h&quot;</span><span class="cp"></span>


<span class="kt">int</span> <span class="nf">ctsort</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">counts</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">counts</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">counts</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temp</span><span class="p">[</span><span class="n">counts</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="n">counts</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

    <span class="n">free</span><span class="p">(</span><span class="n">counts</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#### 基数排序(Radix Sort)</span>

<span class="err">基数排序是一种高效的纯属排序算法</span><span class="p">,</span> <span class="err">其方法是将数据按位分开</span><span class="p">,</span> <span class="err">并从数据的最低有效位到最高有效位进行比较</span><span class="p">,</span> <span class="err">依次排序</span><span class="p">,</span> <span class="err">从而得到有序的数据集合</span>

<span class="err">对于数据</span><span class="p">{</span><span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">40</span><span class="p">}</span><span class="err">来说</span><span class="p">,</span> <span class="err">第一次对个位数进行从低到高排序后</span><span class="p">{</span><span class="mi">40</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">},</span><span class="err">然后再对十位数个的数进行排序最后得到最终结果</span><span class="p">{</span><span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">49</span><span class="p">}</span>

<span class="err">基数排序并不局限于对整型数据进行排序</span><span class="p">,</span> <span class="err">只要能把元素分割成整型数</span><span class="p">,</span> <span class="err">就可以使用基数排序</span>


<span class="err">​```</span><span class="n">c</span>
<span class="cp">#include</span> <span class="cpf">&lt;limits.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;sort.h&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">rxsort</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">counts</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">counts</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">pval</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pow</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">n</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">pval</span><span class="p">)</span> <span class="o">%</span> <span class="n">k</span><span class="p">;</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="n">pval</span><span class="p">)</span> <span class="o">%</span> <span class="n">k</span><span class="p">;</span>
            <span class="n">temp</span><span class="p">[</span><span class="n">counts</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">counts</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="binary-search">二分查找(Binary Search)</h4>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;search.h&quot;</span><span class="cp"></span>


<span class="kt">int</span> <span class="nf">bisearch</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">sorted</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">esize</span><span class="p">,</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">))</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="n">middle</span><span class="p">,</span> <span class="n">right</span><span class="p">;</span>

    <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">middle</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

        <span class="k">switch</span> <span class="p">(</span><span class="n">compare</span><span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sorted</span> <span class="o">+</span> <span class="p">(</span><span class="n">esize</span> <span class="o">*</span> <span class="n">middle</span><span class="p">)),</span> <span class="n">target</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">-</span><span class="mi">1</span><span class="o">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
                <span class="k">return</span> <span class="n">middle</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="_2">二分查找示例: 拼写检查器</h4>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>


<span class="cp">#define SPELL_SIZE 31</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">compare_str</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">str1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">str2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">strcmp</span><span class="p">((</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">str1</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">str2</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * dictionary 是一个可接受的有序字符串数组</span>
<span class="cm"> * size 是字典中字符串的个数</span>
<span class="cm"> * word 是被检查的单词</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">spell</span><span class="p">(</span><span class="kt">char</span> <span class="p">(</span><span class="o">*</span><span class="n">dictionary</span><span class="p">)[</span><span class="n">SPELL_SIZE</span><span class="p">],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">word</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bisearch</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">SPELL_SIZE</span><span class="p">,</span> <span class="n">compare_str</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">){</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="./tag/suan-fa.html">算法</a>
      <a href="./tag/c.html">C</a>
      <a href="./tag/shu-ju-jie-gou.html">数据结构</a>
      <a href="./tag/pai-xu.html">排序</a>
      <a href="./tag/sou-suo.html">搜索</a>
    </p>
  </div>





</article>

    <footer>
<p>
  &copy;  2018 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Powered by <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
           src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>




<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Ivicel's Ambertime ",
  "url" : ".",
  "image": "/images/favicon.ico",
  "description": "ivicel's thoughts and writings"
}
</script>

</body>
</html>