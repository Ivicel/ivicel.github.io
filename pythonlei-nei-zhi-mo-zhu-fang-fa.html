<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />


  <title>Python类内置魔术方法</title>


  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="referrer" content="origin" />
  <meta name="generator" content="Pelican" />
  <link href="./" rel="canonical" />

  <!-- Feed -->

  <link href="./theme/css/style.css" type="text/css" rel="stylesheet" />

  <!-- Code highlight color scheme -->
      <link href="./theme/css/code_blocks/github.css" rel="stylesheet">

    <!-- CSS specified by the user -->


    <link href="./assets/css/prism.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/base.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/base-control.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/github.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/codemirror.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/ivicel.css" type="text/css" rel="stylesheet" />

  <!-- Custom fonts -->
  <link href='https://fonts.googleapis.com/css?family=Montserrat:400,300' rel='stylesheet' type='text/css' />
  <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css" />

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->


  <link href="./pythonlei-nei-zhi-mo-zhu-fang-fa.html" rel="canonical" />

    <meta name="description" content="内置类特殊属性 object.__dict__ instance.__class__ class.__bases__ definition.__name__ definition.__qualname__ class.__mro__ class.mro()...">

    <meta name="author" content="ivicel">





<!-- Open Graph -->
<meta property="og:site_name" content="Ambertime"/>
<meta property="og:title" content="Python类内置魔术方法"/>
<meta property="og:description" content="内置类特殊属性 object.__dict__ instance.__class__ class.__bases__ definition.__name__ definition.__qualname__ class.__mro__ class.mro()..."/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="./pythonlei-nei-zhi-mo-zhu-fang-fa.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2017-03-20 00:00:00+08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="./author/ivicel.html">
<meta property="article:section" content="Python"/>
<meta property="og:image" content="./theme/images/post-bg.jpg">

<!-- Twitter Card -->

<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "name": "Python类内置魔术方法",
  "headline": "Python类内置魔术方法",
  "datePublished": "2017-03-20 00:00:00+08:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "ivicel",
    "url": "./author/ivicel.html"
  },
  "image": "./theme/images/post-bg.jpg",
  "url": "./pythonlei-nei-zhi-mo-zhu-fang-fa.html",
  "description": "内置类特殊属性 object.__dict__ instance.__class__ class.__bases__ definition.__name__ definition.__qualname__ class.__mro__ class.mro()..."
}
</script>
</head>
<!-- TODO : Body class -->
<body class="home-template">

<nav id="menu">
  <a class="close-button">Close</a>
  <div class="nav-wrapper">
    <p class="nav-label">Menu</p>
    <ul>


    </ul>
  </div>
</nav>
    <!-- Progressbar -->
    <div class="progress-container">
        <span class="progress-bar"></span>
    </div>

    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
    <header id="blog-header" >
      <div class="inner">
        <nav id="navigation">
            <span id="home-button" class="nav-button">
                <a class="home-button" href="./" title="Home"><i class="ic ic-arrow-left"></i> Home</a>
            </span>
          <span id="menu-button" class="nav-button">
            <a class="menu-button"><i class="ic ic-menu"></i> Menu</a>
          </span>
        </nav>
        <h1 class="post-title">Python类内置魔术方法</h1>
        <!-- TODO : Proper class for headline -->
        <span class="post-meta">
                <a href="./author/ivicel.html">Ivicel</a>
            | <time datetime="Mon 20 March 2017">Mon 20 March 2017</time>
        </span>
        <!-- TODO : Modified check -->
      </div>
    </header>

  <section id="wrapper">
    <a class="hidden-close"></a>

    <!-- Post content -->
    <main class="content" role="main">
<div class="col-lg-3 hidden-xs hidden-sm">
    <div id="toc"><ul><li><a class="toc-href" href="#" title="Python类内置魔术方法">Python类内置魔术方法</a><ul><li><a class="toc-href" href="#_1" title="内置类特殊属性">内置类特殊属性</a></li><li><a class="toc-href" href="#__slots__" title="__slots__ 的特殊性">__slots__ 的特殊性</a></li><li><a class="toc-href" href="#_2" title="对象方法">对象方法</a></li><li><a class="toc-href" href="#selfx" title="访问控制 self.x">访问控制 self.x</a></li><li><a class="toc-href" href="#selfx_1" title="自定义序列 self[x]">自定义序列 self[x]</a></li><li><a class="toc-href" href="#_3" title="描述符对象">描述符对象</a><ul><li><a class="toc-href" href="#_4" title="对象属性访问原理">对象属性访问原理</a></li><li><a class="toc-href" href="#descriptor" title="描述符(descriptor)举例">描述符(descriptor)举例</a></li></ul></li><li><a class="toc-href" href="#_6" title="比较操作符">比较操作符</a></li><li><a class="toc-href" href="#_7" title="数值操作符">数值操作符</a></li><li><a class="toc-href" href="#_8" title="类的表示">类的表示</a></li><li><a class="toc-href" href="#_9" title="反射">反射</a></li><li><a class="toc-href" href="#_10" title="抽象基类">抽象基类</a></li><li><a class="toc-href" href="#_11" title="可调用的对象">可调用的对象</a></li><li><a class="toc-href" href="#_12" title="上下文管理器">上下文管理器</a></li><li><a class="toc-href" href="#_13" title="拷贝">拷贝</a></li></ul></li></ul></div>
</div>
        <article class="post">
        <div class="inner">
            <section class="post-content">
                <h3 id="_1"> 内置类特殊属性 </h3>
<pre class="highlight"><code class="language-python linenums">object.__dict__

instance.__class__

class.__bases__

definition.__name__

definition.__qualname__

class.__mro__

class.mro()

class.__subclasses__()
</code></pre>
<p> 自定义类都有一个 <code>namespace</code>，即一个字典对象来存储类的属性。<code>C.x</code> 即表示 <code>C.__dict__['x']</code>，当类 <code>C</code> 中不存在属性 <code>x</code>，会依据继承顺序 <a href="https://www.python.org/download/releases/2.3/mro/"><code>MRO</code></a> 表来查找该属性。</p>
<p> 如若查找完基类后，依然找不到属性，才会调相应用 <code>C.__getattribute__()</code>、<code>C.__getattr__()</code></p>
<pre class="highlight"><code class="language-python linenums">class A(object):
    def __getattr__(self, name):
        print('call __getattr__()')

a = A()
a.x = 'X'
print(a.x)              # 'X', __getattr__() 并未调用
print(a.__dict__)       # {'x': 'X'}

######################################

class A(object):
    x = 'A'

class B(A):
    def __getattr__(self, name):
        print('call __getattr__()')
        return 'B'

a = B() 
print(a.x)          # 'A', a.__getattr__() 并不会调用
</code></pre>
<h3 id="__slots__"><code>__slots__</code> 的特殊性 </h3>
<blockquote>
<p> 类变量 <code>__slots__</code> 可赋值 string, iterable，字符 list</p>
<p> 定义 <code>__slots__</code> 变量后，类将不再使用 <code>__dict__</code> 来存储属性 </p>
<p> 类不会自动生成 <code>__dict__</code> 和 <code>__weakref__</code></p>
</blockquote>
<h3 id="_2"> 对象方法 </h3>
<p> 类中的对象方法 (instance method\bound method), 其方法名也存在 <code>M.__dict__</code> 中，对象方法有两个只读变量 <code>mehtod.__self__</code> 和 <code>method.__func__</code>，当调用方法时 <code>method(arg1, arg2)</code> 时，等于调用 <code>method.__func__(method.__self__, arg1, arg2)</code></p>
<pre class="highlight"><code class="language-python linenums">class A(object):
    def m(self):
        print('call method m')

a = A()
a.m()   # a.m.__func__(a.m.__self__)</code></pre>
<h3 id="selfx"> 访问控制 <code>self.x</code></h3>
<pre class="highlight"><code class="language-python linenums">__getattr__(self, name)

__getattribute__(self, name)

# Attribute assignments and deletions update the instance&rsquo;s dictionary, never a class&rsquo;s dictionary.
# If the class has a __setattr__() or __delattr__() method, 
# this is called instead of updating the instance dictionary directly.
# 删除对象的属性或者对对象属性赋值，是直接对实例 __dict__ 的操作
# 当定义了 __setattr__ 、__delattr__ 方法时，使用方法替代
__setattr__(self, name, value)

__delattr__(self, name)
</code></pre>
<p> 基类 <code>object</code> 中并没有 <code>__getattr__()</code> 方法，所以，只有当自定义类的自定义了 <code>__getattr__()</code> 方法，才有可能访问该方法 </p>
<p> 访问属性 <code>self.x</code> 时，首先会隐式调用 <code>__getattribute__()</code> 方法，只有在 <code>__getattribute__()</code> 中显示调用或者 <code>raise</code> 出 <code>AttributeError</code> 时，才会调用 <code>__getattr__()</code></p>
<blockquote>
<ol>
<li>
<p> 类中没有定义 <code>__getattribute__()</code> 时，当 <code>self.x</code> 不存在时，默认 <code>raise</code> 出 <code>AttributeError</code></p>
</li>
<li>
<p> 类中有定义 <code>__getattribute__()</code> 时，访问 <code>self.x</code> 时，调用 <code>__getattribute__()</code>，除非显示调用 <code>__getattr__()</code> 或者 <code>raise</code> 出 <code>AttributeError</code>, 才会调用 <code>__getattr__()</code> 如若存在 </p>
</li>
<li> 在定义 <code>__getattribute__()</code> 时，为避免无限递归调用，一般使用 <code>object.__getattribute__(self, name)</code> 来获取对象的值 </li>
</ol>
</blockquote>
<pre class="highlight"><code class="language-python linenums">class A(object):
    def __getattr__(self, name):
        print('get =&gt; ' + name)

    def __getattribute__(self, name):
        print('get attribute =&gt; ' + name)
        raise AttributeError()  # 隐式调用 __getattr__()



# get attribute =&gt; b
# get =&gt; b
# None
a = A()
print(a.b)

########################################

class A(object):
    def __getattr__(self, name):
        print('get =&gt; ' + name)

# get =&gt; b
# None
a = A()
print(a.b)

########################################

class A(object):
    def __getattribute__(self, name):
        print('get attribute =&gt; ' + name)


# get attribute =&gt; b
# None
a = A()
print(a.b)
</code></pre>
<h3 id="selfx_1"> 自定义序列 self[x]</h3>
<pre class="highlight"><code class="language-python linenums">__len__(self)                       # len() 方法

__getitem__(self, key)              # self[key]

__setitem__(self, key)              # self[key] = XXX

__iter__(self, key)                 # 迭代器

__reversed__(self)                  # reversed() 方法

__contains__(self, item)            # in 和 not in 测试

__missing__(self, key)              # self[key] 不存在时 </code></pre>
<p> 当类没有定义 <code>__getitem__()</code> 时，<code>self['x']</code> 会产生 <strong><code>Type Error</code>:object is not subscriptable</strong>, 定义 <code>__getitem__()</code> 后，类变成一个 <strong>subscriptor</strong>，<code>self['x']</code> 隐式调用 <code>__getitem__()</code>。一般在普通的如 <code>list</code> 中，<code>x</code> 不存在或错误会产生 <code>KeyError</code>，超出范围则产生 <code>IndexError</code></p>
<h3 id="_3"> 描述符对象 </h3>
<pre class="highlight"><code class="language-python linenums">__get__(self, instance, owner)

__set__(self, instance, owner)

__delete__(self, instance, owner)

# 生成描述符实例时调用
__set_name__(self, owner, name)</code></pre>
<blockquote>
<p> 当一个类实现 <code>__get__()</code> <code>__set__()</code> <code>__delete__()</code> 中一个方法，称为 <strong> 描述符类 </strong>(<code>decriptor class</code>)</p>
</blockquote>
<p> 定义 <code>__set__()</code> and/or <code>__delete__()</code>，称为 <strong> 数据描述符 </strong>(<code>data descriptor</code>); 没有定义其中一个的称为 <strong> 非数据描述符 </strong>(<code>non-data descriptor</code>)</p>
<p> 通常 <code>data descriptor</code> 都定义 <code>__set__()</code> 和 <code>__get__()</code>，<code>non-data descriptor</code> 只定义 <code>__get__()</code></p>
<blockquote>
<p>The following methods only apply when an instance of the class containing the method (a so-called descriptor class) appears in an owner class (the descriptor must be in either the owner&rsquo;s class dictionary or in the class dictionary for one of its parents). In the examples below, &ldquo;the attribute&rdquo; refers to the attribute whose name is the key of the property in the owner class&rsquo; <code>__dict__</code>.</p>
<p> 只有描述符类的实例 <code>instance</code> 是 <code>owner_class</code> 中或 <code>owner_class</code> 的某一个父类中 <code>__dict__</code> 中属性的实例，描述符方法才会调用 </p>
</blockquote>
<p> 描述符调用 <code>a.x</code> 和 <code>A.x</code></p>
<ol>
<li> 直接调用 <code>x.__get__(a)</code></li>
<li> 实例对象绑定：<code>a.x</code> 即 <code>type(a).__dict__['x'].__get__(a, type(a))</code></li>
<li> 类绑定：<code>A.x</code> 即 <code>A.__dict__['x'].__get__(None, A)</code></li>
<li>Super 绑定 ( 继承的类有类属性是描述符的实例对象 )：<code>super(B, obj).m</code> 查找 <code>obj.__class__.__mro__</code>，当找到 <code>A</code> 类有 <code>m</code> 属性为描述符对象时调用 <code>A.__dict__['m'].__get__(obj, obj.__class__)</code></li>
</ol>
<pre class="highlight"><code class="language-python linenums"># example
# owner 的类属性是一个 decriptor 的实例
class A(object):
    def __get__(self, instance, cls):
        print('call A.__get__()')
        return 'Class A'

class B(object):
    x = A()

# call A.__get__()
# 'Class A' 
b = B()
print(b.x)  

##############################

# owner 的父类的属性是一个 decriptor 的实例
class A(object):
    def __get__(self, instance, cls):
        print('call A.__get__()')
        return 'Class A'

class B(object):
    x = A()

class C(B):
    pass

# print('call A.__get__()')
# 'Class A'
c = C()
print(c.x)
</code></pre>
<h4 id="_4"> 对象属性访问原理 </h4>
<ul>
<li> 访问顺序：</li>
</ul>
<blockquote>
<p> 资料描述器 (<code>data descriptor</code>) 优先于实例变量 (<code>instance.attribute</code>)，实例变量优先于非资料描述器 (<code>non-data descriptor</code>)，<code>__getattr__()</code> 方法 ( 如果对象中包含的话 ) 具有最低的优先级 </p>
</blockquote>
<pre class="highlight"><code class="language-python linenums">class descriptor(object):
    def __get__(self, instance, cls):
        print('__get__()')

    def __set__(self, instance, value):
        print('__set__()')

class A(object):
    x = descriptor()
    def __init__(self):
        # 资料描述符优先实例变量
        self.x = 'x'        #=&gt; type(a).__dict__['x'].__set__(a, type(a))


# '__set__()'
# '__get__()'
# '__set__()'       
a = A()
a.x         #=&gt; type(a).__dict__['x'].__get__(a, type(a))
a.x = 5     #=&gt; type(a).__dict__['x'].__set__(a, type(a))

##############################################

class descriptor(object):
    def __get__(self, instance, cls):
        print('__get__()')

class A(object):
    x = descriptor()
    def __init__(self):
        # 实例变量优先非资料描述符
        self.x = 'x'        #=&gt; self.__dict__['x'] = 'x'


# x
# {'x': 'x'}        
a = A()
print(a.x)          
print(a.__dict__)       

##############################################

class descriptor(object):
    def __get__(self, instance, cls):
        print('__get__()')

class A(object):
    x = descriptor()

    def __getattr__(self, key):
        print('__getattr__()')

# '__get__()'   
a = A()
# 非资料描述符优先 __getattr__ 
a.x         #=&gt; type(a).__dict__['x'].__get__(a, type(a))
</code></pre>
<h4 id="descriptor"> 描述符 (descriptor) 举例 </h4>
<blockquote>
<p> 内置 property 的实现 </p>
</blockquote>
<pre class="highlight"><code class="language-python linenums">class Property(object):
    def __init__(self, func):
        self._func_getter = func

    def __get__(self, instance, cls):
        return self._func_getter(instance)

    def __set__(self, instance, value):
        if getattr(self, '_setter', False):
            self._func_setter(instance, value)
        else:
            raise AttributeError("can't set attribute")

    def setter(self, func):
        self._setter = True
        self._func_setter = func
        return self

class A(object):
    @Property
    def say_hello(self):
        if hasattr(self, '_x'):
            return self._x
        else:
            return 'xxxxxxxxxxxxx'

    @say_hello.setter
    def say_hello(self, value):
        print('say hello again')
        self._x = value</code></pre>
<blockquote>
<p><code>classmethod</code> 和 <code>staticmethod</code> 的简单实现 </p>
</blockquote>
<pre class="highlight"><code class="language-python linenums">class ClassMethod(object):
    def __init__(self, func):
        self._f = func

    def __get__(self, instance, cls):
        def func():
            return self._f(cls)
        return func

class StaticMethod(object):
    def __init__(self, f):
        self._f = f

    def __get__(self, instance, cls):
        return self._f
</code></pre>
<hr/>
<h3 id="_6"> 比较操作符 </h3>
<pre class="highlight"><code class="language-Python linenums">__eq__(self, other)     # ==

__ne__(self, other)     # !=

__lt__(self, other)     # &lt;

__gt__(self, other)     # &gt;

__le__(self, other)     # &lt;=

__ge__(self, other)     # &gt;=
</code></pre>
<h3 id="_7"> 数值操作符 </h3>
<p>.1 一元操作符 </p>
<pre class="highlight"><code class="language-python linenums">__post__(self)          # 取正 +some_object

__neg__(self)           # 取负 -some_object

__abs__(self)           # 绝对值 abs()

__invert__(self)        # 取反 ~

__round__(self, n)      # 内建函数 round()

__floor__(self)         # math.floor() 函数，向下取整

__ceil__(self)          # math.ceil() 函数，向上取整

__trunc__(self)         # math.trunc() 函数，距离 0 最返的整数
</code></pre>
<p>.2 算数操作符 </p>
<pre class="highlight"><code class="language-python linenums">__add__(self, other)

__sub__(self, other)

__mul__(self, other)

__floordiv__(self, other)

__truediv__(self, other)

__mod__(self, other)

__divmod__(self, other)

__pow__(self)

__lshift__(self, other)

__rshift__(self, other)

__and__(self, other)

__or__(self, other)

__xor__(self, other)
</code></pre>
<p>.3 反射算数运算符 </p>
<pre class="highlight"><code class="language-python linenums">__radd__(self, o)

__rsub__(self, o)

__rmul__(self, o)

__rfloordiv__(self, o)

__rtruediv__(self, o)

__rmod__(self, o)

__rpow__(self)

__rlshift__(self, o)

__rshift__(self, o)

_rand__(self, o)

__ror__(self, o)

__rxor__(self, o)
</code></pre>
<p>.4 增强赋值运算符 </p>
<pre class="highlight"><code class="language-python linenums">__iadd__(self, o)

__isub__(self, o)

__imul__(self, o)

__ifloordiv__(self, o)

__itruediv__(self, o)

__imod__(self, o)

__ipow__(self, o)

__ilshift__(self, o)

__irshift__(self, o)

__iand__(self, o)

__ixor__(self, o)
</code></pre>
<p>.5 类型转换操作符 </p>
<pre class="highlight"><code class="language-python linenums">__int__(self)

__long__(self)

__float__(self)

__complex__(self)

__oct__(self)

__hex__(self)

__index__(self)

__trunc__(self)
</code></pre>
<h3 id="_8"> 类的表示 </h3>
<pre class="highlight"><code class="language-python linenums">__str__(self)

__repr__(self)

__format__(self)

__hash__(self)

__dir__(self)
</code></pre>
<h3 id="_9"> 反射 </h3>
<pre class="highlight"><code class="language-python linenums"># isinstance(instance, class) 方法
__instancecheck__(self, instance)       

# issubclass(subclass, class) 方法
__subclasscheck__(self, subclass)       </code></pre>
<h3 id="_10"> 抽象基类 </h3>
<pre class="highlight"><code class="language-python linenums"></code></pre>
<h3 id="_11"> 可调用的对象 </h3>
<pre class="highlight"><code class="language-python linenums">__call__(self, [args...])

class A():
    def __call__(self):
        pass

a = A()
a()     # 调用 A.__call__()</code></pre>
<h3 id="_12"> 上下文管理器 </h3>
<pre class="highlight"><code class="language-python linenums"># 使用 with 声明时调用，返回值即为 as 后的东西
__enter__(self)

# 退出 with 时调用，处理 with 产生的 exception
__exit__(self, exceptiop_type, exception_value, traceback)


# 跟 async with 使用 , 异步上下文 , 除了必须返回一个 awaitable, 其他与上相同
__aenter__(self)
__aexit__(self, exec_type, exec_value, traceback)</code></pre>
<h3 id="_13"> 拷贝 </h3>
<pre class="highlight"><code class="language-python linenums">__copy__(self)

__deepcopy__(self, memodict=)</code></pre>
            </section>

            <section class="post-info">
                <div class="post-share">
                    <a class="twitter" href="https://twitter.com/share?text=Python类内置魔术方法&amp;url=./pythonlei-nei-zhi-mo-zhu-fang-fa.html" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <i class="ic ic-twitter"></i><span class="hidden">Twitter</span>
                    </a>
                    <a class="facebook" href="https://www.facebook.com/sharer/sharer.php?u=./pythonlei-nei-zhi-mo-zhu-fang-fa.html" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <i class="ic ic-facebook"></i><span class="hidden">Facebook</span>
                    </a>
                    <a class="googleplus" href="https://plus.google.com/share?url=./pythonlei-nei-zhi-mo-zhu-fang-fa.html" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <i class="ic ic-googleplus"></i><span class="hidden">Google+</span>
                    </a>
                    <div class="clear"></div>
                </div>


                <div class="clear"></div>


                </section>


                <aside class="post-nav">
                    <div class="clear"></div>
                </aside>

            </div>
        </article>
    </main>
      <!-- TODO : Body class -->
    <div id="body-class" style="display: none;" class=""></div>

    <footer id="footer">
      <div class="inner">
        <section class="credits">


          <span class="credits-theme">Theme <a href="https://github.com/arulrajnet/attila" rel="nofollow">Attila</a></span>
          <span class="credits-software">Published with <a href="https://github.com/getpelican/pelican" rel="nofollow">Pelican</a></span>
        </section>
      </div>
    </footer>
  </section>

  <script type="text/javascript" src="./theme/js/script.js"></script>

    <!-- Script specified by the user -->
    <script type="text/javascript"  src="./assets/js/prism.js"></script>
</body>
</html>