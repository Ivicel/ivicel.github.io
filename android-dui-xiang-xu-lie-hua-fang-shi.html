
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index, follow" />

  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:300,400,400i,700" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="./theme/pygments/manni.min.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/font-awesome.min.css">

    <link href="./static/custom.css" rel="stylesheet">



    <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/images/favicon.ico" type="image/x-icon">

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-113622715-2', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->

<meta name="author" content="ivicel" />
<meta name="description" content="Android内序列化对象主要有两种方式, 一是原Java自带的Serializable接口, 二是Android内自有的Parcelable接口 1. Serializable接口 Java自带的序列接口使用非常简单, 只要实现Serializable接口即可. Serializable接口只是一个标志类, 系统会将实现了这个接口的类自动进行序列化. 如果想自定义序列化/反序列化过程, 可以自主实现writeObject()和readObject(). 一般我们都不会这么做的 还可以定义一个long serialVersionUID来检测反序列时的数据. 如果值不一样, 反序列时出抛出错误. 这个值可以使用Android Studio自动生成, 也可以手工指定一个. 数值不论如何, 其本质是一样的. 实现Serializable的类成员也一定是可以Serializable的, 比如基本类型int …" />
<meta name="keywords" content="android, 序列化, serializable, parceable">

<meta property="og:site_name" content="Ivicel's Ambertime"/>
<meta property="og:title" content="Android 对象序列化方式"/>
<meta property="og:description" content="Android内序列化对象主要有两种方式, 一是原Java自带的Serializable接口, 二是Android内自有的Parcelable接口 1. Serializable接口 Java自带的序列接口使用非常简单, 只要实现Serializable接口即可. Serializable接口只是一个标志类, 系统会将实现了这个接口的类自动进行序列化. 如果想自定义序列化/反序列化过程, 可以自主实现writeObject()和readObject(). 一般我们都不会这么做的 还可以定义一个long serialVersionUID来检测反序列时的数据. 如果值不一样, 反序列时出抛出错误. 这个值可以使用Android Studio自动生成, 也可以手工指定一个. 数值不论如何, 其本质是一样的. 实现Serializable的类成员也一定是可以Serializable的, 比如基本类型int …"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="./android-dui-xiang-xu-lie-hua-fang-shi.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2018-04-01 00:00:00+08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="./author/ivicel.html">
<meta property="article:section" content="Android"/>
<meta property="article:tag" content="android"/>
<meta property="article:tag" content="序列化"/>
<meta property="article:tag" content="serializable"/>
<meta property="article:tag" content="parceable"/>
<meta property="og:image" content="/images/favicon.ico">

  <title>Ivicel's Ambertime &ndash; Android 对象序列化方式</title>

</head>
<body>
  <aside>
    <div>
      <a href=".">
        <img src="/images/favicon.ico" alt="Ambertime" title="Ambertime">
      </a>
      <h1><a href=".">Ambertime</a></h1>

<p>Make memory in past times</p>

      <ul class="social">
      </ul>
    </div>


  </aside>
  <main>

    <nav>
      <a href=".">Home</a>



    </nav>

<article class="single">
  <header>
      
    <h1 id="android-dui-xiang-xu-lie-hua-fang-shi">Android 对象序列化方式</h1>
    <p>
      Posted on Sun 01 April 2018 in <a href="./category/android.html">Android</a>

    </p>
  </header>


  <div>
    <p><code>Android</code>内序列化对象主要有两种方式, 一是原<code>Java</code>自带的<code>Serializable</code>接口, 二是<code>Android</code>内自有的<code>Parcelable</code>接口</p>
<h3 id="1-serializable">1. <code>Serializable</code>接口</h3>
<p><code>Java</code>自带的序列接口使用非常简单, 只要实现<code>Serializable</code>接口即可. <code>Serializable</code>接口只是一个标志类, 系统会将实现了这个接口的类自动进行序列化. </p>
<blockquote>
<p>如果想自定义序列化/反序列化过程, 可以自主实现<code>writeObject()</code>和<code>readObject()</code>. 一般我们都不会这么做的</p>
</blockquote>
<p>还可以定义一个<code>long serialVersionUID</code>来检测反序列时的数据. 如果值不一样, 反序列时出抛出错误. 这个值可以使用<code>Android Studio</code>自动生成, 也可以手工指定一个. 数值不论如何, 其本质是一样的.</p>
<p>实现<code>Serializable</code>的类成员也一定是可以<code>Serializable</code>的, 比如基本类型<code>int</code>, <code>long</code>, 字符类型<code>String</code>, 或者实现了<code>Serializable</code>接口的自定义类. </p>
<p>可以使用关键字<code>transient</code>来标明不参与序列化过程的变量</p>
<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="kd">implements</span> <span class="n">Serializable</span> <span class="o">{</span>
    <span class="c1">// 定义一个数值以便验证反序列化时的数据正确性</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">8711368828010083044L</span><span class="o">;</span>

    <span class="c1">// 使用关键字 transient 表示变量不参与序列化过程</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="c1">// 要序列化的变量</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isMale</span><span class="o">;</span>

    <span class="c1">// getter and setter</span>
    <span class="c1">// .....</span>
<span class="o">}</span>
</pre></div>


<h3 id="2-parcelable">2. <code>Parcelable</code>接口</h3>
<p>由<code>Parcelable</code>序列化的类可以自由在<code>Binder</code>中进行传输. 但实现的过程会比<code>Serializable</code>麻烦些. 但是<code>Serializable</code>在序列化和反序列化时需要大量的<code>I/O</code>操作, 效率会比较低. 在<code>Android</code>中推荐使用<code>Parcelable</code>, 其在内存中序列化后可以立马发送到网络中, 或者保存到设备上. 如果数据较小也可以使用<code>Serializable</code>来实现, 其优点是方便简单</p>
<p>可<code>Parcelable</code>类里内的变量需要是基本类型或者是可序列化的对象. <code>Intent</code>, <code>Bundle</code>, <code>Bitmap</code>都实现了<code>Parcelable</code>接口. <code>List</code>, <code>Map</code>如果其内的每个元素是可序列化的话, 那么这两个也是可序列化的.</p>
<p>实现<code>Parcelable</code>要实现几个方法和变量:</p>
<ol>
<li><code>writeToParcel(Parcel out, int flag)</code>方法的实现表示类是如何创建序列化对象和数组的. <strong>注意这个实现是的顺序, 当反序列化时也需要按这个顺序来写</strong>
   <code>flags</code>的值一般为<code>0</code>或<code>1</code>(即<code>PARCELABLE_WRITE_RETURN_VALUE</code>), 当为<code>1</code>时表示当前对象需要作为返回值返回, 不能立即释放资源. <strong>通常一般这个值都为<code>0</code></strong></li>
<li><code>describeContents()</code>方法的返回值一般为<code>0</code>, 当序列化内容含有<strong>文件描述符</strong>时, 返回<code>1</code>(即<code>CONTENTS_FILE_DESCRIPTOR</code>)</li>
<li>定义一个<code>static final</code>的常量<code>CREATOR</code>来实现反序列化操作. 这个常量实现了<code>Parcelable.Creator</code>接口.
   <code>T createFromParcel(Parcel in)</code>方法表明如何反序列化一个类. <strong>反序列化的顺序要和序列化时一样</strong>
   <code>T[] newArray(int size)</code>方法表明如何反序列化出一个类的对象数组</li>
</ol>
<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="kd">implements</span> <span class="n">Parcelable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="c1">// 要注意自定义的类也得是可序列化的</span>
    <span class="kd">private</span> <span class="n">Book</span> <span class="n">book</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Book</span> <span class="n">book</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">book</span> <span class="o">=</span> <span class="n">book</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// getter and setter</span>
    <span class="c1">// .....</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">describeContents</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 一般返回 0, 除非有文件描述符存在才返回 1</span>
        <span class="n">reutrn</span> <span class="mi">0</span><span class="o">;</span>   
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">writeToParcel</span><span class="o">(</span><span class="n">Parcel</span> <span class="n">out</span><span class="o">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 序列化的过程, 注意其序列, 在反序列化时要一致</span>
        <span class="c1">// flags 一般传入值为0, 只有在当有需要不能立即释放资源时才会传入 1</span>
        <span class="n">out</span><span class="o">.</span><span class="na">wirteInt</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
        <span class="n">out</span><span class="o">.</span><span class="na">writeString</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="n">out</span><span class="o">.</span><span class="na">writeParcelable</span><span class="o">(</span><span class="n">book</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Parcelable</span><span class="o">.</span><span class="na">Creator</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">CREATOR</span> <span class="o">=</span> 
            <span class="k">new</span> <span class="n">Parceable</span><span class="o">.</span><span class="na">Creator</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;()</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="n">User</span> <span class="nf">createFromParcel</span><span class="o">(</span><span class="n">Parcel</span> <span class="n">in</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 反序列化过程</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">User</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 反序列化数组时的过程</span>
        <span class="kd">public</span> <span class="n">User</span><span class="o">[]</span> <span class="nf">newArray</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">User</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// 反序列化的过程需要注意和序列化时的顺序一致</span>
        <span class="kd">private</span> <span class="nf">User</span><span class="o">(</span><span class="n">Parcel</span> <span class="n">in</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">name</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readString</span><span class="o">();</span>
            <span class="c1">// 需要一个 classLoader 来加载类</span>
            <span class="c1">// 可以从当前线程加载类中查找, 或者指一个类加载</span>
            <span class="c1">// Book book = in.readParcel(Book.class.getClassLoader())</span>
            <span class="n">Book</span> <span class="n">book</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readParcel</span><span class="o">(</span>
                <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getContextClassLoader</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h5 id="reference">Reference:</h5>
<ol>
<li>&lt;<Android 开发艺术探索>&gt;</li>
<li>https://developer.android.com/reference/android/os/Parcelable.html</li>
</ol>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="./tag/android.html">android</a>
      <a href="./tag/xu-lie-hua.html">序列化</a>
      <a href="./tag/serializable.html">serializable</a>
      <a href="./tag/parceable.html">parceable</a>
    </p>
  </div>





</article>

    <footer>
<p>
  &copy;  2018 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Powered by <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
           src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>




<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Ivicel's Ambertime ",
  "url" : ".",
  "image": "/images/favicon.ico",
  "description": "ivicel's thoughts and writings"
}
</script>

</body>
</html>