<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />


  <title>View绘制流程</title>


  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="referrer" content="origin" />
  <meta name="generator" content="Pelican" />
  <link href="./" rel="canonical" />

  <!-- Feed -->

  <link href="./theme/css/style.css" type="text/css" rel="stylesheet" />

  <!-- Code highlight color scheme -->
      <link href="./theme/css/code_blocks/github.css" rel="stylesheet">

    <!-- CSS specified by the user -->


    <link href="./assets/css/prism.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/base.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/base-control.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/github.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/codemirror.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/ivicel.css" type="text/css" rel="stylesheet" />

  <!-- Custom fonts -->
  <link href='https://fonts.googleapis.com/css?family=Montserrat:400,300' rel='stylesheet' type='text/css' />
  <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css" />

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->


  <link href="./viewhui-zhi-liu-cheng.html" rel="canonical" />

    <meta name="description" content="一 . view 的 MeasureSpec 测量取值 对于 DecorView 其大小要求要 ViewRootImpl 中测量 如果要求 MACTH_PARENT, 就设置为窗口的大小 windowSize, 模式为精确 EXACTLY 如果要求为内容大小...">

    <meta name="author" content="ivicel">

    <meta name="tags" content="android">
    <meta name="tags" content="view绘制">




<!-- Open Graph -->
<meta property="og:site_name" content="Ambertime"/>
<meta property="og:title" content="View绘制流程"/>
<meta property="og:description" content="一 . view 的 MeasureSpec 测量取值 对于 DecorView 其大小要求要 ViewRootImpl 中测量 如果要求 MACTH_PARENT, 就设置为窗口的大小 windowSize, 模式为精确 EXACTLY 如果要求为内容大小..."/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="./viewhui-zhi-liu-cheng.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2018-02-22 00:00:00+08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="./author/ivicel.html">
<meta property="article:section" content="Android"/>
<meta property="article:tag" content="android"/>
<meta property="article:tag" content="view绘制"/>
<meta property="og:image" content="./theme/images/post-bg.jpg">

<!-- Twitter Card -->

<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "name": "View绘制流程",
  "headline": "View绘制流程",
  "datePublished": "2018-02-22 00:00:00+08:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "ivicel",
    "url": "./author/ivicel.html"
  },
  "image": "./theme/images/post-bg.jpg",
  "url": "./viewhui-zhi-liu-cheng.html",
  "description": "一 . view 的 MeasureSpec 测量取值 对于 DecorView 其大小要求要 ViewRootImpl 中测量 如果要求 MACTH_PARENT, 就设置为窗口的大小 windowSize, 模式为精确 EXACTLY 如果要求为内容大小..."
}
</script>
</head>
<!-- TODO : Body class -->
<body class="home-template">

<nav id="menu">
  <a class="close-button">Close</a>
  <div class="nav-wrapper">
    <p class="nav-label">Menu</p>
    <ul>


    </ul>
  </div>
</nav>
    <!-- Progressbar -->
    <div class="progress-container">
        <span class="progress-bar"></span>
    </div>

    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
    <header id="blog-header" >
      <div class="inner">
        <nav id="navigation">
            <span id="home-button" class="nav-button">
                <a class="home-button" href="./" title="Home"><i class="ic ic-arrow-left"></i> Home</a>
            </span>
          <span id="menu-button" class="nav-button">
            <a class="menu-button"><i class="ic ic-menu"></i> Menu</a>
          </span>
        </nav>
        <h1 class="post-title">View绘制流程</h1>
        <!-- TODO : Proper class for headline -->
        <span class="post-meta">
                <a href="./author/ivicel.html">Ivicel</a>
            | <time datetime="Thu 22 February 2018">Thu 22 February 2018</time>
        </span>
        <!-- TODO : Modified check -->
      </div>
    </header>

  <section id="wrapper">
    <a class="hidden-close"></a>

    <!-- Post content -->
    <main class="content" role="main">
        <article class="post">
        <div class="inner">
            <section class="post-content">
                <ul>
<li>
<p> 一 .  <code>view</code> 的 <code>MeasureSpec</code> 测量取值 </p>
</li>
<li>
<p> 对于 <code>DecorView</code> 其大小要求要 <code>ViewRootImpl</code> 中测量 </p>
</li>
<li>
<p> 如果要求 <code>MACTH_PARENT</code>, 就设置为窗口的大小 <code>windowSize</code>, 模式为精确 <code>EXACTLY</code></p>
</li>
<li> 如果要求为内容大小 <code>WRAP_CONTENT</code>, 就设置为窗口大小 <code>windowSize</code>, 模式为至多 <code>AT_MOST</code>, 表示不能超过子 <code>view</code> 这个大小 </li>
<li> 默认设置为要求的大小 <code>rootDimension</code>, 模式为精确 <code>EXACTLY</code></li>
</ul>
<pre class="highlight"><code class="language-java linenums">   // ViewRootImpl#getRootMeasureSpec
   private static int getRootMeasureSpec(int windowSize, int rootDimension) {
           int measureSpec;
           switch (rootDimension) {
           case ViewGroup.LayoutParams.MATCH_PARENT:
               // Window can't resize. Force root view to be windowSize.
               measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
               break;
           case ViewGroup.LayoutParams.WRAP_CONTENT:
               // Window can resize. Set max size for root view.
               measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
               break;
           default:
               // Window wants to be an exact size. Force root view to be that size.
               measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
               break;
           }
           return measureSpec;
       }</code></pre>

<ol>
<li> 普通子 <code>view</code> 的大小要受到父 <code>ViewGroup</code> 的 <code>MeasureSpec.getMode</code> 的值 (<code>UNSPECIFIED</code>, <code>EXACTLY</code>, <code>AT_MOST</code>) 影响 . 子 <code>view</code> 的大小指子 <code>view</code> 的 <strong> 内容 + 左右 <code>margin</code>+ 左右 <code>padding</code> 值 </strong></li>
</ol>
<p><img alt=" 子 view 的 MeasureSpec" src="../images/ 子 view 的 MeasureSpec.png" /></p>
<p> 子 <code>view</code> 的测量要从父 <code>ViewGroup</code> 开始 , 在 <code>ViewGroup#measureChildWithMargins</code> 中 , 如果这个 <code>view</code> 支持 <code>margin</code>, <code>padding</code> 的话 </p>
<pre class="highlight"><code class="language-java linenums">// ViewGroup#measureChildWithMargins

protected void measureChildWithMargins(View child,
            int parentWidthMeasureSpec, int widthUsed,
            int parentHeightMeasureSpec, int heightUsed) {
        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();

        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin
                        + widthUsed, lp.width);
        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin
                        + heightUsed, lp.height);

        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
    }

// 在计算 margin, padding 后 , 调用 getChildMeasureSpec 来获得子 view 大小和模式 
// 然后进行子 view 测量循环

// ViewGroup#getChildMeasureSpec
// 该方法结果取值为上表

public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
        int specMode = MeasureSpec.getMode(spec);
        int specSize = MeasureSpec.getSize(spec);

        // 去掉 margin 和 padding 之后的大小 , 负值表示超出父 ViewGroup, 则取 0
        int size = Math.max(0, specSize - padding);

        int resultSize = 0;
        int resultMode = 0;

        switch (specMode) {
        // Parent has imposed an exact size on us
        case MeasureSpec.EXACTLY:
            if (childDimension &gt;= 0) {
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size. So be it.
                resultSize = size;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        // Parent has imposed a maximum size on us
        case MeasureSpec.AT_MOST:
            if (childDimension &gt;= 0) {
                // Child wants a specific size... so be it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size, but our size is not fixed.
                // Constrain child to not be bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        // Parent asked to see how big we want to be
        case MeasureSpec.UNSPECIFIED:
            if (childDimension &gt;= 0) {
                // Child wants a specific size... let him have it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size... find out how big it should
                // be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size.... find out how
                // big it should be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            }
            break;
        }
        //noinspection ResourceType
        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
    }</code></pre>

<ul>
<li>
<h4 id="view"> 二 . <code>View</code> 的工作流程 </h4>
</li>
</ul>
<p><code>view</code> 的测量分两种情况 , 没有子 <code>view</code> 的测量 , 另一种是测量 <code>ViewGroup</code>, 此时需要再递归测量 </p>
<ol>
<li> 当测量 <code>view</code> 时会调用 <code>View#measure</code>, 该方法是 <code>final</code> 不能重写 . 如果 <code>view</code> 没有测量过或者是需要重新测量的 , 该方法会调用 <code>View#onMeasure</code>, 如有需要可以重写 <code>View#onMeasure</code>, <strong> 注意 , 如果需要 <code>view</code> 支持 <code>padding</code> 属性则需要在此处理 </strong></li>
</ol>
<pre class="highlight"><code class="language-java linenums">// View#onMeasure

protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    // getSuggestMinimumXXX 主要是检测是否设置了背景 , 如果设置了取
    // mMinXXX 和 background.mMinXXX 的中的最大值 . 没有设置则取 mMinXXX
    // mMinXXX 由 xml 中的 android:minHeight, android:minWidth 来设置

    setMeasuredDimension(
        getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
        getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}

// View#getDefaultSize

public static int getDefaultSize(int size, int measureSpec) {
      int result = size;
      int specMode = MeasureSpec.getMode(measureSpec);
      int specSize = MeasureSpec.getSize(measureSpec);

      switch (specMode) {
        // 该值多用于系统控件的测量
        case MeasureSpec.UNSPECIFIED:
            result = size;
            break;
        // 一般自定义 view 时使用这两个选项
        case MeasureSpec.AT_MOST:
        case MeasureSpec.EXACTLY:
            result = specSize;
            break;
      }
      return result;
  }

// View#getSuggestMinimumWidth

// 如果 view 没有背景 , 返回 android:minWidth, 默认为 0
// 如果 view 有背景 , 返回 背景的最小宽度 和 android:minWidth 中的最大值 
// 高度下同
protected int getSuggestedMinimumWidth() {
    return (mBackground == null) ? mMinWidth : 
            max(mMinWidth, mBackground.getMinimumWidth());
}

// View#getSuggestMinimumHeight

protected int getSuggestedMinimumHeight() {
    return (mBackground == null) ? mMinHeight : 
            max(mMinHeight, mBackground.getMinimumHeight());
}</code></pre>

<p> 一般自定义 <code>view</code> 多使用 <code>AT_MOST</code>, <code>EXACTLY</code> 来指定大小 </p>
<p> 这样其 <code>specWidth</code>, <code>specHeight</code> 就决定其宽 / 高度的大小 . 所以当我们直接继承 <code>View</code> 来自定义 <code>view</code> 时 , 如果设置 <code>view</code> 的宽 / 高为 <code>wrap_content</code> 时 , 结合上表中的值 , 可以知道如果我们不测量该 <code>view</code> 内容的大小 , 其最终的大小为父 <code>ViewGroup</code> 的大小 , 和设置 <code>match_parent</code> 一样 . 可以使用以下的方法解决 </p>
<pre class="highlight"><code class="language-java linenums">// 重写该 view 的 onMeasure, 测量内容大小
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);

    int widthMeasureMode = MeasureSpec.getMode(widthMeasureSpec);
    int widthMeasureSize = MeasureSpec.getSize(widthMeasureSpec);

    int heightMeasureMode = MeasureSpec.getMode(heightMeasureSpec);
    int heightMeasureSize = MeasureSpec.getSize(heightMeasureSpec);

    // mWidth, mHeight 是自己设定的一个默认的宽 / 高度
    ViewGroup.LayoutParams lp = getLayoutParams();
    int width = (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; 
        lp.width == ViewGroup.LayoutParams.WRAP_CONTENT) ? mWidth : widthMeasureSize;
    int height = (heightSpecMode == MeasureSpec.AT_MOST &amp;&amp;
        lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) ? mHeight : heightMeasureSize;
    setMeasuredDimension(width, height)
}</code></pre>

<ol>
<li><code>ViewGroup</code> 的 <code>measure</code> 过程 . 对于 <code>ViewGroup</code> 来说 , 除了要测量自己的大小外 , 还有递归的测量各个子元素的大小 . 由于不同的布局其测量方法定义不同 , 所以 <code>ViewGroup</code> 没有默认的 <code>onMeasure</code> 方法 , 而是需要具体的继承类来实现该方法 . <code>onMeasure</code> 中调用 <code>measureChildren</code> 或是 <code>measureChildWithMargins</code> 来测量子类 </li>
</ol>
<p><strong> 需要注意的是如果不需要子 <code>view</code> 支持 <code>margin</code> 时 , 使用 <code>ViewGroup#measureChildren</code> 来测量 , 否则应当使用 <code>ViewGroup#measureChildWithMargins</code>, 自定义的 <code>ViewGroup</code> 在重写 <code>onMeasure</code> 时需要特别注意 </strong></p>
<pre class="highlight"><code class="language-java linenums">// ViewGroup#measureChildren

// measureChild 主要递归的调用 view#measure 来测量子 view
// 的大小 , 如果 view 不为 View.GONE 的话
protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
    final int size = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i &lt; size; ++i) {
        final View child = children[i];
        if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) {
            measureChild(child, widthMeasureSpec, heightMeasureSpec);
        }
    }
}

protected void measureChild(View child, int parentWidthMeasureSpec,
        int parentHeightMeasureSpec) {
    final LayoutParams lp = child.getLayoutParams();

    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
            mPaddingLeft + mPaddingRight, lp.width);
    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
            mPaddingTop + mPaddingBottom, lp.height);

    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
}</code></pre>

<p><code>layout</code> 过程 . 当 <code>ViewGroup</code> 的位置确定后 , 其会调用 <code>layout</code>, 并在其中调用 <code>onLayout</code> 来遍历子 <code>view</code> 的 <code>layout</code> 方法来确定子 <code>view</code> 的位置 . 子 <code>view</code> 的 <code>layout</code> 会调用自己的 <code>onLayout</code> 方法 . <code>ViewGroup</code> 没有默认实现 <code>onLayout</code>, 交给具体的布局来实现 , 以方法实现不同的布局 </p>
<pre class="highlight"><code class="language-java linenums">// ViewGroup#layout
@Override
public final void layout(int l, int t, int r, int b) {
    if (!mSuppressLayout &amp;&amp; (mTransition == null ||          
         !mTransition.isChangingLayout())) {
        if (mTransition != null) {
            mTransition.layoutChange(this);
        }
        super.layout(l, t, r, b);
    } else {
        // record the fact that we noop'd it; request layout when transition finishes
        mLayoutCalledWhileSuppressed = true;
    }
}

// View#layout
public void layout(int l, int t, int r, int b) {
    if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) {
        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);
        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
    }

    int oldL = mLeft;
    int oldT = mTop;
    int oldB = mBottom;
    int oldR = mRight;

    boolean changed = isLayoutModeOptical(mParent) ?
            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);

    if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {
        onLayout(changed, l, t, r, b);

        if (shouldDrawRoundScrollbar()) {
            if(mRoundScrollbarRenderer == null) {
                mRoundScrollbarRenderer = new RoundScrollbarRenderer(this);
            }
        } else {
            mRoundScrollbarRenderer = null;
        }

        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;

        ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) {
            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =
                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();
            int numListeners = listenersCopy.size();
            for (int i = 0; i &lt; numListeners; ++i) {
                listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);
            }
        }
    }

    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;
    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;

    if ((mPrivateFlags3 &amp; PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT) != 0) {
        mPrivateFlags3 &amp;= ~PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT;
        notifyEnterOrExitForAutoFillIfNeeded(true);
    }
}</code></pre>

<p>​   绘制过程 <code>draw</code>. 绘制过程主要分为 1. 绘制背景 <code>background.draw(canvas)</code>, 2. 绘制自己 <code>onDraw</code>, 3. 绘制 <code>children</code>.<code>dispatchDraw</code> 方法 , 4. 绘制装饰 <code>onDrawScrollBars</code>. 主要调用 <code>View#draw</code> 方法 </p>
<p>​   在 <code>View</code> 中有一个 <code>View#setWillNotDraw</code> 方法 , 设置 <code>true</code> 表示不绘制该 <code>view</code>. 默认为 <code>false</code>. 当继承 <code>ViewGroup</code> 时 , 需要手动设置为 <code>false</code> 关闭该标志位以便通过 <code>onDraw</code> 来绘制 <code>view</code></p>
            </section>

            <section class="post-info">
                <div class="post-share">
                    <a class="twitter" href="https://twitter.com/share?text=View绘制流程&amp;url=./viewhui-zhi-liu-cheng.html" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <i class="ic ic-twitter"></i><span class="hidden">Twitter</span>
                    </a>
                    <a class="facebook" href="https://www.facebook.com/sharer/sharer.php?u=./viewhui-zhi-liu-cheng.html" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <i class="ic ic-facebook"></i><span class="hidden">Facebook</span>
                    </a>
                    <a class="googleplus" href="https://plus.google.com/share?url=./viewhui-zhi-liu-cheng.html" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <i class="ic ic-googleplus"></i><span class="hidden">Google+</span>
                    </a>
                    <div class="clear"></div>
                </div>

                <aside class="post-tags">
<a href="./tag/android.html">android</a><a href="./tag/viewhui-zhi.html">view绘制</a>                </aside>

                <div class="clear"></div>


                </section>


                <aside class="post-nav">
                    <div class="clear"></div>
                </aside>

            </div>
        </article>
    </main>
      <!-- TODO : Body class -->
    <div id="body-class" style="display: none;" class=""></div>

    <footer id="footer">
      <div class="inner">
        <section class="credits">


          <span class="credits-theme">Theme <a href="https://github.com/arulrajnet/attila" rel="nofollow">Attila</a></span>
          <span class="credits-software">Published with <a href="https://github.com/getpelican/pelican" rel="nofollow">Pelican</a></span>
        </section>
      </div>
    </footer>
  </section>

  <script type="text/javascript" src="./theme/js/script.js"></script>

    <!-- Script specified by the user -->
    <script type="text/javascript"  src="./assets/js/prism.js"></script>
</body>
</html>