<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />


  <title>Android IPC机制</title>


  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="referrer" content="origin" />
  <meta name="generator" content="Pelican" />
  <link href="./" rel="canonical" />

  <!-- Feed -->

  <link href="./theme/css/style.css" type="text/css" rel="stylesheet" />

  <!-- Code highlight color scheme -->
      <link href="./theme/css/code_blocks/github.css" rel="stylesheet">

    <!-- CSS specified by the user -->


    <link href="./assets/css/prism.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/base.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/base-control.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/github.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/codemirror.css" type="text/css" rel="stylesheet" />


    <link href="./assets/css/ivicel.css" type="text/css" rel="stylesheet" />

  <!-- Custom fonts -->
  <link href='https://fonts.googleapis.com/css?family=Montserrat:400,300' rel='stylesheet' type='text/css' />
  <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css" />

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->


  <link href="./android-ipcji-zhi.html" rel="canonical" />

    <meta name="description" content="1. 开启多进程的方法 Android 应用启动时会自动创建一个新的进程 , 其进程名默认为 包名 , 为四大组件 (Activity , Service, ContentProvider, BroadcastReceiver) 启动一个新的进程 , 最简单的是在...">

    <meta name="author" content="ivicel">

    <meta name="tags" content="IPC">
    <meta name="tags" content="Android">
    <meta name="tags" content="进程间通信">




<!-- Open Graph -->
<meta property="og:site_name" content="Ambertime"/>
<meta property="og:title" content="Android IPC机制"/>
<meta property="og:description" content="1. 开启多进程的方法 Android 应用启动时会自动创建一个新的进程 , 其进程名默认为 包名 , 为四大组件 (Activity , Service, ContentProvider, BroadcastReceiver) 启动一个新的进程 , 最简单的是在..."/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="./android-ipcji-zhi.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2018-04-01 00:00:00+08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="./author/ivicel.html">
<meta property="article:section" content="Android"/>
<meta property="article:tag" content="IPC"/>
<meta property="article:tag" content="Android"/>
<meta property="article:tag" content="进程间通信"/>
<meta property="og:image" content="./theme/images/post-bg.jpg">

<!-- Twitter Card -->

<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "name": "Android IPC机制",
  "headline": "Android IPC机制",
  "datePublished": "2018-04-01 00:00:00+08:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "ivicel",
    "url": "./author/ivicel.html"
  },
  "image": "./theme/images/post-bg.jpg",
  "url": "./android-ipcji-zhi.html",
  "description": "1. 开启多进程的方法 Android 应用启动时会自动创建一个新的进程 , 其进程名默认为 包名 , 为四大组件 (Activity , Service, ContentProvider, BroadcastReceiver) 启动一个新的进程 , 最简单的是在..."
}
</script>
</head>
<!-- TODO : Body class -->
<body class="home-template">

<nav id="menu">
  <a class="close-button">Close</a>
  <div class="nav-wrapper">
    <p class="nav-label">Menu</p>
    <ul>


    </ul>
  </div>
</nav>
    <!-- Progressbar -->
    <div class="progress-container">
        <span class="progress-bar"></span>
    </div>

    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
    <header id="blog-header" >
      <div class="inner">
        <nav id="navigation">
            <span id="home-button" class="nav-button">
                <a class="home-button" href="./" title="Home"><i class="ic ic-arrow-left"></i> Home</a>
            </span>
          <span id="menu-button" class="nav-button">
            <a class="menu-button"><i class="ic ic-menu"></i> Menu</a>
          </span>
        </nav>
        <h1 class="post-title">Android IPC机制</h1>
        <!-- TODO : Proper class for headline -->
        <span class="post-meta">
                <a href="./author/ivicel.html">Ivicel</a>
            | <time datetime="Sun 01 April 2018">Sun 01 April 2018</time>
        </span>
        <!-- TODO : Modified check -->
      </div>
    </header>

  <section id="wrapper">
    <a class="hidden-close"></a>

    <!-- Post content -->
    <main class="content" role="main">
        <article class="post">
        <div class="inner">
            <section class="post-content">
                <h4 id="1">1. 开启多进程的方法 </h4>
<p>Android 应用启动时会自动创建一个新的进程 , 其进程名默认为 <strong> 包名 </strong>, 为四大组件 (<strong>Activity</strong> , <strong>Service</strong>, <strong>ContentProvider</strong>, <strong>BroadcastReceiver</strong>) 启动一个新的进程 , 最简单的是在 <code>Manifest.xml</code> 中为其配置 <code>android:process</code> 进程名称 . 有两种写法 . </p>
<p> 一是指定进程的全称 :<code>android:process="info.ivicel.github.android_ipc.another_process"</code>, 此时进程为一个全局进程 , 其他应用可以通过 <code>ShareUID</code> 方式和它跑在同一进程中 </p>
<p> 二是简写 : <code>android:process=":remote"</code>. 这种写法其完整的进程名为 <code> 包名 :remote</code>, 并且此时进程为一个私有进程 , 其他应用的组件不可以同时跑在该进程中 </p>
<blockquote>
<p> 由于 Android 中为不同进程单独分配一个虚拟机来运行 , 所以 Android 中不能通过 <strong> 共享内存 </strong> 来进行通信 . </p>
</blockquote>
<p> 在 Android 中使用 <strong> 共享内存 </strong>, 便会造成 :</p>
<ol>
<li> 静态成员和单例模式完全失效 </li>
<li> 线程的同步机制完全失效 , 通过共享内存来 <code>synchronized</code>, 锁对象 / 锁全局类都不是同一个了 </li>
<li><code>SharedPreferences</code> 的可靠性下降 . 这是因为 <code>SharedPreferences</code> 底层是通过 <code>xml</code> 文件的来实现的 , 需要对文件的读写进行同步 </li>
<li><code>Application</code> 会多次创建 . 多进程会为每一个进程启动一 <code>Application</code>, 相当多次启动应用 . 可以在 <code>Application</code> 的 <code>onCreate()</code> 里打印出进程 <code>id</code> 证实启动了多次应用 </li>
</ol>
<h4 id="2-android-ipc">2. Android 中 IPC 的几种方式 </h4>
<p> 在 Android 中的 IPC 大致有以下几种 : </p>
<ul>
<li> 通过 <code>Intent</code> 的附加 <code>extras</code> 来传递 , 其本质是通过 <code>Bundle</code> 来实现的 </li>
<li> 通过共享文件 </li>
<li> 通过 <code>Binder</code>, 其底层是通过 <code>AIDL</code> 来实现 </li>
<li> 通过 <code>ContentProvider</code></li>
<li> 通过网络 <code>Socket</code></li>
<li> 直接使用 <code>AIDL</code></li>
<li>
<p> 通过 <code>Messenger</code>, 注意这不是消息载体 <code>Message</code></p>
</li>
<li>
<h5 id="bundle"> 使用 Bundle</h5>
</li>
</ul>
<p><code>Bundle</code> 的使用很是简单 , 其实现了 <code>Pacelable</code> 接口 , 可以直接传递各种可序列化的数据 . </p>
<p> 这种方式虽然简单易用 , 但如果需要传输的数据不支持 <code>Bundle</code>, 那只能通过其他绕路方式 . 比如需要在 A 进程中计算出某个结果 , 然后启动进程 B, 同时把结果传给 B. 但计算结果不支持传输 . 可以启动一个 B 进程里的后台 Service, 在其中计算出结果 , 再传到前台 B 进程了 . Service 和 B 是同一个进程 .</p>
<p>​</p>
<ol>
<li>
<h5 id="_1"> 使用共享文件 </h5>
</li>
</ol>
<p> 可以在进程 <code>A</code> 中写入文件 , 在进程 <code>B</code> 中读出文件内容 , 要注意的是读出的对象和写入时的对象其内容数据虽然一样 , 但本质上是两个对象 . 并且使用共享文件进行通信时 , 如果要求的并发量过高 , 其同步就越困难 , 有可能出并发读 / 写时数据不一致的情况 . 其适合使用在对数据同步要求不高的进程之间的通信 .
   <code>SharedPreferences</code> 其底层的实现也是一个 <code>.xml</code> 文件 , 但是系统对其读 / 写时 , 会维护一个在内存里的缓存 , 这使得多进程模式下对 <code>SharedPreferences</code> 的读写非常不可靠 . 所以不要使用其行 IPC</p>
<p>​</p>
<ol>
<li>
<h5 id="aidl"> 使用 AIDL 通信 </h5>
</li>
</ol>
<p> 见 <a href="./zai-androidzhong-shi-yong-aidljin-xing-ipc.html"> 在 Android 中使用 AIDL 进行 IPC</a></p>
<p>​</p>
<ol>
<li>
<h5 id="messenger"> 使用 Messenger</h5>
</li>
</ol>
<p><code>Messenger</code> 是对 AIDL 的封装 , 使用起来更加的方便 . 服务端每一次只处理一个请求 , 使用的 <code>MessageQueue</code> 队列 , 这样在服务端可以不用考虑并发的问题 .</p>
<p>###### 4.1 服务端 </p>
<p> 由于是对 AIDL 的封装 , 所以服务端也是创建一个 Service, 创建一个 Messenger 对象和一个 Handler 对象 ,</p>
<p>Handler 处理客户端发送过来的数据 . Service 的 Binder 对象可由 Messenger 对象返回 .</p>
<p>###### 4.2 客户端 </p>
<p> 客户端通过 <code>bindService()</code> 拿到服务端的代理 . 通信的数据由 <code>Message</code> 类来封装 . 这个代理对象传送数据的方向为 client -&gt; server, 只能单向传输 .</p>
<p> 如果客户端需要服务器传回数据 , 只能在客户端创建一个 <code>Messenger</code> 对象和 <code>Handler</code> 对象 , 并通过 <code>Message.replyTo</code> 将这个对象传给服务器 . 这样 server -&gt; client 就可以传送数据了 .</p>
<blockquote>
<p><code>Messenger</code> 类是 <code>final</code> 的 , 不可能通过继承 <code>Messenger</code> 来重写传送数据方式 </p>
</blockquote>
<p><img alt="Messenger 机制 " src="../images/Messenger 机制 .jpeg" /></p>
<pre class="highlight"><code class="language-java linenums">// server 
public MessengerService extends Service {
    private static final String TAG = "MessengerService";

    static class MessengerHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case Constants.MSG_HELLO_FROM_CLIENT:
                    Log.d(TAG, "Hello from client: " + 
                          msg.getData().getString("msg"));
                    break;

                default:
                    super.handleMessage(msg);
            }
        }
    }

    private Messenger mMessenger = new Messenger(new MessengerHandler());   


    @Override
    public IBinder onBind(Intent intent) {
        return mMessenger.getBinder();   
    }
}


// client
public MessengerActivity extends AppCompatActivity {
    private staitc final String TAG = "MessengerActivity";

    private Messenger mMessenger;

    private SerivceConnection connection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            mMessenger = new Messenger(service);
            sendHelloToServer();
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {}
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Intent intent = new Intent(this, MessengerService.class);
        bindService(intent, connection, Context.BIND_AUTO_CREATE);
    }

    private void sendHelloToServer() {
        Message msg = Message.obtain(null, Constants.MSG_HELLO_FROM_CLIENT);
        Bundle data = new Bundle();
        data.putString("msg", "this is hello from client.");
        msg.setData(data);
        try {
            mMessenger.send(msg);
        } catch (RemoteException e) {
            e.printStackTrace();   
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        unbindService(connection);
    }
}</code></pre>

<p> 在 &lt;<Android 开发艺术探索 >&gt; 中提到 :</p>
<blockquote>
<p>Message 中的另一个字段 object 在同一个进程中是很实用的，但是在进程间通信的时候，在 Android 2.2 以前 object 字段不支持跨进程传输，即便是 2.2 以后，也仅仅是 <strong> 系统 </strong> 提供的实现了 Parcelable 接口的对象才能通过它来传输。这就意味着我们自定义的 Parcelable 对象是无法通过 object 字段来传输的 </p>
</blockquote>
<p> 测试例子 : <a href="https://github.com/ivicel/dev-android-samples/tree/master/ipc-with-messenger">GitHub</a></p>
<p> 测试环境 : </p>
<ul>
<li>Android Studio 3.1</li>
<li>Gradle 4.4</li>
<li>android gradle tool 3.1</li>
<li>target sdk 27</li>
<li>Build tool 27.0.2</li>
</ul>
<p><code>MessengerService</code> 使用设置 <code>android:process=":remote"</code> 单独一个进程后 , 会发生 <code>java.lang.ClassNotFoundException</code>, 猜测是因为找到不 <code>ClassLoader</code></p>
<h4 id="reference">Reference:</h4>
<ol>
<li>&lt;<Android 开发艺术探索 >&gt;</li>
</ol>
            </section>

            <section class="post-info">
                <div class="post-share">
                    <a class="twitter" href="https://twitter.com/share?text=Android IPC机制&amp;url=./android-ipcji-zhi.html" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <i class="ic ic-twitter"></i><span class="hidden">Twitter</span>
                    </a>
                    <a class="facebook" href="https://www.facebook.com/sharer/sharer.php?u=./android-ipcji-zhi.html" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <i class="ic ic-facebook"></i><span class="hidden">Facebook</span>
                    </a>
                    <a class="googleplus" href="https://plus.google.com/share?url=./android-ipcji-zhi.html" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <i class="ic ic-googleplus"></i><span class="hidden">Google+</span>
                    </a>
                    <div class="clear"></div>
                </div>

                <aside class="post-tags">
<a href="./tag/ipc.html">IPC</a><a href="./tag/android.html">Android</a><a href="./tag/jin-cheng-jian-tong-xin.html">进程间通信</a>                </aside>

                <div class="clear"></div>


                </section>


                <aside class="post-nav">
                    <div class="clear"></div>
                </aside>

            </div>
        </article>
    </main>
      <!-- TODO : Body class -->
    <div id="body-class" style="display: none;" class=""></div>

    <footer id="footer">
      <div class="inner">
        <section class="credits">


          <span class="credits-theme">Theme <a href="https://github.com/arulrajnet/attila" rel="nofollow">Attila</a></span>
          <span class="credits-software">Published with <a href="https://github.com/getpelican/pelican" rel="nofollow">Pelican</a></span>
        </section>
      </div>
    </footer>
  </section>

  <script type="text/javascript" src="./theme/js/script.js"></script>

    <!-- Script specified by the user -->
    <script type="text/javascript"  src="./assets/js/prism.js"></script>
</body>
</html>