
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="index, follow" />

  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:300,400,400i,700" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="./theme/pygments/manni.min.css">
  <link rel="stylesheet" type="text/css" href="./theme/font-awesome/css/font-awesome.min.css">

    <link href="./static/custom.css" rel="stylesheet">



    <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/images/favicon.ico" type="image/x-icon">

<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-113622715-2', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->

<meta name="author" content="ivicel" />
<meta name="description" content="图(Graphs) 图由顶点(vertices)和边(edges)组成, 图的边分为有向和无向 图表示为G=(V, E), V 代表顶点的集合, E 和 V 是一种二元关系 有向图: V={1, 2, 3, 4} 和 E = {(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 2), (3, 4)} 无向图: V={1, 2, 3 …" />
<meta name="keywords" content="算法, C, 图, 数据结构">

<meta property="og:site_name" content="Ivicel's Ambertime"/>
<meta property="og:title" content="Matserting Algorithms with C-7: 图"/>
<meta property="og:description" content="图(Graphs) 图由顶点(vertices)和边(edges)组成, 图的边分为有向和无向 图表示为G=(V, E), V 代表顶点的集合, E 和 V 是一种二元关系 有向图: V={1, 2, 3, 4} 和 E = {(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 2), (3, 4)} 无向图: V={1, 2, 3 …"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="./matserting-algorithms-with-c-7-tu.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2017-04-02 00:00:00+08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="./author/ivicel.html">
<meta property="article:section" content="Data Structure Algorithms"/>
<meta property="article:tag" content="算法"/>
<meta property="article:tag" content="C"/>
<meta property="article:tag" content="图"/>
<meta property="article:tag" content="数据结构"/>
<meta property="og:image" content="/images/favicon.ico">

  <title>Ivicel's Ambertime &ndash; Matserting Algorithms with C-7: 图</title>

</head>
<body>
  <aside>
    <div>
      <a href=".">
        <img src="/images/favicon.ico" alt="Ambertime" title="Ambertime">
      </a>
      <h1><a href=".">Ambertime</a></h1>

<p>Make memory in past times</p>

      <ul class="social">
      </ul>
    </div>


  </aside>
  <main>

    <nav>
      <a href=".">Home</a>



    </nav>

<article class="single">
  <header>
      
    <h1 id="matserting-algorithms-with-c-7-tu">Matserting Algorithms with C-7: 图</h1>
    <p>
      Posted on Sun 02 April 2017 in <a href="./category/data-structure-algorithms.html">Data Structure Algorithms</a>

    </p>
  </header>


  <div>
    <h3 id="graphs">图(Graphs)</h3>
<p><img alt="图" src="../images/图.png" /></p>
<p>图由<strong>顶点</strong>(vertices)和<strong>边</strong>(edges)组成, 图的边分为<strong>有向</strong>和<strong>无向</strong></p>
<p>图表示为<code>G=(V, E)</code>, V 代表顶点的集合, E 和 V 是一种二元关系</p>
<blockquote>
<p>有向图: V={1, 2, 3, 4} 和 E = {(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 2), (3, 4)}</p>
<p>无向图: V={1, 2, 3, 4} 和 E = {(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)}</p>
<p>有向图中<code>(1, 2)</code>代表中顶点 <code>1</code>指向顶点<code>2</code></p>
</blockquote>
<p>图中两个重要关系是<strong>邻接</strong>(adjacency)和<strong>关联</strong>(incidence)</p>
<blockquote>
<p>无向图中, 顶点相连就是邻接, 而在有向图中, 只有两个顶点都相互指向对方是才是邻接的, 上图 1 和 2 就不邻接</p>
<p>关联是指顶点和边之间的关系. 有向图<code>(1, 2)</code>中称<code>1</code>关联到<code>2</code>, 无向图都是相互关联的</p>
<p>顶点的入度(in-degree)是指以顶点为终点的边的数目</p>
<p>顶点的出度(out-degree)是指以顶点为起点的边的数目</p>
<p>无向图中入度和出度都指顶点边的数目</p>
</blockquote>
<p><strong>路径</strong>是依次遍历顶点序列之间的边所形成的轨迹. 如果存在一条<code>u</code>到<code>u&lt;sup&gt;'&lt;/sup&gt;</code>的路径, 则称<code>u</code>到<code>u&lt;sup&gt;'&lt;/sup&gt;</code>是可达的. 没有重复顶点的路径称为<strong>简单路径</strong></p>
<p>如果从某顶点出发, 最后能够返回该顶点, 则称该路径为<strong>环</strong></p>
<p>如果图中的每个顶点都能通过某条路径到达其他顶点, 对于无向图则称为<strong>连通</strong>, 对有向图称为<strong>强连通</strong>. 如果只有图中部分是连通的, 无向图中称为<strong>连通分支</strong>, 有向图中称为<strong>强连通分支</strong>. 如果移除某个结点, 使得图或分支推动连通性, 则称该顶点为<strong>关结点</strong>. 如果移除某条边使得图失去连通性, 则称该边为<strong>桥</strong></p>
<p>计算机中通常使用<strong>邻接链表</strong>(adjacency-list representation)来表示图. 邻接表按照链表的方式组织, 链表中的每个结构都包含两个成员: 一个顶点和与该顶点邻接的顶点所组成的一个邻接表</p>
<p>有向图中, 邻接表的顶点总数同总的边数相等; 无向图中, 邻接表的顶点总数是边的两倍</p>
<p><img alt="邻接表" src="../images/邻接表.png" /></p>
<ul>
<li><strong>搜索方法</strong></li>
</ul>
<h4 id="breadth-first-search">广度优先算法(breadth-first search)</h4>
<p>在进一步探索图中的顶点之前先访问当前顶点的所有邻接结点.</p>
<blockquote>
<ol>
<li>开始前, 首先选择一个起始顶点并将其涂成灰色, 而其他顶点为白色. 然后把起始点单独置于一个队列中.  </li>
<li>对于队列中的每个顶点(初始状态下只有起始顶点), 依次找出和队列首部顶点相邻接的顶点, 将其涂成灰色然后加入到队列末尾.  </li>
<li>将队列首部顶点涂黑表示已经访问过, 然后出队; 继续访问下一个首部顶点, 回到第 3 步继续查找相邻接的顶点; 如果相邻接的顶点是白色, 表示还没有发现它, 将其涂成灰色, 并把它入队到末尾.  </li>
<li>直到队列中没有任何顶点时, 完成搜索</li>
</ol>
</blockquote>
<p><img alt="图广度优先算法" src="../images/图广度优先算法.png" /></p>
<h4 id="depth-first-search">深度优先算法(depth-first search)</h4>
<p>在访问某个顶点后, 递归地访问此顶点的所有未访问过的相邻顶点, 尽可能深的持续探索直到无法继续为止</p>
<blockquote>
<ol>
<li>选择一个起始点并涂成灰色加入到栈中, 其他顶点涂为白色.  </li>
<li>查找该顶点所有的邻接顶点, 如果是白色表示尚未发现该顶点, 则把该顶点涂成灰色并加入到栈中.  </li>
<li>最后加入也即是栈顶的顶点, 以该顶点为起始点重复第 2 步; 这样依次循环递归第 2 和 3 步骤, 直到栈顶邻接的顶点全涂成灰色, 或是没有邻接的顶点</li>
<li>当栈顶顶点没有邻接时或是邻接全是灰色时, 将栈顶涂成黑色, 表示已经访问过该顶点, 然后将其出栈.  </li>
<li>对栈顶重复第 2, 3, 4 步骤, 直到所有的顶点都出栈.  </li>
<li>当栈中所有顶点都出栈后, 如果图中还有白色顶点, 则选择其中的任意一个作为起始点, 从第 2 步骤开始, 直至图中所有的顶点都被涂成黑色</li>
</ol>
</blockquote>
<p><img alt="图广度优先算法" src="../images/图广度优先算法.png" /></p>
<p>图抽象数据类型头文件</p>
<div class="codehilite"><pre><span></span><span class="cm">/* graph.h */</span>
<span class="cp">#ifndef GRAPH_H</span>
<span class="cp">#define GRAPH_H</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;list.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;set.h&quot;</span><span class="cp"></span>

<span class="cm">/* 邻接链表顶点结构 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">AdjList_</span> <span class="p">{</span>
    <span class="cm">/* 顶点数据 */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">vertex</span><span class="p">;</span>
    <span class="cm">/* 邻接顶点集合 */</span>
    <span class="n">Set</span> <span class="n">adjacent</span><span class="p">;</span>
<span class="p">}</span><span class="n">AdjList</span><span class="p">;</span>

<span class="cm">/* 图结构 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Graph_</span> <span class="p">{</span>
    <span class="cm">/* 图中顶点数量 */</span>
    <span class="kt">int</span> <span class="n">vcount</span><span class="p">;</span>
    <span class="cm">/* 图中边的数量 */</span>
    <span class="kt">int</span> <span class="n">ecount</span><span class="p">;</span>

    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>
    <span class="cm">/* 链表 */</span>
    <span class="n">List</span> <span class="n">adjlists</span><span class="p">;</span>
<span class="p">}</span><span class="n">Graph</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="n">VertexColor_</span> <span class="p">{</span><span class="n">white</span><span class="p">,</span> <span class="n">gray</span><span class="p">,</span> <span class="n">black</span><span class="p">}</span> <span class="n">VertexColor</span><span class="p">;</span>
<span class="cm">/* 初始化 */</span>
<span class="kt">void</span> <span class="nf">graph_init</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">),</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">));</span>
<span class="cm">/* 销毁 */</span>
<span class="kt">void</span> <span class="nf">graph_destroy</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">);</span>
<span class="cm">/* 插入顶点 */</span>
<span class="kt">int</span> <span class="nf">graph_ins_vertex</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="o">:</span>
<span class="cm">/* 在 data1 和 data2 中建立邻接关系 */</span>
<span class="kt">int</span> <span class="n">graph_ins_edge</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data2</span><span class="p">);</span>
<span class="cm">/* 删除顶点 */</span>
<span class="kt">int</span> <span class="nf">graph_rem_vertex</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* 删除边 */</span>
<span class="kt">int</span> <span class="nf">graph_rem_edge</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">);</span>
<span class="cm">/* 取得顶点的邻接表 */</span>
<span class="kt">int</span> <span class="nf">graph_adjlist</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">AdjList</span> <span class="o">**</span><span class="n">adjlist</span><span class="p">);</span>
<span class="cm">/* 判断 data2 是否是 data1 的邻接点 */</span>
<span class="kt">int</span> <span class="nf">graph_is_adjacent</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data2</span><span class="p">);</span>

<span class="cp">#define graph_adjlists(graph) ((graph)-&gt;adjlists)</span>
<span class="cp">#define graph_vcount(graph) ((graph)-&gt;vcount)</span>
<span class="cp">#define graph_ecount(graph) ((graph)-&gt;ecount)</span>

<span class="cp">#endif</span>
</pre></div>


<p>图的实现</p>
<div class="codehilite"><pre><span></span><span class="cm">/* graph.c */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graph.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;list.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;set.h&quot;</span><span class="cp"></span>

<span class="cm">/* 初始化 */</span>
<span class="kt">void</span> <span class="nf">graph_init</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">),</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">graph</span><span class="o">-&gt;</span><span class="n">vcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">graph</span><span class="o">-&gt;</span><span class="n">ecount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">graph</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">;</span>
    <span class="n">graph</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">=</span> <span class="n">match</span><span class="p">;</span>
    <span class="cm">/* 初始化图链表 */</span>
    <span class="n">list_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* 销毁 */</span>
<span class="kt">void</span> <span class="nf">graph_destroy</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">AdjList</span> <span class="o">*</span><span class="n">adjlist</span><span class="p">;</span>

    <span class="cm">/* 删除每一个顶点 */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">list_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 删除链表结点 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list_rem_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">adjlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* 释放顶点的邻接顶点 */</span>
            <span class="n">set_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">adjacent</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">destroy</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">graph</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">free</span><span class="p">(</span><span class="n">adjlist</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* 删除链表 */</span>
    <span class="n">list_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Graph</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">graph_ins_vertex</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">;</span>
    <span class="n">AdjList</span> <span class="o">*</span><span class="n">adjlist</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

    <span class="cm">/* 确认没有重复数据存在图中链表里 */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">);</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertext</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* 顶点内存 */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">adjlist</span> <span class="o">=</span> <span class="p">(</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">AdjList</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">vertex</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
    <span class="cm">/* 初始化新顶点邻接点 */</span>
    <span class="n">set_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">adjacent</span><span class="p">,</span> <span class="n">graph</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="cm">/* 将新顶点插入到链表尾部 */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">list_ins_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">,</span> <span class="n">list_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">),</span>
        <span class="n">adjlist</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* 增加顶点数量 */</span>
    <span class="n">graph</span><span class="o">-&gt;</span><span class="n">vcount</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">graph_ins_edge</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

    <span class="cm">/* 查找是否存在顶点数据 data2 */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">);</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> 
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">data2</span><span class="p">,</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* 顶点不存在 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 查找是否存在顶点数据 data1 */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">);</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> 
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* 顶点不存在 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* 插入边关系集合 </span>
<span class="cm">     * 邻接点集合里结点数据指向实际的数据, 而不是顶点结构</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">set_insert</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">adjacent</span><span class="p">,</span> <span class="n">data2</span><span class="p">)))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">graph</span><span class="o">-&gt;</span><span class="n">ecount</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* 删除顶点 */</span>
<span class="kt">int</span> <span class="nf">graph_rem_vertex</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">AdjList</span> <span class="o">*</span><span class="n">adjlist</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/*遍历链表中所有顶点, 找到匹配的顶点和邻接点 */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">);</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* 当该顶点是其他顶点的邻接点时, 不允许删除 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">set_is_memember</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">adjacent</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/* 找到匹配的顶点位置 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
            <span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* 未找到符合顶点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* 不能删除有还有邻接点的顶点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">set_size</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">adjacent</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* 删除顶点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">list_rem_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">adjlist</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">adjlist</span><span class="p">);</span>

    <span class="n">graph</span><span class="o">-&gt;</span><span class="n">vcount</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">graph_rem_edge</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data1</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">;</span>
    <span class="cm">/* 查找第一个顶点 */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">);</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* 将顶点的邻接边删除 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">set_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">adjacent</span><span class="p">,</span> <span class="n">data2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">graph</span><span class="o">-&gt;</span><span class="n">ecount</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* 取得顶点 */</span>
<span class="kt">int</span> <span class="nf">graph_adjlist</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">AdjList</span> <span class="o">**</span><span class="n">adjlist</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="cm">/* locate the adjacency list for the vertex */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">);</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* return if the vertex was not found */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* pass back the adjacency list for the vertex */</span>
    <span class="o">*</span><span class="n">adjlist</span> <span class="o">=</span> <span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* 判断邻接关系 */</span>
<span class="kt">int</span> <span class="nf">graph_is_adjacent</span><span class="p">(</span><span class="k">const</span> <span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data2</span><span class="p">)</span>
<span class="p">{</span>   
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">);</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">element</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">set_is_memember</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">adjacent</span><span class="p">,</span> <span class="n">data2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>图的应用: 计算网络跳数(Counting Network Hops)</p>
<p><img alt="网络跳数" src="https://ivicel.github.io/images/网络跳数.png" /></p>
<p>使用广度优先算法, 对于某个顶点的的邻接点, 其邻接点的跳数都等于该顶点跳数加上 1</p>
<div class="codehilite"><pre><span></span><span class="cm">/* bfs.c */</span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graph.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;list.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;queue.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;set.h&quot;</span><span class="cp"></span>


<span class="cm">/* define a struct for vertices in a breadth-first search */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">BfsVertext_</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="cm">/* 顶点颜色 */</span>
    <span class="n">VertexColor</span> <span class="n">color</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">hops</span><span class="p">;</span>
<span class="p">}</span><span class="n">BfsVertex</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="n">BfsVertex</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="n">List</span> <span class="o">*</span><span class="n">hops</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Queue</span> <span class="n">queue</span><span class="p">;</span>
    <span class="n">AdjList</span> <span class="o">*</span><span class="n">adjlist</span><span class="p">,</span> <span class="o">*</span><span class="n">clr_adjlist</span><span class="p">;</span>
    <span class="n">BfsVertex</span> <span class="o">*</span><span class="n">clr_vertex</span><span class="p">,</span> <span class="o">*</span><span class="n">adj_vertex</span><span class="p">;</span>
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">,</span> <span class="o">*</span><span class="n">member</span><span class="p">;</span>

    <span class="cm">/* 初始化顶点颜色 */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph_adjlists</span><span class="p">(</span><span class="n">graph</span><span class="p">));</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">clr_vertex</span> <span class="o">=</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">(</span><span class="n">clr_vertex</span><span class="p">,</span> <span class="n">start</span><span class="p">))</span> <span class="p">{</span>
            <span class="cm">/* 确定起点 */</span>
            <span class="n">clr_vertex</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">gray</span><span class="p">;</span>
            <span class="n">clr_vertex</span><span class="o">-&gt;</span><span class="n">hops</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">clr_vertex</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">white</span><span class="p">;</span>
            <span class="n">clr_vertex</span><span class="o">-&gt;</span><span class="n">hops</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* 取得起始顶点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">graph_adjlist</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clr_adjlist</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 将起始点加入队列中 */</span>
    <span class="n">queue_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">queue_enqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="n">clr_adjlist</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">queue_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* 循环队列, 广度优先 */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">queue_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">adjlist</span> <span class="o">=</span> <span class="n">queue_peek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
        <span class="cm">/* 循环邻接点 */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">member</span> <span class="o">=</span> <span class="n">set_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">adjacent</span><span class="p">);</span> <span class="n">member</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="n">member</span> <span class="o">=</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* 注意集合结点存储的数据指向并不是一个顶点, 而是顶点指向的实际数据 */</span>
            <span class="n">adj_vertex</span> <span class="o">=</span> <span class="n">set_data</span><span class="p">(</span><span class="n">member</span><span class="p">);</span>
            <span class="cm">/* 确认顶点存在于图中 */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">graph_adjlist</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">adj_vertex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clr_adjlist</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">queue_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">clr_vertex</span> <span class="o">=</span> <span class="n">clr_adjlist</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">clr_vertex</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">white</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* 如果顶点还没有添加到队列中, 将其涂成灰色并加入到队列里 */</span>
                <span class="n">clr_vertex</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">gray</span><span class="p">;</span>
                <span class="cm">/*  队列首部顶点到达这个顶点所需跳数 + 1, 也即是起始点到该点的跳数 */</span>
                <span class="n">clr_vertex</span><span class="o">-&gt;</span><span class="n">hops</span> <span class="o">=</span> <span class="p">((</span><span class="n">BfsVertex</span> <span class="o">*</span><span class="p">)</span><span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hops</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">queue_enqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="n">clr_adjlist</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">queue_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* 队首部出队, 涂成黑色 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">queue_dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">adjlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">((</span><span class="n">BfsVertex</span> <span class="o">*</span><span class="p">)</span><span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">black</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">queue_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* 完成循环成销毁队列 */</span>
    <span class="n">queue_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">);</span>
    <span class="cm">/* 初始一个队列 hops */</span>
    <span class="n">list_init</span><span class="p">(</span><span class="n">hops</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph_adjlist</span><span class="p">(</span><span class="n">graph</span><span class="p">));</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">clr_vertex</span> <span class="o">=</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">;</span>
        <span class="cm">/* 对于 hops 值为即为到达该顶点所需最少跳数, -1 是不可到达的顶点 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">clr_vertex</span><span class="o">-&gt;</span><span class="n">hops</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">list_ins_next</span><span class="p">(</span><span class="n">hops</span><span class="p">,</span> <span class="n">list_tail</span><span class="p">(</span><span class="n">hops</span><span class="p">),</span> <span class="n">clr_vertex</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">list_destroy</span><span class="p">(</span><span class="n">hops</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>图的应用: 拓扑排序(Topological Sorting)</p>
<div class="codehilite"><pre><span></span><span class="cm">/* dfs.c */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graph&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;list.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;set.h&quot;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">DfsVertex_</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="n">VertexColor</span> <span class="n">color</span><span class="p">;</span>
<span class="p">}</span><span class="n">DfsVertex</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dfs_main</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="n">AdjList</span> <span class="o">*</span><span class="n">adjlist</span><span class="p">,</span> <span class="n">List</span> <span class="o">*</span><span class="n">ordered</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">AdjList</span> <span class="o">*</span><span class="n">clr_adjlist</span><span class="p">;</span>
    <span class="n">DfsVertex</span> <span class="o">*</span><span class="n">clr_vertex</span><span class="p">,</span> <span class="o">*</span><span class="n">adj_vertex</span><span class="p">;</span>
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">member</span><span class="p">;</span>
    <span class="cm">/* change the color of vertex to gray */</span>
    <span class="p">((</span><span class="n">DfsVertex</span> <span class="o">*</span><span class="p">)</span><span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">gray</span><span class="p">;</span>
    <span class="cm">/* search its adjacency set */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">member</span> <span class="o">=</span> <span class="n">set_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">adjacent</span><span class="p">);</span> <span class="n">member</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">member</span> <span class="o">=</span> <span class="n">member</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* determine the color of the next adjacent vertex */</span>
        <span class="n">adj_vertex</span> <span class="o">=</span> <span class="n">set_data</span><span class="p">(</span><span class="n">member</span><span class="p">);</span>
        <span class="cm">/* 取得该顶点 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">graph_adjlist</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">adj_vertex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clr_adjlist</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">clr_vertex</span> <span class="o">=</span> <span class="n">clr_adjlist</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">;</span>
        <span class="cm">/* move one vertex deeper when the next adjacent vertex is white */</span>
        <span class="cm">/* 如果顶点是白色, 表明还没被访问过, 如果有邻接点, 继续向下层访问 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">clr_vertex</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">white</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dfs_main</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">clr_adjlist</span><span class="p">,</span> <span class="n">ordered</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* color the current vertex black and make it first in the list */</span>
    <span class="p">((</span><span class="n">DfsVertex</span> <span class="o">*</span><span class="p">)</span><span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">black</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">list_ins_next</span><span class="p">(</span><span class="n">ordered</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="n">DfsVertex</span> <span class="o">*</span><span class="p">)</span><span class="n">adjlist</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">Graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">,</span> <span class="n">List</span> <span class="o">*</span><span class="n">ordered</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DfsVertex</span> <span class="o">*</span><span class="n">vertex</span><span class="p">;</span>
    <span class="n">ListElmt</span> <span class="o">*</span><span class="n">element</span><span class="p">;</span>

    <span class="cm">/* initial all of the vertices in the graph */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">);</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">vertex</span> <span class="o">=</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">;</span>
        <span class="n">vertex</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">white</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* initialize list */</span>
    <span class="n">list_init</span><span class="p">(</span><span class="n">ordered</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="cm">/* perform depth-first search */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="o">-&gt;</span><span class="n">adjlists</span><span class="p">);</span> <span class="n">element</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">list_next</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* ensure that every component of unconnected graphs is searched */</span>
        <span class="n">vertex</span> <span class="o">=</span> <span class="p">((</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vertex</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">white</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* 确保所有顶点遍历到, 发生错误就退出 */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dfs_main</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="p">(</span><span class="n">AdjList</span> <span class="o">*</span><span class="p">)</span><span class="n">list_data</span><span class="p">(</span><span class="n">element</span><span class="p">),</span> <span class="n">ordered</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">list_destroy</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="./tag/suan-fa.html">算法</a>
      <a href="./tag/c.html">C</a>
      <a href="./tag/tu.html">图</a>
      <a href="./tag/shu-ju-jie-gou.html">数据结构</a>
    </p>
  </div>





</article>

    <footer>
<p>
  &copy;  2018 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Powered by <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
           src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>




<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Ivicel's Ambertime ",
  "url" : ".",
  "image": "/images/favicon.ico",
  "description": "ivicel's thoughts and writings"
}
</script>

</body>
</html>