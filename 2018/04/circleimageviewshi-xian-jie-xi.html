<!DOCTYPE html>
<html lang="en">
    <head>
            <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="google-site-verification" content="WpfeDx8HRNQcT7jzjSsZ0vhtfw8M7gFo-YoDmXZRGHg"/>
        <meta name="google-site-verification" content="H97dWyn-QYy4n8BEw7ZAX8bFDDin_BwYiEOb3v_4dEs" />
        <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
        
  
        <title>
Ambertime        </title>

        <!-- Web App Manifest -->
        <link rel="manifest" href="https://ivicel.info/assets/pwa/manifest.json" />

        <!-- Favicon -->
        <link rel="shortcut icon" href="https://ivicel.info/assets/images/favicon.ico"/>
        <!-- Canonical URL -->
        <link rel="canonical" href="" />
        <link rel="stylesheet" href="https://ivicel.info/theme/css/bootstrap.min.css" />

        <!-- Custom CSS -->
        <link rel="stylesheet" href="https://ivicel.info/theme/css/hux-blog.min.css" />
        <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="https://ivicel.info/theme/css/prism.css" />
        <link rel="stylesheet" href="https://ivicel.info/theme/css/ivicel.css" />

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->
        


    <style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('https://ivicel.info/assets/images/header.jpg');
    }

    header.intro-header .header-mask{
        width: 100%;
        height: 100%;
        position: absolute;
        background: rgba(0,0,0, 0.3);
    }
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>
    </head>


    <!-- hack iOS CSS :active style -->
    <body ontouchstart="">
<!-- Navigation -->
<!-- <nav class="navbar navbar-default navbar-custom navbar-fixed-top invert"> -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ivicel.info/">Ambertime</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="https://ivicel.info/">Home</a>
                    </li>
                        <li>
                            <a href="https://ivicel.info/archives.html">ARCHIVES</a>
                        </li>
                        <li>
                            <a href="https://ivicel.info/about.html">ABOUT</a>
                        </li>
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script> 
        
<!-- Post Header -->

<header class="intro-header" >
    <div class="header-mask"></div>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        <a class="tag" href="#" title="CircleImageView">CircleImageView</a>
                        <a class="tag" href="#" title="源码解析">源码解析</a>
                        <a class="tag" href="#" title="实现">实现</a>
                    </div>
                    <h1>CircleImageView实现解析</h1>
                    <span class="meta">Posted by ivicel on 2018-04-28</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<div class="container">
    <article>
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container">
                <h3>1. CircleImageView 的实现</h3>
<h4>1.1 自定义的属性</h4>
<p>CircleImageView 一共自定义的 5 个自定义属性</p>
<ol>
<li><code>civ_border_width</code> 边框的大小</li>
<li><code>civ_border_color</code> 边框的颜色</li>
<li><code>civ_border_overlay</code> 边框覆盖</li>
<li><code>civ_fill_color</code> 图片背景填充, 已弃用, 使用 <code>civ_circle_background_color</code> 替代</li>
</ol>
<h4>1.2 流程</h4>
<p>CircleImageView 是继承自系统控件 <code>android.widget.ImageView</code>, 而不是 support 里的兼容控件 <code>android.support.v7.widget.AppCompatImageView</code>, 作者的理由是为了使用控件更加简洁, 这样不必在包内依赖 android support v7 包, 减小包的大小. 如果有版本兼容问题的话, 我们可以自己按需求改成继承自 v7 包.</p>
<blockquote>
<p>CircleImageView 里有两个重要的标志位 <code>mReady</code>, <code>mSetupPending</code>. 用来控制解析自定义属性, 和图片来源以及 view 大小的测量. 为什么要使用两个标志位并相互依赖? 这是由于 ImageView 可能通过 xml 和 java 两种方法来设置图片来源, 这两种方法调用的时机也是不同. 另外我们需要确保先要解析我们自定义的值才好计算出边框大小, 颜色等, 还有 view 的大小要到 onMeasure 时才能确定, 所以圆半径大小的要到那时才能确定</p>
</blockquote>
<p>我们都知道, xml 的 inflate 使用的是控件里的第二个构造方法, 即 <code>public CircleImageView(Context context, AttributeSet attrs)</code>, 然后这里调用了 <code>public CircleImageView(Context context, AttributeSet attrs, int defStyle)</code>.</p>
<p>在第三个构造调用了父类 <code>ImageView</code> 里对应的构造方法, 这里要注意的是, 父类里会解析我们所写的 xml 文件, 然后如果我们写了图片文件来源 <code>android:src</code>, 这里就会调用了 <code>ImageView#setDrawable</code> 来设置图片文件来源.</p>
<p>然后我们看到 CircleImageView 源码里面设置图片的 setXXX 方法都已经被重写了, 都只增加了一行 <code>initializeBitmap()</code> 来初始化图片 mBitmap 来源.</p>
<pre class="highlight line-numbers"><code class="language-java linenums">private void initializeBitmap() {
    // 通过这个标志可以设定我们是否需要把图片变形为圆形或者不改变
    // 如果设定了 onDraw 那就按 ImageView 来绘画
    if (mDisableCircularTransformation) {
        mBitmap = null;
    } else {
        // 获取图片
        mBitmap = getBitmapFromDrawable(getDrawable());
    }
    setup();
}

private void setup() {
    // 第一次 mReady 初始为 false, 所以总是直接返回, 回到构造方法里解析自定义属性
    if (!mReady) {
        mSetupPending = true;
        return;
    }
    // 这一步判断也是很重要的, 因为图片的设置可能是在 xml 也可能是在 java 中 setXXX 方法
    // 所以当完成调用构造方法后, 再次调用 setup 时并没有测量好 view 的大小, 这里就会直接返回
    if (getWidth() == 0 &amp;&amp; getHeight() == 0) {
        return;
    }

    /* .... */
}</code></pre>

<p>来看两种情况:</p>
<ol>
<li>通过 xml 设置图片来源. </li>
</ol>
<p><code>setImageDrawable()</code> -&gt; <code>initializeBitmap()</code> -&gt; <code>setup()</code>, 遇到 <code>mReady == false</code> 返回 -&gt; 构造方法里解析自定义属性, 然后 <code>init()</code> -&gt; 这时 <code>mSetupPending == true</code>, 再次调用 <code>setup()</code>, 但此时 view 的大小还没测量好, <code>getWidth() == 0</code>, <code>getHeight() == 0</code> 直接返回. </p>
<p>当 view 测量完成后调用 <code>onSizeChanged()</code> -&gt; 再次 <code>setup</code>, 这时一切就绪可以测量圆的半径大小, 位置等种种</p>
<ol>
<li>通过 java 代码来设置图片来源.</li>
</ol>
<p>重写 <code>setImageXXXX()</code> 方法, 里面都调用了 <code>initializeBitmap()</code>. 然后跟上面的一样, 只不过这时候 <code>mReady</code> 已经是 <code>true</code>, 因为在 <code>init()</code> 里已经设置了, 并且此时我们已经完成了对 view 的测量, 这样在 <code>setup()</code> 里就直接测量圆的半径等等所需的值</p>
<pre class="highlight line-numbers"><code class="language-java linenums">private void init() {
    super.setScaleType(SCALE_TYPE);
    mReady = true;

    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {
        setOutlineProvider(new OutlineProvider());
    }
    // 如果已经在 xml 设置了图片, 就会直接设置图片的大小等
    if (mSetupPending) {
        setup();
        mSetupPending = false;
    }
}</code></pre>

<p>来看如何获得 bitmap.</p>
<pre class="highlight line-numbers"><code class="language-java linenums">private Bitmap getBitmapFromDrawable(Drawable drawable) {
    if (drawable == null) {
        return null;
    }
    // 如果是 BitmapDrawable 对象, 直接使用 BitmapDrawable#getBitmap() 获得
    if (drawable instanceof BitmapDrawable) {
        return ((BitmapDrawable) drawable).getBitmap();
    }

    try {
        Bitmap bitmap;
        // 如果是 ColorDrawable 对象, 因为填充颜色没有所谓的大小, 是根据要填充的 view 来确定大小的. 
        // 所以给一个初始的大小来生成 bitmap, 到时把这个 bitmap 拉伸便可
        if (drawable instanceof ColorDrawable) {
            bitmap = Bitmap.createBitmap(COLORDRAWABLE_DIMENSION, COLORDRAWABLE_DIMENSION, BITMAP_CONFIG);
        } else {
            // 其余情况下由传入的 drawable 大小来确定生成新的 bitmap
            bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), BITMAP_CONFIG);
        }
        Canvas canvas = new Canvas(bitmap);
        drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());
        drawable.draw(canvas);
        return bitmap;
    } catch (Exception e) {
        e.printStackTrace();
        return null;
    }
}</code></pre>

<p>回过来看最重要的 setup 方法</p>
<pre class="highlight line-numbers"><code class="language-java linenums">private void setup() {
    if (!mReady) {
        mSetupPending = true;
        return;
    }

    if (getWidth() == 0 &amp;&amp; getHeight() == 0) {
        return;
    }
    // 设置为不要变形为圆形时的情况, 会执行这个
    if (mBitmap == null) {
        invalidate();
        return;
    }
    // 设置着色器
    mBitmapShader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP,
            Shader.TileMode.CLAMP);
    // 图片画笔, 反锯齿, 着色器
    mBitmapPaint.setAntiAlias(true);
    mBitmapPaint.setShader(mBitmapShader);
    // 边框画笔样式
    mBorderPaint.setStyle(Paint.Style.STROKE);
    mBorderPaint.setAntiAlias(true);
    mBorderPaint.setColor(mBorderColor);
    mBorderPaint.setStrokeWidth(mBorderWidth);
    // 背景画笔样式
    mCircleBackgroundPaint.setStyle(Paint.Style.FILL);
    mCircleBackgroundPaint.setAntiAlias(true);
    mCircleBackgroundPaint.setColor(mCircleBackgroundColor);
    // 图片宽高
    mBitmapHeight = mBitmap.getHeight();
    mBitmapWidth = mBitmap.getWidth();
    // 计算圆形的外切矩形大小
    mBorderRect.set(calculateBounds());
    // 计算边框的半径, 我们在 xml 中设置的是边框大小 * 2, 这里要除以 2
    // 因为在画圆时, Paint#setStrokeWidth 的参数就是圆边框线的两倍
    mBorderRadius = Math.min((mBorderRect.height() - mBorderWidth) / 2.0f,
            (mBorderRect.width() - mBorderWidth) / 2.0f);
    mDrawableRect.set(mBorderRect);
    // overlay 为 true 时, 向内缩小 1px
    if (!mBorderOverlay &amp;&amp; mBorderWidth &gt; 0) {
        mDrawableRect.inset(mBorderWidth - 1.0f, mBorderWidth - 1.0f);
    }
    // 图形圆的半径大小, 可以看到取这个大小时, 边框是画在图像上的
    mDrawableRadius = Math.min(mDrawableRect.height() / 2.0f, mDrawableRect.width() / 2.0f);
    // 过滤颜色, 只在 java 代码中设置调用
    applyColorFilter();
    updateShaderMatrix();
    invalidate();
}

 private RectF calculateBounds() {
    // 注意先要减去上下左右的 padding 才是 view 真正的内容区大小
    int availableWidth  = getWidth() - getPaddingLeft() - getPaddingRight();
    int availableHeight = getHeight() - getPaddingTop() - getPaddingBottom();
    // 取长宽里的最小值来作一个内切圆, 该值就是边框圆的直径
    int sideLength = Math.min(availableWidth, availableHeight);
    // 以左, 上的 padding 为准来定位圆
    // 如果长, 高很大, 那么 paddingRight, paddingBottom 可能不会产生什么影响 
    float left = getPaddingLeft() + (availableWidth - sideLength) / 2f;
    float top = getPaddingTop() + (availableHeight - sideLength) / 2f;
    // 将在这个矩形内作一个内切圆
    return new RectF(left, top, left + sideLength, top + sideLength);
}

private void updateShaderMatrix() {
    float scale;
    float dx = 0;
    float dy = 0;
    mShaderMatrix.set(null);
    // 我们已经计算好一个矩形, 我们需要知道图片比预定矩形大还是小, 以便作缩放
    // 下面是 mDrawableRect.height() / mBitmapHeight &gt; 
    // mDrawableRect.width() / mBitmapWidth 的变形
    // 因为图片有放大或缩小, 缩放中心为原点, 所以图片要进行移动
    if (mBitmapWidth * mDrawableRect.height() &gt; 
            mDrawableRect.width() * mBitmapHeight) {
        // 按高进行缩放时, 要在 x 轴平移
        scale = mDrawableRect.height() / (float) mBitmapHeight;
        dx = (mDrawableRect.width() - mBitmapWidth * scale) * 0.5f;
    } else {
        // 按宽进行缩放时, 要在 y 轴平移
        scale = mDrawableRect.width() / (float) mBitmapWidth;
        dy = (mDrawableRect.height() - mBitmapHeight * scale) * 0.5f;
    }

    mShaderMatrix.setScale(scale, scale);
    mShaderMatrix.postTranslate((int) (dx + 0.5f) + mDrawableRect.left, (int) (dy + 0.5f) + mDrawableRect.top);

    mBitmapShader.setLocalMatrix(mShaderMatrix);
}

protected void onDraw(Canvas canvas) {
    // 禁用变形
    if (mDisableCircularTransformation) {
        super.onDraw(canvas);
        return;
    }
    // 没有获得图片源
    if (mBitmap == null) {
        return;
    }
    // 有背景颜色
    if (mCircleBackgroundColor != Color.TRANSPARENT) {
        canvas.drawCircle(mDrawableRect.centerX(), mDrawableRect.centerY(), mDrawableRadius, mCircleBackgroundPaint);
    }
    // 画图片
    canvas.drawCircle(mDrawableRect.centerX(), mDrawableRect.centerY(),
            mDrawableRadius, mBitmapPaint);
    // 画边框
    if (mBorderWidth &gt; 0) {
        canvas.drawCircle(mBorderRect.centerX(), mBorderRect.centerY(), 
                mBorderRadius, mBorderPaint);
    }
}</code></pre>

<h3>Reference</h3>
<ol>
<li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0806/3268.html">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0806/3268.html</a></li>
<li><a href="https://juejin.im/entry/593108c4a22b9d0058c08a2c">https://juejin.im/entry/593108c4a22b9d0058c08a2c</a></li>
<li><a href="https://github.com/hdodenhof/CircleImageView">https://github.com/hdodenhof/CircleImageView</a></li>
</ol>

                <hr style="visibility: hidden;">
                <ul class="pager">
                </ul>
                <hr style="visibility: hidden;">


                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
            </div>  
            <div class="col-lg-2 col-lg-offset-0 visible-lg-block sidebar-container catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        </div>
    </article>
</div>

 
        
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->

                <p class="copyright text-muted">
                    Copyright &copy; Ambertime 2019                    <br>
                    Powered by <a href="http://getpelican.com/">Pelican</a> | Theme by <a href="http://huangxuan.me">HuxPro</a>
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=ivicel&repo=ivicel.github.io&type=star&count=true" >
                    </iframe>
                    
                </p>
            </div>
        </div>
    </div>
</footer> 
        
        <script src="https://ivicel.info/theme/js/jquery.min.js"></script>
        <script src="https://ivicel.info/theme/js/bootstrap.min.js"></script>
        <script src="https://ivicel.info/theme/js/animatescroll.min.js"></script>
        <script src="https://ivicel.info/theme/js/prism.js"></script>
        <script src="https://ivicel.info/theme/js/hux-blog.min.js"></script>
        <script src="https://ivicel.info/theme/js/snackbar.js"></script>
        <!--fastClick.js -->
        <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
                TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                }
                },
                tex2jax: {
                inlineMath: [ ['$','$'] ],
                displayMath: [ ['$$','$$'] ],
                processEscapes: true,
                }
            });
            </script>
        <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <!-- Google Analytics -->
        <script>
            var _gaId = "UA-113622715-2";
            var _gaDomain = "https://ivicel.info";

            // Originial
            (function(i, s, o, g, r, a, m) {
                i["GoogleAnalyticsObject"] = r;
                (i[r] =
                    i[r] ||
                    function() {
                        (i[r].q = i[r].q || []).push(arguments);
                    }),
                    (i[r].l = 1 * new Date());
                (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
                a.async = 1;
                a.src = g;
                m.parentNode.insertBefore(a, m);
            })(
                window,
                document,
                "script",
                "//www.google-analytics.com/analytics.js",
                "ga"
            );

            ga("create", _gaId, _gaDomain);
            ga("send", "pageview");
        </script>

        <!-- Side Catalog -->

<script type="text/javascript">
    

</script>


<script src="//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js"></script>
<script src="https://ivicel.info/theme/js/jquery.nav.js"></script>

<script type="text/javascript">
    anchors.options = {
        visible: 'always',
        placement: 'right',
        icon: '#'
    };
    anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }));
    
    var disqus_config = function () {
        this.page.url = 'https://ivicel.info/2018/04/circleimageviewshi-xian-jie-xi.html';
        this.page.identifier = 'CircleImageView实现解析';
        this.page.title = 'CircleImageView实现解析';
    };

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//ambertime.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    </body>
</html>