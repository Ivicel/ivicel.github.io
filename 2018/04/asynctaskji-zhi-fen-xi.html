<!DOCTYPE html>
<html lang="en">
    <head>
            <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="google-site-verification" content="WpfeDx8HRNQcT7jzjSsZ0vhtfw8M7gFo-YoDmXZRGHg"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  
        <title>
Ambertime        </title>

        <!-- Web App Manifest -->
        <link rel="manifest" href="/assets/pwa/manifest.json" />

        <!-- Favicon -->
        <link rel="shortcut icon" href="/assets/images/favicon.ico"/>
        <!-- Canonical URL -->
        <link rel="canonical" href="" />
        <link rel="stylesheet" href="/theme/css/bootstrap.min.css" />

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/theme/css/hux-blog.min.css" />
        <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="/theme/css/prism.css" />
        <link rel="stylesheet" href="/theme/css/ivicel.css" />

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->
        


    <style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/assets/images/header.jpg');
    }

    header.intro-header .header-mask{
        width: 100%;
        height: 100%;
        position: absolute;
        background: rgba(0,0,0, 0.3);
    }
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>
    </head>


    <!-- hack iOS CSS :active style -->
    <body ontouchstart="">
<!-- Navigation -->
<!-- <nav class="navbar navbar-default navbar-custom navbar-fixed-top invert"> -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Ambertime</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                        <li>
                            <a href="/archives">ARCHIVES</a>
                        </li>
                        <li>
                            <a href="/about">ABOUT</a>
                        </li>
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script> 
        
<!-- Post Header -->

<header class="intro-header" >
    <div class="header-mask"></div>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        <a class="tag" href="#" title="线程">线程</a>
                        <a class="tag" href="#" title="线程池">线程池</a>
                        <a class="tag" href="#" title="AsyncTask">AsyncTask</a>
                    </div>
                    <h1>AsyncTask机制分析</h1>
                    <span class="meta">Posted by ivicel on 2018-04-10</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<div class="container">
    <article>
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container">
                <h3>1. AsyncTask 的使用</h3>
<p>AsyncTask 为抽象类, 继承该类至少要重写 <code>doInBackground(Params...params)</code> 方法. 除了该方法是在<strong>非主程</strong>中执行外, 其他的如 <code>onPreExecute()</code> <code>onProgressUpdate(Progress...progresses)</code> <code>onPostExecute(Result result)</code> <code>onCancel()</code> 都是在主线程中执行. </p>
<p>AsyncTask 另外可以设置三个类型参数, <code>AsyncTask&lt;Params, Progress, Result&gt;</code> . 分别指传入  <code>doInBackground(Param…params)</code>  的参数数组, <code>onProgressUpdate(Progress…progress)</code> 进度更新参数,  从 <code>doInBackground()</code> 返回结果, 可在 <code>onPostExecute(Result result)</code> 中接收到该结果.</p>
<pre class="highlight line-numbers"><code class="language-java linenums">public static DownloadTask extends AsyncTask&lt;String, Integer, Long&gt; {
    @Override
    protected Long doInBackground(String...urls) {
        int i = 0;
        for (String url : urls) {
            Log.d(TAG, "get url: " + url);
            i++;
            publishProgress(i);
        }
        return i;
    }

    @Override
    protected void onProgressUpdate(Integer...progress) {
        for (Integer p : progress) {
            Log.d(TAG, "get progress: " + p);
        }
    }

    @Override
    protected void onPostExecute(Long result) {
        Log.d(TAG, "get result: " + result);    
    }
}

DownloadTask&lt;String, Integer, Long&gt; task = new DownloadTask&lt;&gt;();
task.execute(urls);</code></pre>

<ul>
<li>在 <strong>SDK 17(JellyBean_MR1)</strong> 之后新建对象和 <code>execute()</code> 方法不必在主线程中调用了, 因为 sHandler 这个静态变量已经在内部使用 Looper.getMainLooper 来初始化了. <a href="https://android.googlesource.com/platform/frameworks/base/+/jb-mr1-release/core/java/android/os/AsyncTask.java">查看源码</a></li>
<li>不要在重写时直接调用 <code>onXXXX</code> 方法</li>
<li>一个 AsyncTask 对象只能执行一次 <code>execute/executeOnExecutor</code></li>
<li><code>AsyncTask#execute()</code> 默认是串行执行, 可以使用 <code>AsyncTask#executOnExecutor()</code> 来并行执行任务.</li>
</ul>
<h3>2. 源码分析(基于 SDK 27)</h3>
<p>当我们创建一个新的 AsyncTask 对象时, 都会走到 <code>AsyncTask(Looper callbackLooper)</code> 这个构造方法. 如果没传入 null 或者 main looper 时, 就会默认使用主线程的 looper</p>
<h4>2.1 构造方法</h4>
<pre class="highlight line-numbers"><code class="language-java linenums">public AsyncTask(Looper callbackLooper) {
    // 使用自定义 handler 或者使用默认的 handler, 默认 handler 在主线程中执行
    mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper()
            ? getMainHandler()
            : new Handler(callbackLooper);
    // 初始化执行参数和返回结果
    /* .... */
}</code></pre>

<h4>2.2 执行方法</h4>
<p><code>AsyncTask#execute</code> 其实也是调用了 <code>AsyncTask#executeOnExecutor</code>, 其传入了一个内部实现的串行 <code>Executor</code>. </p>
<pre class="highlight line-numbers"><code class="language-java linenums">// AsyncTask#executeOnExecutor
public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,
            Params... params) {
        // 判断当前状态, 运行中或已完成的将抛出错误. 这也证明了前面说的每个对象只能调用一次执行
        if (mStatus != Status.PENDING) {
            switch (mStatus) {
                case RUNNING:
                    throw new IllegalStateException("Cannot execute task:"
                            + " the task is already running.");
                case FINISHED:
                    throw new IllegalStateException("Cannot execute task:"
                            + " the task has already been executed "
                            + "(a task can be executed only once)");
            }
        }
        // 设置运行状态, 调用执行任务前的准备方法, 传入参数, 使用线程池执行任务
        mStatus = Status.RUNNING;
        onPreExecute();
        mWorker.mParams = params;
        // 这会调用 Runnable 里的 run() 方法
        exec.execute(mFuture);

        return this;
    }</code></pre>

<p>一分为二. 在调用 <code>Executor#execute(Runnable)</code> 之后, 将根据之前不同的默认的 <code>Executor</code> 来执行任务. 一个是串行, 一个是并行. </p>
<p>串行的内部实现</p>
<pre class="highlight line-numbers"><code class="language-java linenums">public static final Executor SERIAL_EXECUTOR = new SerialExecutor();
private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;

// AsyncTask#SerialExecutor
private static class SerialExecutor implements Executor {
        // 非线程安全的数组实现的双端队列
        final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();
        Runnable mActive;
        // 执行任务时, 把任务添加到队列中, 从队列里依次取出来执行
        public synchronized void execute(final Runnable r) {
            mTasks.offer(new Runnable() {
                public void run() {
                    try {
                        r.run();
                    } finally {
                        scheduleNext();
                    }
                }
            });
            if (mActive == null) {
                scheduleNext();
            }
        }

        protected synchronized void scheduleNext() {
            if ((mActive = mTasks.poll()) != null) {
                // 在这是里使用的是已经创建好的线程池来执行任务, 避免过多创建新线程
                // 减小不必要的消耗. 由于 mTask 取出来的 Runnable 执行方法里, 
                // 我们又递归的调用了 scheduleNext, 所以会按顺序执行下去
                THREAD_POOL_EXECUTOR.execute(mActive);
            }
        }
    }</code></pre>

<p>并行的内部实现. </p>
<pre class="highlight line-numbers"><code class="language-java linenums">public static final Executor THREAD_POOL_EXECUTOR;
static {
    // 核心线程 2-4, 最大线程数为 CPU 核心数 + 1, 30s 的超时时间(设置了核心线程也会超时)
    // 有界的等待队列, 最大值为 128, 创建线程的工厂方法重写了以 AsyncTask + number 的线程名
    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
            CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,
            sPoolWorkQueue, sThreadFactory);
    threadPoolExecutor.allowCoreThreadTimeOut(true);
    THREAD_POOL_EXECUTOR = threadPoolExecutor;
}</code></pre>

<p>由于 <code>Executor</code> 具体执行的是在构造方法里初始化的 <code>FutureTask#run()</code>方法, 其中我们传入了一个 <code>Runnable</code> 作为参数, 该参数的 run 方法会在这里会被调用. 回过来看构造方法里的</p>
<pre class="highlight line-numbers"><code class="language-java linenums">public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,
            Params... params) {
    /* ... */

    mWorker = new WorkerRunnable&lt;Params, Result&gt;() {
            public Result call() throws Exception {
                // 原子状态, 调用中
                mTaskInvoked.set(true);
                Result result = null;
                try {
                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                    // 调用定义的方法, 返回结果
                    result = doInBackground(mParams);
                    Binder.flushPendingCommands();
                } catch (Throwable tr) {
                    // 取消
                    mCancelled.set(true);
                    throw tr;
                } finally {
                    // 这会调用之前定义好的 handler 通 message 传送到 onPostExecute 中
                    // result 会被再包一层 AsyncTaskResult 类中, 类中包含 AsyncTask 对象和
                    // result 对象
                    // AsyncTaskResult 可以接收一个结果数组, 但默认 handler 实现只取一个结果
                    postResult(result);
                }
                return result;
            }
        };
        // FutureTask#run 执行时会调用 Callable 里的 call 方法
        // call 方法的返回值会作为 FutureTask 的调用结果, 通过 Future#get 方法获得
        mFuture = new FutureTask&lt;Result&gt;(mWorker) {
            // 在设置 Future#set 返回值后, 会调用该方法
            @Override
            protected void done() {
                try {
                    // 再次检测运行的结果是否给返回回调
                    postResultIfNotInvoked(get());
                } catch (InterruptedException e) {
                    android.util.Log.w(LOG_TAG, e);
                } catch (ExecutionException e) {
                    throw new RuntimeException("An error occurred while " +
                        " executing doInBackground()", e.getCause());
                } catch (CancellationException e) {
                    postResultIfNotInvoked(null);
                }
            }
        };
}</code></pre>

<p>关于 AsyncTask 不能执行时间太长(几分钟)的任务, 原因官方并没有解释说明. 在 StackOverflow 上的一个<a href="https://stackoverflow.com/questions/12797550/android-asynctask-for-long-running-operations?noredirect=1&amp;lq=1">回答</a>,  最高票的答案说明了两点原因:</p>
<ul>
<li>没有和 Activity 的生命周期同步</li>
<li>易产生内存泄漏</li>
</ul>
<p>第一点, <code>doInBackground</code> 是在非主线程中执行, 之后会在主线程中调用  <code>onPostExecute</code> 更新 UI. 但可能原先的 Activity 可能已经被 destroy, 或者重建, AsyncTask 中原 Activity 引用已经不是原来的指向, 这可能引发 Exception. 第二点, 我们很容易在 Activity 中创建一个 AsyncTask 的 inner class, 这使 AsyncTask 中有一个指向 Activity 的引用, 当手机转向等引起的 Activity 重建, 由于 AsyncTask 持有 outer class 的引用, 导致 Activity 不能释放内存</p>
<h3>Reference:</h3>
<ol>
<li>&lt;<Android开发艺术探索>&gt;</li>
<li><a href="https://android.googlesource.com/platform/frameworks/base/+/oreo-release/core/java/android/os/AsyncTask.java">AsyncTask 源代码</a></li>
<li><a href="https://stackoverflow.com/questions/12797550/android-asynctask-for-long-running-operations?noredirect=1&amp;lq=1">https://stackoverflow.com/questions/12797550/android-asynctask-for-long-running-operations?noredirect=1&amp;lq=1</a></li>
<li><a href="https://blog.csdn.net/Gaugamela/article/details/55188752">https://blog.csdn.net/Gaugamela/article/details/55188752</a></li>
</ol>

                <hr style="visibility: hidden;">
                <ul class="pager">
                </ul>
                <hr style="visibility: hidden;">

            </div>  
        </div>
    </article>
</div>

        <script src="/theme/js/jquery.min.js"></script>
        <script src="/theme/js/bootstrap.min.js"></script>
        <script src="/theme/js/prism.js"></script>
        <script src="/theme/js/hux-blog.min.js"></script>
        <script src="/theme/js/snackbar.js"></script>
        <script src="/theme/js/sw-registration.js"></script>
        <!--fastClick.js -->
        <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>

        <!-- Google Analytics -->
        <script>
            var _gaId = "UA-113622715-2";
            var _gaDomain = "";

            // Originial
            (function(i, s, o, g, r, a, m) {
                i["GoogleAnalyticsObject"] = r;
                (i[r] =
                    i[r] ||
                    function() {
                        (i[r].q = i[r].q || []).push(arguments);
                    }),
                    (i[r].l = 1 * new Date());
                (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
                a.async = 1;
                a.src = g;
                m.parentNode.insertBefore(a, m);
            })(
                window,
                document,
                "script",
                "//www.google-analytics.com/analytics.js",
                "ga"
            );

            ga("create", _gaId, _gaDomain);
            ga("send", "pageview");
        </script>


<script src="//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js"></script>
 
        
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->

                <p class="copyright text-muted">
                    Copyright &copy; Ambertime 2019                    <br>
                    Powered by <a href="http://getpelican.com/">Pelican</a> | Theme by <a href="http://huangxuan.me">HuxPro</a>
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=ivicel&repo=ivicel.github.io&type=star&count=true" >
                    </iframe>
                    
                </p>
            </div>
        </div>
    </div>
</footer> 
        
        <script src="/theme/js/jquery.min.js"></script>
        <script src="/theme/js/bootstrap.min.js"></script>
        <script src="/theme/js/prism.js"></script>
        <script src="/theme/js/hux-blog.min.js"></script>
        <script src="/theme/js/snackbar.js"></script>
        <script src="/theme/js/sw-registration.js"></script>
        <!--fastClick.js -->
        <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>

        <!-- Google Analytics -->
        <script>
            var _gaId = "UA-113622715-2";
            var _gaDomain = "";

            // Originial
            (function(i, s, o, g, r, a, m) {
                i["GoogleAnalyticsObject"] = r;
                (i[r] =
                    i[r] ||
                    function() {
                        (i[r].q = i[r].q || []).push(arguments);
                    }),
                    (i[r].l = 1 * new Date());
                (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
                a.async = 1;
                a.src = g;
                m.parentNode.insertBefore(a, m);
            })(
                window,
                document,
                "script",
                "//www.google-analytics.com/analytics.js",
                "ga"
            );

            ga("create", _gaId, _gaDomain);
            ga("send", "pageview");
        </script>


<script src="//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js"></script>
    </body>
</html>