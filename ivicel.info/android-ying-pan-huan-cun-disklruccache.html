<!DOCTYPE html>
<html lang="zh">
    <head>
          <meta charset="utf-8" />
        <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />


        <title>
Android 硬盘缓存 DiskLrucCache        </title>


        <meta name="HandheldFriendly" content="True" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="referrer" content="origin" />
        <meta name="generator" content="Pelican" />
        <link
            rel="icon"
            type="image/png"
            href="/assets/images/favicon.png"
        />
        <link href="/" rel="canonical" />

        <!-- Feed -->
         
        <link
            href="/theme/css/style.css"
            type="text/css"
            rel="stylesheet"
        />

        <!-- Code highlight color scheme -->
        <link
            href="/theme/css/code_blocks/github.css"
            rel="stylesheet"
        />
         <!-- CSS specified by the user -->
  
        <link href="/assets/css/prism.css" type="text/css" rel="stylesheet" />
  
        <link href="/assets/css/base.css" type="text/css" rel="stylesheet" />
  
        <link href="/assets/css/base-control.css" type="text/css" rel="stylesheet" />
  
        <link href="/assets/css/github.css" type="text/css" rel="stylesheet" />
  
        <link href="/assets/css/codemirror.css" type="text/css" rel="stylesheet" />
  
        <link href="/assets/css/ivicel.css" type="text/css" rel="stylesheet" />
 
        <!-- Custom fonts -->
        <link
            href="https://fonts.googleapis.com/css?family=Montserrat:400,300"
            rel="stylesheet"
            type="text/css"
        />
        <link
            href="https://fonts.googleapis.com/css?family=Lato"
            rel="stylesheet"
            type="text/css"
        />

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->


  <link href="/android-ying-pan-huan-cun-disklruccache.html" rel="canonical" />

    <meta name="description" content="1. DiskLruCache 的使用 DiskLruCache 并不属于 Android 源码 , 只是官方推荐的一种实现方式 , 可以在 这里 找到源码 , 这个源码使用了其他几个自定义类里的方法 , 比如读行 , 出错打印 . Android Developer...">

    <meta name="author" content="ivicel">

    <meta name="tags" content="缓存">
    <meta name="tags" content="磁盘缓存">
    <meta name="tags" content="lru">
    <meta name="tags" content="cache">
    <meta name="tags" content="disk cache">




<!-- Open Graph -->
<meta property="og:site_name" content="Ambertime"/>
<meta property="og:title" content="Android 硬盘缓存 DiskLrucCache"/>
<meta property="og:description" content="1. DiskLruCache 的使用 DiskLruCache 并不属于 Android 源码 , 只是官方推荐的一种实现方式 , 可以在 这里 找到源码 , 这个源码使用了其他几个自定义类里的方法 , 比如读行 , 出错打印 . Android Developer..."/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="/android-ying-pan-huan-cun-disklruccache.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2018-04-04 00:00:00+08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="/author/ivicel.html">
<meta property="article:section" content="misc"/>
<meta property="article:tag" content="缓存"/>
<meta property="article:tag" content="磁盘缓存"/>
<meta property="article:tag" content="lru"/>
<meta property="article:tag" content="cache"/>
<meta property="article:tag" content="disk cache"/>
<meta property="og:image" content="/theme/images/post-bg.jpg">

<!-- Twitter Card -->

<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "name": "Android 硬盘缓存 DiskLrucCache",
  "headline": "Android 硬盘缓存 DiskLrucCache",
  "datePublished": "2018-04-04 00:00:00+08:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "ivicel",
    "url": "/author/ivicel.html"
  },
  "image": "/theme/images/post-bg.jpg",
  "url": "/android-ying-pan-huan-cun-disklruccache.html",
  "description": "1. DiskLruCache 的使用 DiskLruCache 并不属于 Android 源码 , 只是官方推荐的一种实现方式 , 可以在 这里 找到源码 , 这个源码使用了其他几个自定义类里的方法 , 比如读行 , 出错打印 . Android Developer..."
}
</script>    </head>
    <!-- TODO : Body class -->
    <body class="home-template">
<nav id="menu">
  <a class="close-button">Close</a>
  <div class="nav-wrapper">
    <p class="nav-label">Menu</p>
    <ul>

              <li role="presentation"><a href="/pages/about.html">About</a></li>
              <li role="presentation"><a href="/pages/archives.html">Archives</a></li>
              <li role="presentation"><a href="/pages/category.html">Category</a></li>

    </ul>
  </div>
</nav>     <!-- Progressbar -->
    <div class="progress-container">
        <span class="progress-bar"></span>
    </div>

    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
    <header id="blog-header" >
      <div class="inner">
        <nav id="navigation">
            <span id="home-button" class="nav-button">
                <a class="home-button" href="/" title="Home"><i class="ic ic-arrow-left"></i> Home</a>
            </span>
          <span id="menu-button" class="nav-button">
            <a class="menu-button"><i class="ic ic-menu"></i> Menu</a>
          </span>
        </nav>
        <h1 class="post-title">Android 硬盘缓存 DiskLrucCache</h1>
        <!-- TODO : Proper class for headline -->
        <span class="post-meta">
                <a href="/author/ivicel.html">Ivicel</a>
            | <time datetime="Wed 04 April 2018">Wed 04 April 2018</time>
        </span>
        <!-- TODO : Modified check -->
      </div>
    </header>

        <section id="wrapper">
            <a class="hidden-close"></a>

    <!-- Post content -->
    <main class="content" role="main">
        <article class="post">
        <div class="inner">
            <section class="post-content">
                <h3 id="1-disklrucache">1. DiskLruCache 的使用 </h3>
<p>DiskLruCache 并不属于 Android 源码 , 只是官方推荐的一种实现方式 , 可以在 <a href="https://android.googlesource.com/platform/libcore/+/jb-mr2-release/luni/src/main/java/libcore/io/StrictLineReader.java"> 这里 </a> 找到源码 , 这个源码使用了其他几个自定义类里的方法 , 比如读行 , 出错打印 . Android Developer Sample 里关于 bitmap 的加载使用到了这个类来做缓存 , 可直接使用 , 可以在 <a href="https://developer.android.com/samples/DisplayingBitmaps/src/com.example.android.displayingbitmaps/util/DiskLruCache.html"> 这里 </a> 找到源码 . 另外一个 <a href="https://gist.github.com/ivicel/f98f9ba4420c9d2c5274f151b625f677">GitHub 备份地址 </a></p>
<blockquote>
<p>Android Developer Sample 里的源码没有有效的初始化 redundantOpCount, 而是为 0. 这导致如果不断退出重进应用 , 很难达到封顶的 2000 行 , 即使 journal 已经超出 2000 行 . </p>
<p>GitHub 上已经添加 </p>
</blockquote>
<p> 一般来说我们都会把磁盘放到 sdcard 上 , 也就是 <code>/sdcard/Android/data/app_package_name/cache</code> 里 , 在 <strong>SDK 19</strong> 之前 , 外部存储需要声明权限 <code>WRITE_EXTERNAL_STORAGE</code>. </p>
<p> 在使用外部存储之前 , 还有一样需要注意的是 <strong> 判断是否存在外部存储 </strong>. </p>
<pre class="highlight"><code class="language-java linenums">private File getCacheDirectoryFile(Context context, String dirName) {
    File cacheFile;
    if (!Environment.isExternalStorageRemovable ||
        Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
        // 外部 cache
        cacheFile = context.getExternalCacheDir();
    } else {
        // 内部 cache
        cacheFile = context.getCacheDir();
    }
    return new File(cacheFile, dirName);
}</code></pre>

<blockquote>
<p>DiskLruCache 的缓存目录里不要跟别的缓存相互混合 , 以免导致缓存出错 </p>
</blockquote>
<p>DiskLruCache 构造方法是 <code>private</code>, 提供了一个 <code>DiskLruCache#open()</code> 方法来获得一个新的对象 .</p>
<pre class="highlight"><code class="language-java linenums">// @param directory 缓存目录
// @param appVersion 版本号 , 当版本号发生改变时 , 缓存会被清空重建
// @param valueCount 每个节点对应该对应的数据个数 , 一般传 1, 一个节点一个数据
// @param maxSize 缓存大小
public static open(File directory, int appVersion, int valueCount, long maxSize);

// 80M 缓存
DiskLruCache lruCache = DiskLruCache.open(getCacheDirectoryFile(context, "images",
        1, 1, 80 * 1024 * 1024);</code></pre>

<p> 向缓存中写入数据 , 由 <code>DiskLruCache.Editor</code> 类负责 . 使用 <code>DiskLruCache#edit()</code> 方法获得一个 <code>DiskLruCache.Editor</code> 对象 , 便可以打开文件输入和输出流来进行读写 . 这里的 <code>newInputStream()</code> 只能读到最后一次 <code>commit</code></p>
<pre class="highlight"><code class="language-java linenums">// 由 key 值获得 Editor 对象 , key 值一般也使用 url 的 MD5 值
DiskLruCache.Editor editor = lruCache.edit(key);
// 获得输出流 , 参数是数据的数组下标 , 指的是在 open 时传入的 valueCount 的值
// 这个值为一个 node 节点以数组的形式来存储多少个数据 , 只存一个数据 , 其下标为 0
OutputStream out = editor.newOutputStream(0);
// 将 bitmap 压缩成 png 写入到流中 , 然后将写入结果记到日志中
if (bitmap.compress(Bitmap.CompressFormat.PNG, 50, out)) {
    editor.commit();
} else {
    editor.abort();
}</code></pre>

<p> 通过 <code>DiskLruCache#get()</code> 方法可以得到一个 <code>DiskLruCache.Snapshot</code> 对象 , 通过这个对象可以得到缓存文件的输入流 </p>
<pre class="highlight"><code class="language-java linenums">// 根据 key 找到对应的缓存文件
DiskLruCache.Snapshot snapShot = lruCache.get(key);
InputStream in = snapShot.getInputStream(0);
// InputStream 是一种有序的流 , 第一次读完后指针便指向流末尾 . 用文件描述符即可 , 或者重置指针位置
FileDescriptor fd = in.getFD();
// 根据需要的宽高进行压缩
bitmap = loadSpecifyImage(fd, destWidth, destHeight);</code></pre>

<h3 id="2-disklrucache">2. DiskLruCache 源码解析 </h3>
<h4 id="21">2.1 头部 </h4>
<p>DiskLruCache 的缓存记录最主要是对其日志文件 journal 进行操作 , 一但 journal 文件遭到破坏 , 缓存被会被重建 . 其格式说明如下 :</p>
<blockquote>
<pre class="highlight"><code class="linenums">libcore.io.DiskLruCache
1
1
2

DIRTY 335c4c6028171cfddfbaae1a9c313c52
CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342
REMOVE 335c4c6028171cfddfbaae1a9c313c52
DIRTY 1ab96a171faeeee38496d8b330771a7a
CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234
READ 1ab96a171faeeee38496d8b330771a7a</code></pre>

</blockquote>
<ul>
<li> 头部 , 每一次打开 (<code>DiskLruCache#open</code>) 时都会验证头部是否相符 , 如果存在 <strong>journal</strong> 但不相符的 , 缓存被清空然后重建 . 不存在 <strong>journal</strong> 的 , 重建缓存 :</li>
<li> 第一行是文件标识 <code>MAGIC</code>, 默认为 <code>libcore.io.DiskLruCache</code></li>
<li> 第二行是 DiskLruCache 类的版本号 (<code>CACHE_VERSION</code>), 默认是 <code>1</code></li>
<li> 第三行是传入的 App 版本号 (<code>APP_VERSION</code>), 当应用版本号变动时缓存被清空 . 要想在应用变更时不清空缓存传入一个 <strong> 固定值 </strong> 便可 </li>
<li> 第四行是 <code>valueCount</code>, 代表的是一个 <code>Node</code> 结点对应的是几个数据节点 . 上面的是 <strong> 两 </strong> 个 </li>
<li> 第五行是一个空行分隔行 </li>
<li> 主体记录 , 格式为 <code>status key value[0].length….value[N - 1].length</code>, 每列值以 <strong> 空格 </strong> 分隔 </li>
<li><code>status</code> 的值有 :<ul>
<li><code>DIRTRY</code> 脏数据 , 代表对这条数据进行操作 , 每一行 <code>DIRTY</code> 后都应该跟着一条 <code>CLEAN</code> 或者 <code>REMOVE</code>, 代表对数据的操作结束 . 如果没有则这条数据为无效数据 , 将被删除 </li>
<li><code>CLEAN</code> 代表这条数据已经写入到磁盘中 , 可以进行读写 </li>
<li><code>REMOVE</code> 代表这条数据已经被删除 </li>
<li><code>READ</code> 代表读取一条数据 </li>
</ul>
</li>
<li><code>status</code> 后面跟着 <code>key</code>, <code>CLEAN</code> 操作后面跟着节点内每条数据的大小 , 单位为 <code>byte</code>, 上面例子每个节点有两条 . 这些 <strong> 数据的合 </strong> 代表当前缓存使用的大小 </li>
</ul>
<h4 id="22-entry">2.2 缓存文件的内部摘要类 Entry</h4>
<p> 与 LruCache 类似 , DiskLruCache 也是一个最近访问最多算法 , 其类内部也一样持一个 <code>LinkedHashMap</code> 对象 <code>lruEntries</code> 来记录其数据被访问记录 , 结构为 <code>&lt;String, DiskLruCache#Entry&gt;</code>, <code>key</code> 是我们传入的 , <code>Entry</code> 对象为内部私有类 , 记录在磁盘上名为 <code>key</code> 的文件的一些信息 . 比如可读 , 可写 , 对应 <code>key</code> 等 </p>
<pre class="highlight"><code class="language-java linenums">// DiskLruCache#Entry
private final class Entry {
    // 对应的 key
    private final String key;
    // 节点数据的字节数
    private final long[] lengths;
    // 当一条数据有 CLEAN, 即被写到磁盘里时 , 为 true
    private boolean readable;
    // The ongoing edit or null if this entry is not being edited.
    private Editor currentEditor;
    // The sequence number of the most recently committed edit to this entry.
    private long sequenceNumber;

    /* ... */

    // 一个 node 对应多个数据时 , 是以 key.i 的格式为名字来保存文件
    public File getCleanFile(int i) {
        return new File(directory, key + "." + i);
    }

    public File getDirtyFile(int i) {
        return new File(directory, key + "." + i + ".tmp");
    }
}</code></pre>

<h4 id="23">2.3 打开缓存 </h4>
<p>DiskLruCache 的构造方法是 <code>private</code> 的 , 通过静态方法 <code>DiskLruCache#open()</code> 来创建一个缓存对象 . 构造方法只是简单的保存了一些属性值 . 而 <code>open()</code> 方法里对 journal 文件进行了判断和验证 </p>
<p> 创建缓存方法 </p>
<pre class="highlight"><code class="language-java linenums">// DiskLruCache#open()
public static DiskLruCache open(File directory, int appVersion, int valueCount, 
        long maxSize) throws IOException {
    /* ... */   
    // prefer to pick up where we left off
    DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, 
            maxSize);
    // 如果已经存在了 journal 文件 , 读取头部进行对比
    // 对比失败会删除该缓存目录 , 然后再重建一个缓存目录
    if (cache.journalFile.exists()) {
        try {
            // 验证头部 , 读取日志中的每一行
            // 跳过 REMOVE 记录 , 只保存 READ, DIRTY, CLEAN. 到 LinkedHashMap 中
            // CLEAN 设置 readable = true, 节点每个数据的大小到 lenghts 数组
            // DIRTY 设置 currentEditor = new Editor(entry)
            // READ 不作改变
            cache.readJournal();
            // 
            cache.processJournal();
            cache.journalWriter = new BufferedWriter(
                    new FileWriter(cache.journalFile, true), IO_BUFFER_SIZE);
            return cache;
        } catch (IOException journalIsCorrupt) {
            cache.delete();
        }
    }

    // create a new empty cache
    directory.mkdirs();
    cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);
    cache.rebuildJournal();
    return cache;
}</code></pre>

<p><code>open()</code> 里即使传入的目录不存在 , DiskLruCache 也是会帮我们重建一个缓存目录的 . </p>
<pre class="highlight"><code class="language-java linenums">// DiskLruCache#rebuildJournal()
private synchronized void rebuildJournal() throws IOException {
    if (journalWriter != null) {
        journalWriter.close();
    }

    // 使用临时 journal 文件来重建缓存 , 重建完成后再更名为正式的 journal 文件名
    // 按格式写入头部
    /* ... */

    // 将内存中已经读取的缓存记录写到文件里
    for (Entry entry : lruEntries.values()) {
        if (entry.currentEditor != null) {
            writer.write(DIRTY + ' ' + entry.key + '\n');
        } else {
            writer.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n');
        }
    }
    // 关闭文件 , 重命名 , 将 journalWriter 指向新文件
    writer.close();
    journalFileTmp.renameTo(journalFile);
    journalWriter = new BufferedWriter(new FileWriter(journalFile, true), IO_BUFFER_SIZE);
}</code></pre>

<p><code>readJournal()</code>, <code>readJournalLine()</code>, <code>processJournal()</code> 这三个方法是重要的操作 journal 文件的方法 . <code>readJournal()</code> 处理好正确的头部匹配 , 然后调用  <code>readJournalLine()</code> 来读取每一行主体内容 . 处理的步骤为 : 
1. 每读到一个 REMOVE 就删除 <code>lruEntries</code> 里对应 key 的 entry
2. 如果这一行不为 REMOVE, 并且其不在 <code>lruEntries</code> 里 , 就将为其创建一个 entry 加入到链表中
3. 如果这一行为 CLEAN, 那表示这条数据已确保写到磁盘了 , 设置为 <code>readable = true</code>, <code>currentEditor = null</code>, 并将该节点的数据大小进行保存
4. 如果这一行为 DIRTY, 表示这条数据有过编辑 (<code>DiskLruCache#.edit()</code>), 为其创建一个编辑器
5. 如果这一行为 READ, 已经在 2 里处理过了 </p>
<p> 这样就处理了所有的标记符 . 在 <code>processJournal()</code> 方法里 , 删除掉 DIRTY 记录 . 因为一条 DIRTY 只对应一条 CLEAN 或 REMOVE, REMOVE 对应的 DIRTY 我们已经在第一次读到时已经删除过 . 另外在每次读到 CLEAN 时 , 我们都会把其对应的 DIRTY 的 <code>currentEditor</code> 设置为 <code>null</code>, 所以只要查找 <code>currentEditor = null</code> 记录便可 </p>
<pre class="highlight"><code class="language-java linenums">// DiskLruCache#readJournal()
// 这个方法主要是验证头部正确后 , 把日志时的每条记录都读到 lruEntries 中
private void readJournal() throws IOException {
    InputStream in = new BufferedInputStream(new FileInputStream(journalFile), IO_BUFFER_SIZE);
    try {
        // 验证头部 , 每次读一行 , 分别与传入的值对比
        /* ... */

        // 如果头部无误 , 将除 REMOVE 之外的记录读到 lruEntries 中
        int lineCount = 0;
        while (true) {
            try {
                readJournalLine(readAsciiLine(in));
                lineCount++;
            } catch (EOFException endOfJournal) {
                break;
            }
        }
        redundantOpCount = lineCount - lruEnties.size();
    } finally {
        closeQuietly(in);
    }
}


// DiskLruCache#readJournalLine()
private void readJournalLine(String line) throws IOException {
    String[] parts = line.split(" ");
    if (parts.length &lt; 2) {
        throw new IOException("unexpected journal line: " + line);
    }
    // 当读到 REMOVE 表示我们要删除该条对应的 DIRTY 记录
    String key = parts[1];
    if (parts[0].equals(REMOVE) &amp;&amp; parts.length == 2) {
        lruEntries.remove(key);
        return;
    }
    // 过滤掉 REMOVE 匹配的一次 DIRTY 记录后 , 剩下的记录都会读到 lruEntries
    Entry entry = lruEntries.get(key);
    if (entry == null) {
        entry = new Entry(key);
        lruEntries.put(key, entry);
    }

    if (parts[0].equals(CLEAN) &amp;&amp; parts.length == 2 + valueCount) {
        // CLEAN 表示保存了文件 , 是可读的
        entry.readable = true;
        entry.currentEditor = null;
        // 设置其节点有多少份数据 , copyOfRange 同 Arrays.copyOfRange
        entry.setLengths(copyOfRange(parts, 2, parts.length));
    } else if (parts[0].equals(DIRTY) &amp;&amp; parts.length == 2) {
        // 为 DIRTY 记录设置一个可写对象
        entry.currentEditor = new Editor(entry);
    } else if (parts[0].equals(READ) &amp;&amp; parts.length == 2) {
        // this work was already done by calling lruEntries.get()
    } else {
        throw new IOException("unexpected journal line: " + line);
    }
}


// DiskLruCache#processJournal()
// 再把日志的数据都读到 lruEntries 后 , 删除其中的 DIRTY 数据
// 因为每一条 DIRTY 至少匹配 REMOVE
private void processJournal() throws IOException {
    deleteIfExists(journalFileTmp);
    for (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) {
        Entry entry = i.next();
        if (entry.currentEditor == null) {
            // 删除到记录不正确的 DIRTY 后 , 才计算现在使用了多少容量
            for (int t = 0; t &lt; valueCount; t++) {
                size += entry.lengths[t];
            }
        } else {
            // 删除 DIRTY 记录
            entry.currentEditor = null;
            for (int t = 0; t &lt; valueCount; t++) {
                deleteIfExists(entry.getCleanFile(t));
                deleteIfExists(entry.getDirtyFile(t));
            }
            i.remove();
        }
    }
}</code></pre>

<h4 id="24">2.4 写入缓存 </h4>
<p> 在将日志记录读到 <code>lruEntries</code> 后 , 便可以进行读写操作 . 写操作是获得一个 <code>DiskLruCache#Editor</code> 对象 .</p>
<pre class="highlight"><code class="language-java linenums">private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
    // 检测文件没有关闭和 key 的有效性 , 不能包含空格和换行 : ' ', '\r', '\n'
    checkNotClosed();
    validateKey(key);
    // lruEntries 中取出该记录 , 如果不为 null, 说明不是新记录 ; 并且如果其
    // 保存了 currentEditor 的话说明有其他线程在编辑 , 因为我们会把完成的 DIRTY 记录
    // 从 lruEntries 中删除掉
    Entry entry = lruEntries.get(key);
    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER
            &amp;&amp; (entry == null || entry.sequenceNumber != expectedSequenceNumber)) {
        return null; // snapshot is stale
    }
    // 这里要注意如果我们获取了一次 Editor 对象 , 再次获取前没有 commit/abort 操作则返回 null
    if (entry == null) {
        entry = new Entry(key);
        lruEntries.put(key, entry);
    } else if (entry.currentEditor != null) {
        return null; // another edit is in progress
    }
    // 获取一个新的编辑状态
    Editor editor = new Editor(entry);
    entry.currentEditor = editor;

    // 写入 DIRTY 状态
    journalWriter.write(DIRTY + ' ' + key + '\n');
    journalWriter.flush();
    return editor;
}</code></pre>

<p> 在拿到 <code>Editor</code> 对象之后 , 便可以获得输出流 , 将图片之类写到磁盘作缓存 . </p>
<pre class="highlight"><code class="language-java linenums">public final class Editor {
    private final Entry entry;
    private boolean hasErrors;

    // 返回的是一个 FilterOutputStream, 如果出错就把标志位 hasErrors 设为 true
    // 在写完后 commit 时检查标志位 , 有错误会放弃该缓存
    public OutputStream newOutputStream(int index) throws IOException {
        synchronized (DiskLruCache.this) {
            if (entry.currentEditor != this) {
                throw new IllegalStateException();
            }
            // FileOutputStream 会帮我们自动创建文件
            return new FaultHidingOutputStream(
                    new FileOutputStream(entry.getDirtyFile(index)));
        }
    }

    /* ... */
}</code></pre>

<p> 调用 <code>DiskLruCache.Editor#commit()</code> 时会调用 <code>DiskLruCache#completeEdit()</code> 完成最终编辑 </p>
<pre class="highlight"><code class="language-java linenums">private synchronized void completeEdit(Editor editor, boolean success) 
        throws IOException {
        // 检查 DIRTY 文件是否创建了
        if (success &amp;&amp; !entry.readable) {
            for (int i = 0; i &lt; valueCount; i++) {
                if (!entry.getDirtyFile(i).exists()) {
                    editor.abort();
                    throw new IllegalStateException("edit didn't create file " + i);
                }
            }
        }
        // 重命名文件 , 减去老的缓存大小
        for (int i = 0; i &lt; valueCount; i++) {
            File dirty = entry.getDirtyFile(i);
            if (success) {
                if (dirty.exists()) {
                    File clean = entry.getCleanFile(i);
                    dirty.renameTo(clean);
                    long oldLength = entry.lengths[i];
                    long newLength = clean.length();
                    entry.lengths[i] = newLength;
                    size = size - oldLength + newLength;
                }
            } else {
                deleteIfExists(dirty);
            }
        }
        // 操作行数增加 1
        redundantOpCount++;
        // 操作完成时重置为 null
        entry.currentEditor = null;
        if (entry.readable | success) {
            entry.readable = true;
            journalWriter.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n');
            if (success) {
                // sequenceNumber 用来记录该 entry 是否过期 , 在获取 Shapshot 时会与
                // entry.sequenceNumber 对比 , 如果不相等则是过期的
                entry.sequenceNumber = nextSequenceNumber++;
            }
        } else {
            lruEntries.remove(entry.key);
            journalWriter.write(REMOVE + ' ' + entry.key + '\n');
        }
        // 判断是否超出设定的缓存容量 , 是否操作行数记录大于 2000, 
        // 或者 redundantOpCount &gt; lruEntries.size()
        // 以便来决定是否在释放一些缓存
        if (size &gt; maxSize || journalRebuildRequired()) {
            executorService.submit(cleanupCallable);
        }
    }</code></pre>

<h4 id="25">2.5 读取缓存 </h4>
<p> 通过 <code>DiskLruCache#get()</code> 获得一个 <code>Snapshot</code> 缓存对象 . 该对象主要是 <code>InputStream</code> 的再封装 </p>
<pre class="highlight"><code class="language-java linenums">// DiskLruCache#get
public synchronized Snapshot  (String key) throws IOException {
    // 检查文件是否打开 , key 是否正确
    /* ... */

    // 一次性打开所有的数据以保证一个 key 即使对应多个数据也只有一个 snapshot
    InputStream[] ins = new InputStream[valueCount];
    try {
        for (int i = 0; i &lt; valueCount; i++) {
            ins[i] = new FileInputStream(entry.getCleanFile(i));
        }
    } catch (FileNotFoundException e) {
        // a file must have been deleted manually!
        return null;
    }
    // 记录操作数 , 写入操作记录 , 之后要再检查操作记录是否超出设定
    redundantOpCount++;
    journalWriter.append(READ + ' ' + key + '\n');
    if (journalRebuildRequired()) {
        executorService.submit(cleanupCallable);
    }

    return new Snapshot(key, entry.sequenceNumber, ins);
}</code></pre>

<h4 id="26">2.6 删除缓存 </h4>
<p> 每次读 , 写 , 删除缓存后 , 都要再次判断操作记录或者缓存大小已经超出设置的值 . 删除操作主要是由一个 </p>
<pre class="highlight"><code class="language-java linenums">// 调用 remove
// DiskLruCache#remove
public synchronized boolean remove(String key) throws IOException {
    checkNotClosed();
    validateKey(key);
    Entry entry = lruEntries.get(key);
    if (entry == null || entry.currentEditor != null) {
        return false;
    }
    // 删除对应 key 的所有文件
    for (int i = 0; i &lt; valueCount; i++) {
        File file = entry.getCleanFile(i);
        if (!file.delete()) {
            throw new IOException("failed to delete " + file);
        }
        size -= entry.lengths[i];
        entry.lengths[i] = 0;
    }
    // 是否要重建 journal 文件
    redundantOpCount++;
    journalWriter.append(REMOVE + ' ' + key + '\n');
    lruEntries.remove(key);

    if (journalRebuildRequired()) {
        executorService.submit(cleanupCallable);
    }

    return true;
}

private final ExecutorService executorService = new ThreadPoolExecutor(0, 1, 60L,
        TimeUnit.SECONDS, new LinkBlockingQueue&lt;Runnable&gt;());
private final Callable&lt;Void&gt; cleanupCallable = new Callable&lt;&gt;() {
    @Override
    public Void call() throw Exception {
        synchronized (DiskLruCache.this) {
            if (journalWriter == null) {
                return null;
            }
            trimeToSize();
            if (journalRebuildRequired()) {
                rebuildJournal();
                redundantOpCount = 0;
            }
            return null;
        }
    }
};

private void trimToSize() throws IOException {
    // 循环迭代删除超出的空间
    while (size &gt; maxSize) {
        final Map.Entry&lt;String, Entry&gt; toEvict = 
            lruEntries.entrySet().iterator.next();
        remove(toEvict.getKey());
    }
}</code></pre>

<h3 id="reference">Reference</h3>
<ol>
<li>&lt;<Android 开发艺术探索 >&gt;</li>
<li><a href="https://blog.csdn.net/shakespeare001/article/details/51695358">https://blog.csdn.net/shakespeare001/article/details/51695358</a></li>
<li><a href="https://www.jianshu.com/p/b282140acc20">https://www.jianshu.com/p/b282140acc20</a></li>
<li><a href="http://nirvanawoody.com/2016/05/05/Android-DiskLruCache">http://nirvanawoody.com/2016/05/05/Android-DiskLruCache</a></li>
</ol>
            </section>

            <section class="post-info">
                <div class="post-share">
                    <a class="twitter" href="https://twitter.com/share?text=Android 硬盘缓存 DiskLrucCache&amp;url=/android-ying-pan-huan-cun-disklruccache.html" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <i class="ic ic-twitter"></i><span class="hidden">Twitter</span>
                    </a>
                    <a class="facebook" href="https://www.facebook.com/sharer/sharer.php?u=/android-ying-pan-huan-cun-disklruccache.html" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <i class="ic ic-facebook"></i><span class="hidden">Facebook</span>
                    </a>
                    <a class="googleplus" href="https://plus.google.com/share?url=/android-ying-pan-huan-cun-disklruccache.html" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <i class="ic ic-googleplus"></i><span class="hidden">Google+</span>
                    </a>
                    <div class="clear"></div>
                </div>

                <aside class="post-tags">
<a href="/tag/huan-cun.html">缓存</a><a href="/tag/ci-pan-huan-cun.html">磁盘缓存</a><a href="/tag/lru.html">lru</a><a href="/tag/cache.html">cache</a><a href="/tag/disk-cache.html">disk cache</a>                </aside>

                <div class="clear"></div>


                </section>


                <aside class="post-nav">
                    <div class="clear"></div>
                </aside>

            </div>
        </article>
    </main>
            <!-- TODO : Body class -->
            <div
                id="body-class"
                style="display: none;"
                class=""
            ></div>

            <footer id="footer">
                <div class="inner">
                    <section class="credits">
      
                        <span class="credits-theme">Theme
                        <a
                            href="https://github.com/arulrajnet/attila"
                            rel="nofollow"
                            >Attila</a
                        ></span>
                        <span class="credits-software">Published with
                        <a
                            href="https://github.com/getpelican/pelican"
                            rel="nofollow"
                            >Pelican</a
                        ></span>
                    </section>
                </div>
            </footer>
        </section>

        <script
            type="text/javascript"
            src="/theme/js/script.js"
        ></script>

        <!-- Script specified by the user -->
           <script type="text/javascript" src="/assets/js/prism.js"></script>
       </body>
</html>