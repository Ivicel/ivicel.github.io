<!DOCTYPE html>
<html lang="en">
    <head>
            <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="google-site-verification" content="WpfeDx8HRNQcT7jzjSsZ0vhtfw8M7gFo-YoDmXZRGHg"/>
        <meta name="google-site-verification" content="H97dWyn-QYy4n8BEw7ZAX8bFDDin_BwYiEOb3v_4dEs" />
        <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
        
  
        <title>
Ambertime        </title>

        <!-- Web App Manifest -->
        <link rel="manifest" href="https://ivicel.info/assets/pwa/manifest.json" />

        <!-- Favicon -->
        <link rel="shortcut icon" href="https://ivicel.info/assets/images/favicon.ico"/>
        <!-- Canonical URL -->
        <link rel="canonical" href="" />
        <link rel="stylesheet" href="https://ivicel.info/theme/css/bootstrap.min.css" />

        <!-- Custom CSS -->
        <link rel="stylesheet" href="https://ivicel.info/theme/css/hux-blog.min.css" />
        <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="https://ivicel.info/theme/css/prism.css" />
        <link rel="stylesheet" href="https://ivicel.info/theme/css/ivicel.css" />

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->
        


    <style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('https://ivicel.info/assets/images/header.jpg');
    }

    header.intro-header .header-mask{
        width: 100%;
        height: 100%;
        position: absolute;
        background: rgba(0,0,0, 0.3);
    }
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>
    </head>


    <!-- hack iOS CSS :active style -->
    <body ontouchstart="">
<!-- Navigation -->
<!-- <nav class="navbar navbar-default navbar-custom navbar-fixed-top invert"> -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ivicel.info/">Ambertime</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="https://ivicel.info/">Home</a>
                    </li>
                        <li>
                            <a href="https://ivicel.info/archives">ARCHIVES</a>
                        </li>
                        <li>
                            <a href="https://ivicel.info/about">ABOUT</a>
                        </li>
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script> 
        
<!-- Post Header -->

<header class="intro-header" >
    <div class="header-mask"></div>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        <a class="tag" href="#" title="缓存">缓存</a>
                        <a class="tag" href="#" title="磁盘缓存">磁盘缓存</a>
                        <a class="tag" href="#" title="lru">lru</a>
                        <a class="tag" href="#" title="cache">cache</a>
                        <a class="tag" href="#" title="disk cache">disk cache</a>
                    </div>
                    <h1>Android 硬盘缓存 DiskLrucCache</h1>
                    <span class="meta">Posted by ivicel on 2018-04-04</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<div class="container">
    <article>
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container">
                <h3>1. DiskLruCache 的使用</h3>
<p>DiskLruCache 并不属于 Android 源码, 只是官方推荐的一种实现方式, 可以在 <a href="https://android.googlesource.com/platform/libcore/+/jb-mr2-release/luni/src/main/java/libcore/io/StrictLineReader.java">这里</a> 找到源码, 这个源码使用了其他几个自定义类里的方法, 比如读行, 出错打印. Android Developer Sample 里关于 bitmap 的加载使用到了这个类来做缓存, 可直接使用, 可以在 <a href="https://developer.android.com/samples/DisplayingBitmaps/src/com.example.android.displayingbitmaps/util/DiskLruCache.html">这里</a> 找到源码. 另外一个 <a href="https://gist.github.com/ivicel/f98f9ba4420c9d2c5274f151b625f677">GitHub 备份地址</a></p>
<blockquote>
<p>Android Developer Sample 里的源码没有有效的初始化 redundantOpCount, 而是为 0. 这导致如果不断退出重进应用, 很难达到封顶的 2000 行, 即使 journal 已经超出 2000 行. </p>
<p>GitHub 上已经添加</p>
</blockquote>
<p>一般来说我们都会把磁盘放到 sdcard 上, 也就是 <code>/sdcard/Android/data/app_package_name/cache</code> 里, 在 <strong>SDK 19</strong> 之前, 外部存储需要声明权限 <code>WRITE_EXTERNAL_STORAGE</code>. </p>
<p>在使用外部存储之前, 还有一样需要注意的是<strong>判断是否存在外部存储</strong>. </p>
<pre class="highlight line-numbers"><code class="language-java linenums">private File getCacheDirectoryFile(Context context, String dirName) {
    File cacheFile;
    if (!Environment.isExternalStorageRemovable ||
        Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
        // 外部 cache
        cacheFile = context.getExternalCacheDir();
    } else {
        // 内部 cache
        cacheFile = context.getCacheDir();
    }
    return new File(cacheFile, dirName);
}</code></pre>

<blockquote>
<p>DiskLruCache 的缓存目录里不要跟别的缓存相互混合, 以免导致缓存出错</p>
</blockquote>
<p>DiskLruCache 构造方法是 <code>private</code>, 提供了一个 <code>DiskLruCache#open()</code> 方法来获得一个新的对象.</p>
<pre class="highlight line-numbers"><code class="language-java linenums">// @param directory 缓存目录
// @param appVersion 版本号, 当版本号发生改变时, 缓存会被清空重建
// @param valueCount 每个节点对应该对应的数据个数, 一般传 1, 一个节点一个数据
// @param maxSize 缓存大小
public static open(File directory, int appVersion, int valueCount, long maxSize);

// 80M 缓存
DiskLruCache lruCache = DiskLruCache.open(getCacheDirectoryFile(context, "images",
        1, 1, 80 * 1024 * 1024);</code></pre>

<p>向缓存中写入数据, 由 <code>DiskLruCache.Editor</code> 类负责. 使用 <code>DiskLruCache#edit()</code> 方法获得一个 <code>DiskLruCache.Editor</code> 对象, 便可以打开文件输入和输出流来进行读写. 这里的 <code>newInputStream()</code> 只能读到最后一次 <code>commit</code></p>
<pre class="highlight line-numbers"><code class="language-java linenums">// 由 key 值获得 Editor 对象, key 值一般也使用 url 的 MD5 值
DiskLruCache.Editor editor = lruCache.edit(key);
// 获得输出流, 参数是数据的数组下标, 指的是在 open 时传入的 valueCount 的值
// 这个值为一个 node 节点以数组的形式来存储多少个数据, 只存一个数据, 其下标为 0
OutputStream out = editor.newOutputStream(0);
// 将 bitmap 压缩成 png 写入到流中, 然后将写入结果记到日志中
if (bitmap.compress(Bitmap.CompressFormat.PNG, 50, out)) {
    editor.commit();
} else {
    editor.abort();
}</code></pre>

<p>通过 <code>DiskLruCache#get()</code> 方法可以得到一个 <code>DiskLruCache.Snapshot</code> 对象, 通过这个对象可以得到缓存文件的输入流</p>
<pre class="highlight line-numbers"><code class="language-java linenums">// 根据 key 找到对应的缓存文件
DiskLruCache.Snapshot snapShot = lruCache.get(key);
InputStream in = snapShot.getInputStream(0);
// InputStream 是一种有序的流, 第一次读完后指针便指向流末尾. 用文件描述符即可, 或者重置指针位置
FileDescriptor fd = in.getFD();
// 根据需要的宽高进行压缩
bitmap = loadSpecifyImage(fd, destWidth, destHeight);</code></pre>

<h3>2. DiskLruCache 源码解析</h3>
<h4>2.1 头部</h4>
<p>DiskLruCache 的缓存记录最主要是对其日志文件 journal 进行操作, 一但 journal 文件遭到破坏, 缓存被会被重建. 其格式说明如下:</p>
<blockquote>
<pre class="highlight line-numbers"><code class="linenums">libcore.io.DiskLruCache
1
1
2

DIRTY 335c4c6028171cfddfbaae1a9c313c52
CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342
REMOVE 335c4c6028171cfddfbaae1a9c313c52
DIRTY 1ab96a171faeeee38496d8b330771a7a
CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234
READ 1ab96a171faeeee38496d8b330771a7a</code></pre>

</blockquote>
<ul>
<li>头部, 每一次打开(<code>DiskLruCache#open</code>)时都会验证头部是否相符, 如果存在 <strong>journal</strong> 但不相符的, 缓存被清空然后重建. 不存在 <strong>journal</strong> 的, 重建缓存:</li>
<li>第一行是文件标识 <code>MAGIC</code>, 默认为 <code>libcore.io.DiskLruCache</code></li>
<li>第二行是 DiskLruCache 类的版本号(<code>CACHE_VERSION</code>), 默认是 <code>1</code></li>
<li>第三行是传入的 App 版本号(<code>APP_VERSION</code>), 当应用版本号变动时缓存被清空. 要想在应用变更时不清空缓存传入一个<strong>固定值</strong>便可</li>
<li>第四行是 <code>valueCount</code>, 代表的是一个 <code>Node</code> 结点对应的是几个数据节点. 上面的是 <strong>两</strong> 个</li>
<li>第五行是一个空行分隔行</li>
<li>主体记录, 格式为 <code>status key value[0].length….value[N - 1].length</code>, 每列值以<strong>空格</strong>分隔</li>
<li><code>status</code> 的值有:<ul>
<li><code>DIRTRY</code> 脏数据, 代表对这条数据进行操作, 每一行 <code>DIRTY</code> 后都应该跟着一条 <code>CLEAN</code> 或者 <code>REMOVE</code>, 代表对数据的操作结束. 如果没有则这条数据为无效数据, 将被删除</li>
<li><code>CLEAN</code> 代表这条数据已经写入到磁盘中, 可以进行读写</li>
<li><code>REMOVE</code> 代表这条数据已经被删除</li>
<li><code>READ</code> 代表读取一条数据</li>
</ul>
</li>
<li><code>status</code> 后面跟着 <code>key</code>, <code>CLEAN</code> 操作后面跟着节点内每条数据的大小, 单位为 <code>byte</code>, 上面例子每个节点有两条. 这些<strong>数据的合</strong>代表当前缓存使用的大小</li>
</ul>
<h4>2.2 缓存文件的内部摘要类 Entry</h4>
<p>与 LruCache 类似, DiskLruCache 也是一个最近访问最多算法, 其类内部也一样持一个 <code>LinkedHashMap</code> 对象 <code>lruEntries</code> 来记录其数据被访问记录, 结构为 <code>&lt;String, DiskLruCache#Entry&gt;</code>, <code>key</code> 是我们传入的, <code>Entry</code> 对象为内部私有类, 记录在磁盘上名为 <code>key</code> 的文件的一些信息. 比如可读, 可写, 对应 <code>key</code> 等</p>
<pre class="highlight line-numbers"><code class="language-java linenums">// DiskLruCache#Entry
private final class Entry {
    // 对应的 key
    private final String key;
    // 节点数据的字节数
    private final long[] lengths;
    // 当一条数据有 CLEAN, 即被写到磁盘里时, 为 true
    private boolean readable;
    // The ongoing edit or null if this entry is not being edited.
    private Editor currentEditor;
    // The sequence number of the most recently committed edit to this entry.
    private long sequenceNumber;

    /* ... */

    // 一个 node 对应多个数据时, 是以 key.i 的格式为名字来保存文件
    public File getCleanFile(int i) {
        return new File(directory, key + "." + i);
    }

    public File getDirtyFile(int i) {
        return new File(directory, key + "." + i + ".tmp");
    }
}</code></pre>

<h4>2.3 打开缓存</h4>
<p>DiskLruCache 的构造方法是 <code>private</code> 的, 通过静态方法 <code>DiskLruCache#open()</code> 来创建一个缓存对象. 构造方法只是简单的保存了一些属性值. 而 <code>open()</code> 方法里对 journal 文件进行了判断和验证</p>
<p>创建缓存方法</p>
<pre class="highlight line-numbers"><code class="language-java linenums">// DiskLruCache#open()
public static DiskLruCache open(File directory, int appVersion, int valueCount, 
        long maxSize) throws IOException {
    /* ... */   
    // prefer to pick up where we left off
    DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, 
            maxSize);
    // 如果已经存在了 journal 文件, 读取头部进行对比
    // 对比失败会删除该缓存目录, 然后再重建一个缓存目录
    if (cache.journalFile.exists()) {
        try {
            // 验证头部, 读取日志中的每一行
            // 跳过 REMOVE 记录, 只保存 READ, DIRTY, CLEAN. 到 LinkedHashMap 中
            // CLEAN 设置 readable = true, 节点每个数据的大小到 lenghts 数组
            // DIRTY 设置 currentEditor = new Editor(entry)
            // READ 不作改变
            cache.readJournal();
            // 
            cache.processJournal();
            cache.journalWriter = new BufferedWriter(
                    new FileWriter(cache.journalFile, true), IO_BUFFER_SIZE);
            return cache;
        } catch (IOException journalIsCorrupt) {
            cache.delete();
        }
    }

    // create a new empty cache
    directory.mkdirs();
    cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);
    cache.rebuildJournal();
    return cache;
}</code></pre>

<p><code>open()</code> 里即使传入的目录不存在, DiskLruCache 也是会帮我们重建一个缓存目录的. </p>
<pre class="highlight line-numbers"><code class="language-java linenums">// DiskLruCache#rebuildJournal()
private synchronized void rebuildJournal() throws IOException {
    if (journalWriter != null) {
        journalWriter.close();
    }

    // 使用临时 journal 文件来重建缓存, 重建完成后再更名为正式的 journal 文件名
    // 按格式写入头部
    /* ... */

    // 将内存中已经读取的缓存记录写到文件里
    for (Entry entry : lruEntries.values()) {
        if (entry.currentEditor != null) {
            writer.write(DIRTY + ' ' + entry.key + '\n');
        } else {
            writer.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n');
        }
    }
    // 关闭文件, 重命名, 将 journalWriter 指向新文件
    writer.close();
    journalFileTmp.renameTo(journalFile);
    journalWriter = new BufferedWriter(new FileWriter(journalFile, true), IO_BUFFER_SIZE);
}</code></pre>

<p><code>readJournal()</code>, <code>readJournalLine()</code>, <code>processJournal()</code> 这三个方法是重要的操作 journal 文件的方法. <code>readJournal()</code> 处理好正确的头部匹配, 然后调用  <code>readJournalLine()</code> 来读取每一行主体内容. 处理的步骤为: 
1. 每读到一个 REMOVE 就删除 <code>lruEntries</code> 里对应 key 的 entry
2. 如果这一行不为 REMOVE, 并且其不在 <code>lruEntries</code> 里, 就将为其创建一个 entry 加入到链表中
3. 如果这一行为 CLEAN, 那表示这条数据已确保写到磁盘了, 设置为 <code>readable = true</code>, <code>currentEditor = null</code>, 并将该节点的数据大小进行保存
4. 如果这一行为 DIRTY, 表示这条数据有过编辑(<code>DiskLruCache#.edit()</code>), 为其创建一个编辑器
5. 如果这一行为 READ, 已经在 2 里处理过了</p>
<p>这样就处理了所有的标记符. 在 <code>processJournal()</code> 方法里, 删除掉 DIRTY 记录. 因为一条 DIRTY 只对应一条 CLEAN 或 REMOVE, REMOVE 对应的 DIRTY 我们已经在第一次读到时已经删除过. 另外在每次读到 CLEAN 时, 我们都会把其对应的 DIRTY 的 <code>currentEditor</code> 设置为 <code>null</code>, 所以只要查找 <code>currentEditor = null</code> 记录便可</p>
<pre class="highlight line-numbers"><code class="language-java linenums">// DiskLruCache#readJournal()
// 这个方法主要是验证头部正确后, 把日志时的每条记录都读到 lruEntries 中
private void readJournal() throws IOException {
    InputStream in = new BufferedInputStream(new FileInputStream(journalFile), IO_BUFFER_SIZE);
    try {
        // 验证头部, 每次读一行, 分别与传入的值对比
        /* ... */

        // 如果头部无误, 将除 REMOVE 之外的记录读到 lruEntries 中
        int lineCount = 0;
        while (true) {
            try {
                readJournalLine(readAsciiLine(in));
                lineCount++;
            } catch (EOFException endOfJournal) {
                break;
            }
        }
        redundantOpCount = lineCount - lruEnties.size();
    } finally {
        closeQuietly(in);
    }
}


// DiskLruCache#readJournalLine()
private void readJournalLine(String line) throws IOException {
    String[] parts = line.split(" ");
    if (parts.length &lt; 2) {
        throw new IOException("unexpected journal line: " + line);
    }
    // 当读到 REMOVE 表示我们要删除该条对应的 DIRTY 记录
    String key = parts[1];
    if (parts[0].equals(REMOVE) &amp;&amp; parts.length == 2) {
        lruEntries.remove(key);
        return;
    }
    // 过滤掉 REMOVE 匹配的一次 DIRTY 记录后, 剩下的记录都会读到 lruEntries
    Entry entry = lruEntries.get(key);
    if (entry == null) {
        entry = new Entry(key);
        lruEntries.put(key, entry);
    }

    if (parts[0].equals(CLEAN) &amp;&amp; parts.length == 2 + valueCount) {
        // CLEAN 表示保存了文件, 是可读的
        entry.readable = true;
        entry.currentEditor = null;
        // 设置其节点有多少份数据, copyOfRange 同 Arrays.copyOfRange
        entry.setLengths(copyOfRange(parts, 2, parts.length));
    } else if (parts[0].equals(DIRTY) &amp;&amp; parts.length == 2) {
        // 为 DIRTY 记录设置一个可写对象
        entry.currentEditor = new Editor(entry);
    } else if (parts[0].equals(READ) &amp;&amp; parts.length == 2) {
        // this work was already done by calling lruEntries.get()
    } else {
        throw new IOException("unexpected journal line: " + line);
    }
}


// DiskLruCache#processJournal()
// 再把日志的数据都读到 lruEntries 后, 删除其中的 DIRTY 数据
// 因为每一条 DIRTY 至少匹配 REMOVE
private void processJournal() throws IOException {
    deleteIfExists(journalFileTmp);
    for (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) {
        Entry entry = i.next();
        if (entry.currentEditor == null) {
            // 删除到记录不正确的 DIRTY 后, 才计算现在使用了多少容量
            for (int t = 0; t &lt; valueCount; t++) {
                size += entry.lengths[t];
            }
        } else {
            // 删除 DIRTY 记录
            entry.currentEditor = null;
            for (int t = 0; t &lt; valueCount; t++) {
                deleteIfExists(entry.getCleanFile(t));
                deleteIfExists(entry.getDirtyFile(t));
            }
            i.remove();
        }
    }
}</code></pre>

<h4>2.4 写入缓存</h4>
<p>在将日志记录读到 <code>lruEntries</code> 后, 便可以进行读写操作. 写操作是获得一个 <code>DiskLruCache#Editor</code> 对象.</p>
<pre class="highlight line-numbers"><code class="language-java linenums">private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
    // 检测文件没有关闭和 key 的有效性, 不能包含空格和换行: ' ', '\r', '\n'
    checkNotClosed();
    validateKey(key);
    // lruEntries 中取出该记录, 如果不为 null, 说明不是新记录; 并且如果其
    // 保存了 currentEditor 的话说明有其他线程在编辑, 因为我们会把完成的 DIRTY 记录
    // 从 lruEntries 中删除掉
    Entry entry = lruEntries.get(key);
    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER
            &amp;&amp; (entry == null || entry.sequenceNumber != expectedSequenceNumber)) {
        return null; // snapshot is stale
    }
    // 这里要注意如果我们获取了一次 Editor 对象, 再次获取前没有 commit/abort 操作则返回 null
    if (entry == null) {
        entry = new Entry(key);
        lruEntries.put(key, entry);
    } else if (entry.currentEditor != null) {
        return null; // another edit is in progress
    }
    // 获取一个新的编辑状态
    Editor editor = new Editor(entry);
    entry.currentEditor = editor;

    // 写入 DIRTY 状态
    journalWriter.write(DIRTY + ' ' + key + '\n');
    journalWriter.flush();
    return editor;
}</code></pre>

<p>在拿到 <code>Editor</code> 对象之后, 便可以获得输出流, 将图片之类写到磁盘作缓存. </p>
<pre class="highlight line-numbers"><code class="language-java linenums">public final class Editor {
    private final Entry entry;
    private boolean hasErrors;

    // 返回的是一个 FilterOutputStream, 如果出错就把标志位 hasErrors 设为 true
    // 在写完后 commit 时检查标志位, 有错误会放弃该缓存
    public OutputStream newOutputStream(int index) throws IOException {
        synchronized (DiskLruCache.this) {
            if (entry.currentEditor != this) {
                throw new IllegalStateException();
            }
            // FileOutputStream 会帮我们自动创建文件
            return new FaultHidingOutputStream(
                    new FileOutputStream(entry.getDirtyFile(index)));
        }
    }

    /* ... */
}</code></pre>

<p>调用 <code>DiskLruCache.Editor#commit()</code> 时会调用 <code>DiskLruCache#completeEdit()</code> 完成最终编辑</p>
<pre class="highlight line-numbers"><code class="language-java linenums">private synchronized void completeEdit(Editor editor, boolean success) 
        throws IOException {
        // 检查 DIRTY 文件是否创建了
        if (success &amp;&amp; !entry.readable) {
            for (int i = 0; i &lt; valueCount; i++) {
                if (!entry.getDirtyFile(i).exists()) {
                    editor.abort();
                    throw new IllegalStateException("edit didn't create file " + i);
                }
            }
        }
        // 重命名文件, 减去老的缓存大小
        for (int i = 0; i &lt; valueCount; i++) {
            File dirty = entry.getDirtyFile(i);
            if (success) {
                if (dirty.exists()) {
                    File clean = entry.getCleanFile(i);
                    dirty.renameTo(clean);
                    long oldLength = entry.lengths[i];
                    long newLength = clean.length();
                    entry.lengths[i] = newLength;
                    size = size - oldLength + newLength;
                }
            } else {
                deleteIfExists(dirty);
            }
        }
        // 操作行数增加 1
        redundantOpCount++;
        // 操作完成时重置为 null
        entry.currentEditor = null;
        if (entry.readable | success) {
            entry.readable = true;
            journalWriter.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n');
            if (success) {
                // sequenceNumber 用来记录该 entry 是否过期, 在获取 Shapshot 时会与
                // entry.sequenceNumber 对比, 如果不相等则是过期的
                entry.sequenceNumber = nextSequenceNumber++;
            }
        } else {
            lruEntries.remove(entry.key);
            journalWriter.write(REMOVE + ' ' + entry.key + '\n');
        }
        // 判断是否超出设定的缓存容量, 是否操作行数记录大于 2000, 
        // 或者 redundantOpCount &gt; lruEntries.size()
        // 以便来决定是否在释放一些缓存
        if (size &gt; maxSize || journalRebuildRequired()) {
            executorService.submit(cleanupCallable);
        }
    }</code></pre>

<h4>2.5 读取缓存</h4>
<p>通过 <code>DiskLruCache#get()</code> 获得一个 <code>Snapshot</code> 缓存对象. 该对象主要是 <code>InputStream</code> 的再封装</p>
<pre class="highlight line-numbers"><code class="language-java linenums">// DiskLruCache#get
public synchronized Snapshot  (String key) throws IOException {
    // 检查文件是否打开, key 是否正确
    /* ... */

    // 一次性打开所有的数据以保证一个 key 即使对应多个数据也只有一个 snapshot
    InputStream[] ins = new InputStream[valueCount];
    try {
        for (int i = 0; i &lt; valueCount; i++) {
            ins[i] = new FileInputStream(entry.getCleanFile(i));
        }
    } catch (FileNotFoundException e) {
        // a file must have been deleted manually!
        return null;
    }
    // 记录操作数, 写入操作记录, 之后要再检查操作记录是否超出设定
    redundantOpCount++;
    journalWriter.append(READ + ' ' + key + '\n');
    if (journalRebuildRequired()) {
        executorService.submit(cleanupCallable);
    }

    return new Snapshot(key, entry.sequenceNumber, ins);
}</code></pre>

<h4>2.6 删除缓存</h4>
<p>每次读, 写, 删除缓存后, 都要再次判断操作记录或者缓存大小已经超出设置的值. 删除操作主要是由一个</p>
<pre class="highlight line-numbers"><code class="language-java linenums">// 调用 remove
// DiskLruCache#remove
public synchronized boolean remove(String key) throws IOException {
    checkNotClosed();
    validateKey(key);
    Entry entry = lruEntries.get(key);
    if (entry == null || entry.currentEditor != null) {
        return false;
    }
    // 删除对应 key 的所有文件
    for (int i = 0; i &lt; valueCount; i++) {
        File file = entry.getCleanFile(i);
        if (!file.delete()) {
            throw new IOException("failed to delete " + file);
        }
        size -= entry.lengths[i];
        entry.lengths[i] = 0;
    }
    // 是否要重建 journal 文件
    redundantOpCount++;
    journalWriter.append(REMOVE + ' ' + key + '\n');
    lruEntries.remove(key);

    if (journalRebuildRequired()) {
        executorService.submit(cleanupCallable);
    }

    return true;
}

private final ExecutorService executorService = new ThreadPoolExecutor(0, 1, 60L,
        TimeUnit.SECONDS, new LinkBlockingQueue&lt;Runnable&gt;());
private final Callable&lt;Void&gt; cleanupCallable = new Callable&lt;&gt;() {
    @Override
    public Void call() throw Exception {
        synchronized (DiskLruCache.this) {
            if (journalWriter == null) {
                return null;
            }
            trimeToSize();
            if (journalRebuildRequired()) {
                rebuildJournal();
                redundantOpCount = 0;
            }
            return null;
        }
    }
};

private void trimToSize() throws IOException {
    // 循环迭代删除超出的空间
    while (size &gt; maxSize) {
        final Map.Entry&lt;String, Entry&gt; toEvict = 
            lruEntries.entrySet().iterator.next();
        remove(toEvict.getKey());
    }
}</code></pre>

<h3>Reference</h3>
<ol>
<li>&lt;<Android开发艺术探索>&gt;</li>
<li><a href="https://blog.csdn.net/shakespeare001/article/details/51695358">https://blog.csdn.net/shakespeare001/article/details/51695358</a></li>
<li><a href="https://www.jianshu.com/p/b282140acc20">https://www.jianshu.com/p/b282140acc20</a></li>
<li><a href="http://nirvanawoody.com/2016/05/05/Android-DiskLruCache">http://nirvanawoody.com/2016/05/05/Android-DiskLruCache</a></li>
</ol>

                <hr style="visibility: hidden;">
                <ul class="pager">
                </ul>
                <hr style="visibility: hidden;">

                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
            </div>  
        </div>
    </article>
</div>

 
        
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->

                <p class="copyright text-muted">
                    Copyright &copy; Ambertime 2019                    <br>
                    Powered by <a href="http://getpelican.com/">Pelican</a> | Theme by <a href="http://huangxuan.me">HuxPro</a>
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=ivicel&repo=ivicel.github.io&type=star&count=true" >
                    </iframe>
                    
                </p>
            </div>
        </div>
    </div>
</footer> 
        
        <script src="https://ivicel.info/theme/js/jquery.min.js"></script>
        <script src="https://ivicel.info/theme/js/bootstrap.min.js"></script>
        <script src="https://ivicel.info/theme/js/prism.js"></script>
        <script src="https://ivicel.info/theme/js/hux-blog.min.js"></script>
        <script src="https://ivicel.info/theme/js/snackbar.js"></script>
        <script src="https://ivicel.info/theme/js/sw-registration.js"></script>
        <!--fastClick.js -->
        <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
                TeX: {
                equationNumbers: {
                    autoNumber: "AMS"
                }
                },
                tex2jax: {
                inlineMath: [ ['$','$'] ],
                displayMath: [ ['$$','$$'] ],
                processEscapes: true,
                }
            });
            </script>
        <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <!-- Google Analytics -->
        <script>
            var _gaId = "UA-113622715-2";
            var _gaDomain = "https://ivicel.info";

            // Originial
            (function(i, s, o, g, r, a, m) {
                i["GoogleAnalyticsObject"] = r;
                (i[r] =
                    i[r] ||
                    function() {
                        (i[r].q = i[r].q || []).push(arguments);
                    }),
                    (i[r].l = 1 * new Date());
                (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
                a.async = 1;
                a.src = g;
                m.parentNode.insertBefore(a, m);
            })(
                window,
                document,
                "script",
                "//www.google-analytics.com/analytics.js",
                "ga"
            );

            ga("create", _gaId, _gaDomain);
            ga("send", "pageview");
        </script>

<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'ambertime';
    var disqus_config = function () {
        this.page.url = 'https://ivicel.info/2018/04/android-ying-pan-huan-cun-disklruccache.html';
        this.page.identifier = 'Android 硬盘缓存 DiskLrucCache';
        this.page.title = 'Android 硬盘缓存 DiskLrucCache';
    };

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//ambertime.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<!-- disqus 公共JS代码 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js"></script>
    </body>
</html>