<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Ambertime - misc</title><link href="https://ivicel.info/" rel="alternate"></link><link href="https://ivicel.info/feeds/misc.atom.xml" rel="self"></link><id>https://ivicel.info/</id><updated>2019-05-04T00:00:00+08:00</updated><subtitle>Make memory in past times</subtitle><entry><title>Spring Flasky 开发(三)</title><link href="https://ivicel.info/2019/05/spring-flasky-kai-fa-san.html" rel="alternate"></link><published>2019-05-04T00:00:00+08:00</published><updated>2019-05-04T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2019-05-04:/2019/05/spring-flasky-kai-fa-san.html</id><summary type="html">&lt;h3&gt;1. XSS 保护&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;不要相信用户每一个输入&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们需要对用户写的 post 进行过滤, 以避免 XSS 攻击. 其他的因为 Thymeleaf 默认输出都是 escape 的, 所以我们不需要对像个人 Profile 的信息输入进行过滤. &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 这里设置一些支持的标签, 比如 span, p, h* 之类
private static final PolicyFactory POLICY_FACTORY = new HtmlPolicyBuilder()
        .allowElements(Const.ALLOWED_HTML_TAG).toFactory();

public static String sanitize(final String text) {
    return POLICY_FACTORY.sanitize(text);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们自定义一个 &lt;code&gt;EntityEventListener&lt;/code&gt;, 在保存 post …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;1. XSS 保护&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;不要相信用户每一个输入&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们需要对用户写的 post 进行过滤, 以避免 XSS 攻击. 其他的因为 Thymeleaf 默认输出都是 escape 的, 所以我们不需要对像个人 Profile 的信息输入进行过滤. &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 这里设置一些支持的标签, 比如 span, p, h* 之类
private static final PolicyFactory POLICY_FACTORY = new HtmlPolicyBuilder()
        .allowElements(Const.ALLOWED_HTML_TAG).toFactory();

public static String sanitize(final String text) {
    return POLICY_FACTORY.sanitize(text);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们自定义一个 &lt;code&gt;EntityEventListener&lt;/code&gt;, 在保存 post 到数据库之前对 markdown 和 HTML 过滤.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public class SanitizerListener {
    // 在新插入, 和更新前调用
    @PrePersist
    @PreUpdate
    public void sanitize(Object object) {
        try {
            // 通过反射查找到实体类中被 Sanitize 注解标记的成员变量
            // Sanitize 是自定义的一个注解
            Field[] fields = object.getClass().getDeclaredFields();
            for (Field field : fields) {
                if (field.getAnnotation(Sanitize.class) != null) {
                    // 只支持字符类型
                    log.error(field.getType().toString());
                    if (!CharSequence.class.isAssignableFrom(field.getType())) {
                        log.warn("Annotation @Sanitize only support string field.");
                        continue;
                    }
                    // 通过 bean 反省拿到变量的值, 调用过滤方法后再将值写回
                    PropertyDescriptor descriptor = new PropertyDescriptor(field.getName(), object.getClass());
                    String text = (String) descriptor.getReadMethod().invoke(object);
                    text = CommonUtil.sanitize(text);
                    Method writeMethod = descriptor.getWriteMethod();
                    writeMethod.invoke(object, text);
                }
            }
        } catch (IntrospectionException | IllegalAccessException | InvocationTargetException e) {
            log.error("can't sanitize {}: {}", object, e.getMessage());
        }
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们只需要在实体类 &lt;code&gt;Post&lt;/code&gt; 和 &lt;code&gt;Comment&lt;/code&gt; 上加上注解事件, 在成员变量上加入标记注解 &lt;code&gt;@Sanitize&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;@EntityListeners({SanitizerListener.class})
public class Post extends BaseDomain implements Serializable {
    @Sanitize
    private String body;

    @Sanitize
    private String bodyHtml;    
}

@EntityListeners(SanitizerListener.class)
public class Comment extends BaseDomain implements Serializable {
    @Sanitize
    private String body;

    @Sanitize
    private String bodyHtml;
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2. 原生 &lt;code&gt;HttpServletResponse&lt;/code&gt; 对象返回 Thymeleaf 模版&lt;/h3&gt;
&lt;p&gt;在登录失败时, 我们会提醒返回用户名或密码错误的提示&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public class LoginFailureHandler implements AuthenticationFailureHandler {
    @Override
    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,
            AuthenticationException exception) throws IOException, ServletException {
        // 获取 Thymeleaf 模版上下文
        WebContext ctx = new WebContext(request, response, request.getServletContext(), request.getLocale());
        // 设置返回 status code
        response.setStatus(HttpStatus.NOT_FOUND.value());
        // 把原用户的输入填回模版中, 避免用户再次输入
        LoginDTO user = new LoginDTO();
        user.setUsername(request.getParameter("username"));
        user.setPassword(request.getParameter("password"));
        user.setRememberMe(request.getParameter("rememberMe") != null);
        ctx.setVariable("user", user);
        ctx.setVariable("msg", "username or password error.");
        ctx.setVariable("classappend", "alert-warning");
        // 当加入 Thymeleaf 依赖时, 自动配置模版处理引擎 bean
        templateEngine.process("auth/login", ctx, response.getWriter());
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;项目地址: &lt;a href="https://github.com/ivicel/spring-flasky"&gt;https://github.com/ivicel/spring-flasky&lt;/a&gt;&lt;/p&gt;</content><category term="spring boot"></category><category term="flasky"></category></entry><entry><title>Spring Flasky 开发(二)</title><link href="https://ivicel.info/2019/05/spring-flasky-kai-fa-er.html" rel="alternate"></link><published>2019-05-03T00:00:00+08:00</published><updated>2019-05-03T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2019-05-03:/2019/05/spring-flasky-kai-fa-er.html</id><summary type="html">&lt;h3&gt;1. 注册功能&lt;/h3&gt;
&lt;p&gt;注册需要 4 个字段, 分别是 &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt;, &lt;code&gt;password&lt;/code&gt;, &lt;code&gt;confirmPassword&lt;/code&gt;, 注册的 &lt;code&gt;username&lt;/code&gt; 和 &lt;code&gt;email&lt;/code&gt; 都是惟一的, 需要从库查找. 两次输入的密码需要相同, 这里自己定义了一个注解约束, 然后实现 ConstraintValidator 接口&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 这个注解作用于类上面, 目标是字段 first 的值要等于字段 second
@Retention(RUNTIME)
@Target(value = {TYPE, ANNOTATION_TYPE})
// 约束的具体实现类
@Constraint(validatedBy = EqualsMatchValidator.class)
public @interface EqualsMatch {
    String first();

    String second();

    String message() default "{first} not equals …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;h3&gt;1. 注册功能&lt;/h3&gt;
&lt;p&gt;注册需要 4 个字段, 分别是 &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt;, &lt;code&gt;password&lt;/code&gt;, &lt;code&gt;confirmPassword&lt;/code&gt;, 注册的 &lt;code&gt;username&lt;/code&gt; 和 &lt;code&gt;email&lt;/code&gt; 都是惟一的, 需要从库查找. 两次输入的密码需要相同, 这里自己定义了一个注解约束, 然后实现 ConstraintValidator 接口&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 这个注解作用于类上面, 目标是字段 first 的值要等于字段 second
@Retention(RUNTIME)
@Target(value = {TYPE, ANNOTATION_TYPE})
// 约束的具体实现类
@Constraint(validatedBy = EqualsMatchValidator.class)
public @interface EqualsMatch {
    String first();

    String second();

    String message() default "{first} not equals {second}";

    Class&amp;lt;?&amp;gt;[] groups() default {};

    Class&amp;lt;? extends Payload&amp;gt;[] payload() default {};


    @Documented
    @Target(value = {TYPE, ANNOTATION_TYPE})
    @Retention(RUNTIME)
    @interface List {
        EqualsMatch[] value();
    }
}

public class EqualsMatchValidator implements ConstraintValidator&amp;lt;EqualsMatch, Object&amp;gt; {
    // 字段一名称
    private String firstFieldName;
    // 字段二名称
    private String secondFieldName;

    @Override
    public void initialize(EqualsMatch constraintAnnotation) {
        firstFieldName = constraintAnnotation.first();
        secondFieldName = constraintAnnotation.second();
    }

    // 返回 false 则为不相等, 反之亦然
    @Override
    public boolean isValid(Object value, ConstraintValidatorContext context) {
        // 通过 java bean 反省拿到两个字段的值
        String first = getField(value, firstFieldName);
        String second = getField(value, secondFieldName);
        // 两个都为 null 时
        if (first == null) {
            return second == null;
        }

        return first.equals(second);
    }

    private String getField(Object obj, String name) {
        try {
            PropertyDescriptor descriptor = new PropertyDescriptor(name, obj.getClass());
            Method method = descriptor.getReadMethod();
            return (String) method.invoke(obj);
        } catch (IntrospectionException | IllegalAccessException | InvocationTargetException e) {
            return null;
        }
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2. 登录功能&lt;/h3&gt;
&lt;p&gt;权限控制保护使用的是 Spring Security, 添加 Spring Security 依赖后, 使我们的 &lt;code&gt;User&lt;/code&gt; 类实现 &lt;code&gt;UserDetails&lt;/code&gt;, 这是 Spring Security 内置的用户接口, Spring Security 会使用其实现来查找用户的权限认证(Authorization), 以及身份认证(Authentication), 现在我们只需根据数据库中的 &lt;code&gt;confirmed&lt;/code&gt; 字段来判断用户是否激活了其邮箱, 所以其他的判断都返回 &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要注意的是 Spring Security 使用的原生的 Servlet Filter 来拦截 request, 有一套自己的拦截顺序, 并不依赖 Spring MVC 框架, 所以如果请求被拦截并不会到达 DispatcherServlet 派发给我们的 Controller&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public class User implements UserDetails {
    // 用户的角色集合, 这里我们只有一个, 简单的返回一个 singleton 集合
    @Override
    public Collection&amp;lt;? extends GrantedAuthority&amp;gt; getAuthorities() {
        return Collections.singleton(role);
    }

    // 帐号是否非过期
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    // 帐号是否非锁定
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    // 认证是否非过期
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    // 帐号是否已启用
    @Override
    public boolean isEnabled() {
        return true;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来是实现一个用户查询, 我们想要的是, 当用户登录时, 会去数据库中查找这个用户, 如果存在返回其信息包装成一个 &lt;code&gt;UserDetails&lt;/code&gt;, 然后对比其密码. 我们在 &lt;code&gt;UserServiceImpl&lt;/code&gt; 中实现这个接口&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;@Service("userService")
public class UserServiceImpl implements UserService, UserDetailsService {

    @Override
    public UserDetails loadUserByUsername(String username) 
            throws UsernameNotFoundException {
        Optional&amp;lt;User&amp;gt; user;
        // 根据用户使用的是邮箱还是帐户名登录来查找出
        if (emailPattern.matcher(username).matches()) {
            user = findByEmail(username);
        } else {
            user = findByUsername(username);
        }
        // 帐号不存在
        if (!user.isPresent()) {
            throw new UsernameNotFoundException(String.format("username of %s not found", username));
        }

        return user.get();
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Spring Security 会自动的调用我们上面的实现, 返回 &lt;code&gt;UserDetails&lt;/code&gt;. 然后对 password 进行对比.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring Security 默认所有的 POST 方法都是有 CSRF 保护&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新建一个类继承 &lt;code&gt;WebSecurityConfigurerAdapter&lt;/code&gt;, 在这里配置登录以及一些拦截, 使用 &lt;code&gt;@EnableGlobalMethodSecurity(prePostEnabled = true)&lt;/code&gt; 开启 post 请求之前的方法保护, 使用 &lt;code&gt;@PreAuthorize&lt;/code&gt; 注解, 这使得我们可以保护一些必要的方法, 比如发表 post 必须要先行登录.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 不要让系统自动配置 
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // 登录与登出保护, 已登录的不要重复登录, 未登录的不能登出
        // 因为我们使用的是内置 login, logout 拦截, 所以 post 不用自己写 controller
        http.authorizeRequests()
            .antMatchers("/auth/login")
            .access("not @webAuth.loginRequired(authentication)")
            .antMatchers("/auth/logout")
            .access("@webAuth.loginRequired(authentication)");

        // 403 handler
        http.exceptionHandling().accessDeniedHandler(accessDeniedHandler);

        // other urls, 其他 url 都允许
        http.authorizeRequests().anyRequest().permitAll();

        // custom form login, logout
        http.formLogin()
            // 自定义的登录页面, 默认的字段是 username, password
            .loginPage("/auth/login")
            // 登录失败时, 返回用户名或密码错误, 不要返回详细信息, 避免猜解
            .failureHandler(loginFailureHandler)
            // 登录成功后的跳转, 更新最后可见信息等
            .successHandler(loginSuccessHandler)
            .and()
            .logout()
            // 登出控制, 自定义登录 url
            .logoutUrl("/auth/logout")
            // 因为登出是被 filter 拦截的, 并且默认是 POST, 
            // 所以在这给客户端返回一个 JSON, 并给出跳转 url, 由客户端重定向
            .logoutSuccessHandler((request, response, authentication) -&amp;gt; {
                    response.setStatus(HttpStatus.OK.value());
                    response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);
                    Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
                    map.put("url", request.getContextPath() + "/");
                    new ObjectMapper().writeValue(response.getWriter(), map);
                })
            // 清除 sesssion 及 cookie 信息
            .clearAuthentication(true).invalidateHttpSession(true)
            .and().rememberMe();
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        // 配置我们的登录查询
        // 这里配置后, 登录时系统会查询数据库, 取出匹配数据, 把发送过来的密码
        // 使用 passswordEncoder 加密后, 与库中字段对比
        auth.userDetailsService(userService).passwordEncoder(passwordEncoder);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里, 我们自定义了一个 Bean 用来处理一些常用到的认证, 比如是否登录, 是否是该帐号等, 自定义 &lt;a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#el-access-web-beans"&gt;Security Bean&lt;/a&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public class WebSecurityAuth {
    // 修改 post 的权限, 本人和管理员都可
    public boolean canModfiyPost(Authentication auth, Post post) {
        // check anonymous
        if (auth == null || !(auth.getPrincipal() instanceof User)) {
            return false;
        }

        return hasPermission(auth, Permission.ADMIN) ||
                (post.getAuthor().equals(auth.getPrincipal()) &amp;amp;&amp;amp; hasPermission(auth, Permission.WRITE));
    }

    // 修改一些普通个人信息, moderator, 本人, admin
    public boolean canEditProfile(Authentication auth, String username) {
        if (!(auth instanceof User)) {
            return false;
        }

        return auth.getName().equals(username) ||
                AuthorityUtils.authorityListToSet(
            auth.getAuthorities()).contains("ROLE_ADMIN") ||
                AuthorityUtils.authorityListToSet(
            auth.getAuthorities()).contains("ROLE_MODERATOR");
    }

    // 需要登录才可查看
    public boolean loginRequired(Authentication auth) {
        return auth.getPrincipal() instanceof User;
    }

    // 帐户是否激活
    public boolean isConfirmed(Authentication auth) {
        if (auth == null || !(auth.getPrincipal() instanceof User)) {
            return false;
        }

        return ((User) auth.getPrincipal()).isConfirmed();
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;我们的好多认证都是在 Session 里查找的, 这就要求我们保持同步 Session 里的信息和数据库一样, 比如注册后, 我们是在 A 浏览器里登录, 在 B 里确认了邮箱链接, 那么在确认后, 我们只更改数据库里的字段, 但 A 浏览器使用的是 Session 里的信息, 只能重新登录. 一是要么只使用 &lt;code&gt;Authentication&lt;/code&gt; 里的 username, 总是去数据库中查找相应数据, 二是要么建立一种 Sync 机制, 要修改数据后将数据同步到 Session Cache 中. Spring Security 没有提供这样同步机制, 因为这机制强烈依赖具体业务, 多久同步, 同步及时或失败是否影响到了业务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;3. 邮件发送&lt;/h3&gt;
&lt;p&gt;我们使用的是 &lt;code&gt;OhMyEmail&lt;/code&gt; 简单邮件发送系统, 基于 SMTP. 因为我们没有使用 spring-boot-mail, 所以 email 的自动配置并不会启动, 首先在设置启动 &lt;code&gt;@EnableConfigurationProperties({MailProperties.class})&lt;/code&gt;, 用来接收 &lt;code&gt;spring.mail&lt;/code&gt; 的配置, 然后在 &lt;code&gt;WebConfig&lt;/code&gt; 里设置 &lt;code&gt;OhMyEmail&lt;/code&gt; 的配置&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;@Configuration
public class WebConfig {
    // 依赖内置的 MailProperties
    private MailProperties mailProperties;

    @PostConstruct
    public void initEmail() {
        Properties props = new Properties();
        // 配置用户名, 密码, host, 端口, 和其他的一些配置, 之后使用静态的 builder 即可
        props.setProperty("username", mailProperties.getUsername());
        props.setProperty("password", mailProperties.getPassword());
        props.setProperty("mail.smtp.host", mailProperties.getHost());
        props.setProperty("mail.smtp.port", String.valueOf(mailProperties.getPort()));
        props.putAll(mailProperties.getProperties());

        OhMyEmail.config(props);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4. 自定义的权限检查&lt;/h3&gt;
&lt;p&gt;如果我们定义一个 Bean, 其实现了 &lt;code&gt;PermissionEvaluator&lt;/code&gt;, Spring 会自动扫描到这个 Bean 将其用作 &lt;code&gt;hasPermission&lt;/code&gt; 的检查实现.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public class WebPermissionEvalutor implements PermissionEvaluator {
    // targetDomainObject 一般传进来的是一个 entity, 以检查是否有操作该 entity 的权限
    @Override
    public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) {
        // 这里我们并用不到 targetDomainObject
        // 我们传进来的是一个 Permission 对象
        if (!(permission instanceof Permission) || authentication == null ||
                !(authentication.getPrincipal() instanceof User)) {
            return false;
        }

        User currentUser = (User) authentication.getPrincipal();

        return currentUser.can((Permission) permission);
    }

    @Override
    public boolean hasPermission(Authentication authentication, Serializable targetId, String targetType,
            Object permission) {
        return false;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;5. Spring Security Authorize&lt;/h3&gt;
&lt;p&gt;如果我们需要在普通类中使用 &lt;code&gt;Authentication&lt;/code&gt; 对象, 可以使用 &lt;code&gt;org.springframework.security.core.context.SecurityContextHolder&lt;/code&gt; 来获取&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;Authentication auth = SecurityContextHolder.getContext().getAuthentication();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;@PreAuthorize&lt;/code&gt; 和 &lt;code&gt;@PostAuthorize&lt;/code&gt; 分别是在调用方法前和方法后的认证. 支持 SpEL 表达式, 比如我们可以在用户发表新的 Post 前这样判断当前用户是否有写权限&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;@PostMapping
@PreAuthorize("hasPermission(null, T(info.ivicel.springflasky.web.model.Permission).WRITE)")
public ResponseEntity addNewPost(Authentication auth, @Validated PostDTO postDto) {
    // ....
}&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;参考 &lt;a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#jc-method"&gt;Method Security&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于 &lt;code&gt;hasRole(…)&lt;/code&gt; 这样的角色检查, 我们在实体类 &lt;code&gt;Role&lt;/code&gt; 实现了 &lt;code&gt;GrantedAuthority&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public class Role extends BaseDomain implements GrantedAuthority {
    @Override
    public String getAuthority() {
        // 默认检查有前缀 'ROLE_'
        return "ROLE_" + name.toUpperCase();
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;项目地址: &lt;a href="https://github.com/ivicel/spring-flasky"&gt;https://github.com/ivicel/spring-flasky&lt;/a&gt;&lt;/p&gt;</content><category term="spring boot"></category><category term="flasky"></category></entry><entry><title>Spring Flasky 开发(一)</title><link href="https://ivicel.info/2019/05/spring-flasky-kai-fa-yi.html" rel="alternate"></link><published>2019-05-02T00:00:00+08:00</published><updated>2019-05-02T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2019-05-02:/2019/05/spring-flasky-kai-fa-yi.html</id><summary type="html">&lt;h3&gt;1. 项目说明&lt;/h3&gt;
&lt;p&gt;Flasky 是 &lt;a href="https://book.douban.com/subject/26274202/"&gt;Flask Web Development&lt;/a&gt; 里的一个实例项目, 原项目是使用 Python 开发了, 一个类似微博的小型项目, 我用 Spring Boot 重写了一个
实现了里面提到了主要功能:&lt;/p&gt;
&lt;ul class="task-list"&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" disabled checked/&gt; Post 分页, 及在登录后查看关注的人发的 Post&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" disabled checked/&gt; 帐号注册, 登录, 发 Post, 对他人 Post 的评论&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" disabled checked/&gt; 个人信息页&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" disabled checked/&gt; 权限系统, 帐号角色分配&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" disabled checked/&gt; 邮件发送系统, 通过邮件激活帐号, 重置密码&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" disabled checked/&gt; 关注, 取消关注功能&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" disabled/&gt; Rest API&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. 主要依赖&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Spring Boot&lt;/li&gt;
&lt;li&gt;Spring Security 用于权限控制, 登录&lt;/li&gt;
&lt;li&gt;Spring Data JPA 数据库查询 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h3&gt;1. 项目说明&lt;/h3&gt;
&lt;p&gt;Flasky 是 &lt;a href="https://book.douban.com/subject/26274202/"&gt;Flask Web Development&lt;/a&gt; 里的一个实例项目, 原项目是使用 Python 开发了, 一个类似微博的小型项目, 我用 Spring Boot 重写了一个
实现了里面提到了主要功能:&lt;/p&gt;
&lt;ul class="task-list"&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" disabled checked/&gt; Post 分页, 及在登录后查看关注的人发的 Post&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" disabled checked/&gt; 帐号注册, 登录, 发 Post, 对他人 Post 的评论&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" disabled checked/&gt; 个人信息页&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" disabled checked/&gt; 权限系统, 帐号角色分配&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" disabled checked/&gt; 邮件发送系统, 通过邮件激活帐号, 重置密码&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" disabled checked/&gt; 关注, 取消关注功能&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" disabled/&gt; Rest API&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. 主要依赖&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Spring Boot&lt;/li&gt;
&lt;li&gt;Spring Security 用于权限控制, 登录&lt;/li&gt;
&lt;li&gt;Spring Data JPA 数据库查询 ORM&lt;/li&gt;
&lt;li&gt;Thymeleaf 模版引擎&lt;/li&gt;
&lt;li&gt;MySQL 数据库&lt;/li&gt;
&lt;li&gt;OhMyEmail 最简单邮箱发送系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3. 数据库模型&lt;/h3&gt;
&lt;p&gt;&lt;img alt="flasky 数据库模型" src="../../assets/images/flasky.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;users&lt;/code&gt; 用户表, 有几个冗余的设计, 比如常用到的关注, 被关注数量, 发表 post 数量, 评论数量等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;comments&lt;/code&gt; 评论表, 和 posts, users 都是多对一关系&lt;/li&gt;
&lt;li&gt;&lt;code&gt;roles&lt;/code&gt; 角色权限表, permissions 是一个 32 位的 int, 每位代表一个权限, 默认初始三种角色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;posts&lt;/code&gt; post 内容, 和 users 是多对一关系&lt;/li&gt;
&lt;li&gt;&lt;code&gt;follows&lt;/code&gt; 关注映射表, followed_id, follower_id 都是 users.id, 表 users 是一个自身多对多的关系&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;由于我们需要对 &lt;code&gt;follows&lt;/code&gt; 表添加一些额外的字段, 所以在 Spring JPA 的关系映射中, &lt;code&gt;User&lt;/code&gt; 和 &lt;code&gt;Follow&lt;/code&gt; 这两个实体是一个多对一个关系, 在 &lt;code&gt;User&lt;/code&gt; 实体中, 不再用 &lt;strong&gt;多对多&lt;/strong&gt; 的关系表示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;4. 实体类&lt;/h3&gt;
&lt;p&gt;主要注意要自己定义 follows 表实体类, &lt;code&gt;follower&lt;/code&gt; 是关注者, &lt;code&gt;followed&lt;/code&gt; 是被关注者, 多对多的中间映射表是自己定义的, 所以 &lt;code&gt;User&lt;/code&gt; 中不再定义多对多的映射&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public class Follow extends BaseDomain {

    private static final long serialVersionUID = -119359227790097339L;

    // 两个多对一关系, 一个关注者 id, 一个是被关注者 id
    @ManyToOne
    @JoinColumn(name = "follower_id", foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT))
    private User follower;

    @ManyToOne
    @JoinColumn(name = "followed_id", foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT))
    private User followed;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;User&lt;/code&gt; 中和 &lt;code&gt;Role&lt;/code&gt; 的多对一关系&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public class User {
    @ManyToOne
    @JoinColumn(name = "role_id", nullable = false, foreignKey =       @ForeignKey(NO_CONSTRAINT))
    private Role role;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Post&lt;/code&gt; 和 &lt;code&gt;User&lt;/code&gt; 的多对一关系&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public class Post extends BaseDomain implements Serializable {

    private static final long serialVersionUID = -6830098959594362217L;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false, foreignKey = @ForeignKey(NO_CONSTRAINT))
    private User author;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Comment&lt;/code&gt; 和 &lt;code&gt;User&lt;/code&gt;, &lt;code&gt;Post&lt;/code&gt; 的多对一关系&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public class Comment extends BaseDomain implements Serializable {

    private static final long serialVersionUID = -1029418689058348694L;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false, columnDefinition = "bigint",
            foreignKey = @ForeignKey(NO_CONSTRAINT))
    private User author;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "post_id", nullable = false, columnDefinition = "bigint",
            foreignKey = @ForeignKey(NO_CONSTRAINT))
    private Post post;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义一个 &lt;code&gt;Permission&lt;/code&gt;, 用于映射权限, 当有权限增改时, 修改这个类即可&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public enum Permission {
    /**
     * 关注权限
     */
    FOLLOW(0x01, "FOLLOW"),

    /**
     * 评论权限
     */
    COMMENT(0x02, "COMMENT"),

    /**
     * 写 post 权限
     */
    WRITE(0x04, "WRITE"),

    /**
     * 修改他人信息的权限,
     */
    MODERATE(0x08, "MODERATE"),

    /**
     * 管理员权限
     */
    ADMIN(0xff, "ADMIN");&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;项目地址: &lt;a href="https://github.com/ivicel/spring-flasky"&gt;https://github.com/ivicel/spring-flasky&lt;/a&gt;&lt;/p&gt;</content><category term="spring boot"></category><category term="flasky"></category></entry><entry><title>博客主题的修改</title><link href="https://ivicel.info/2019/05/bo-ke-zhu-ti-de-xiu-gai.html" rel="alternate"></link><published>2019-05-01T00:00:00+08:00</published><updated>2019-05-01T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2019-05-01:/2019/05/bo-ke-zhu-ti-de-xiu-gai.html</id><summary type="html">&lt;p&gt;这个博客是使用 &lt;a href="http://getpelican.com"&gt;Pelican&lt;/a&gt; 搭建了, Pelican 是一个使用了 Python 写的一个静态博客生成框架, 里面使用了 &lt;a href="http://jinja.pocoo.org/"&gt;Jinja2&lt;/a&gt; 作为模版&lt;/p&gt;
&lt;p&gt;最近重新修改了博客主题, 使用了 &lt;a href="http://huangxuan.me/"&gt;HuxPro&lt;/a&gt; 里的样式主题, 原主题里使用的是 &lt;a href="https://jekyllrb.com/"&gt;Jekyll&lt;/a&gt; 生成, 不过其模版写法和 Jinja2 差不多, 自己稍微修改了下, 用 jinja2 重新写了一个&lt;/p&gt;
&lt;p&gt;由于 Pelican 生成的目录结构不同, 其针对 article, archive, category, page, tag 都可以生成单独的页面, 所以在一些内嵌的页面里 (archives), 取巧的使用 ajax 来请求刷新 tag&lt;/p&gt;
&lt;p&gt;由于 Python Markdown 只支持最基本的 Markdown 语法, 所以需要扩展插件, 我使用了 &lt;a href="https://facelessuser.github.io/pymdown-extensions/"&gt;pymdownx&lt;/a&gt;, 这是一个扩展包 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;这个博客是使用 &lt;a href="http://getpelican.com"&gt;Pelican&lt;/a&gt; 搭建了, Pelican 是一个使用了 Python 写的一个静态博客生成框架, 里面使用了 &lt;a href="http://jinja.pocoo.org/"&gt;Jinja2&lt;/a&gt; 作为模版&lt;/p&gt;
&lt;p&gt;最近重新修改了博客主题, 使用了 &lt;a href="http://huangxuan.me/"&gt;HuxPro&lt;/a&gt; 里的样式主题, 原主题里使用的是 &lt;a href="https://jekyllrb.com/"&gt;Jekyll&lt;/a&gt; 生成, 不过其模版写法和 Jinja2 差不多, 自己稍微修改了下, 用 jinja2 重新写了一个&lt;/p&gt;
&lt;p&gt;由于 Pelican 生成的目录结构不同, 其针对 article, archive, category, page, tag 都可以生成单独的页面, 所以在一些内嵌的页面里 (archives), 取巧的使用 ajax 来请求刷新 tag&lt;/p&gt;
&lt;p&gt;由于 Python Markdown 只支持最基本的 Markdown 语法, 所以需要扩展插件, 我使用了 &lt;a href="https://facelessuser.github.io/pymdown-extensions/"&gt;pymdownx&lt;/a&gt;, 这是一个扩展包, 包含了比如基于 js 的语法高亮, ``` 格式的代码标记, 路径转换(这个在写 markdown 时图片和上传后的图片路径不一致时进行转换), todo-list 等等.&lt;/p&gt;
&lt;p&gt;语法高亮使用了&lt;a href="https://prismjs.com/"&gt; prismjs&lt;/a&gt;, 先在 &lt;code&gt;pymdownx.highlight&lt;/code&gt; 里禁用 markdown 使用 pygments 语法高亮, 设置自定义生成 &lt;code&gt;css_class&lt;/code&gt;, 主要是用于生成行号. prismjs 需要在 &lt;code&gt;pre&lt;/code&gt; 标签读取 &lt;code&gt;.line-numbers&lt;/code&gt; 这个 class, 默认只生成 &lt;code&gt;.highlight&lt;/code&gt;, 设置成 &lt;code&gt;highlight line-nubmers&lt;/code&gt; 即可&lt;/p&gt;</content></entry><entry><title>数据库事务并发问题及隔离行为</title><link href="https://ivicel.info/2019/01/shu-ju-ku-shi-wu-bing-fa-wen-ti-ji-ge-chi-xing-wei.html" rel="alternate"></link><published>2019-01-12T00:00:00+08:00</published><updated>2019-01-12T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2019-01-12:/2019/01/shu-ju-ku-shi-wu-bing-fa-wen-ti-ji-ge-chi-xing-wei.html</id><summary type="html">&lt;h4&gt;1. 数据库事务知识&lt;/h4&gt;
&lt;h5&gt;1.1 数据库事务的 4 个基本特征: ACID&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;原子性(Atomic): 一个事务是不可分割的整体, 其内的操作要么全部成功, 要么全部失败.&lt;/li&gt;
&lt;li&gt;一致性(Consistency): 事务确保数据库从一个一致状态转变到另一个一致的状态. 一致状态指的是数据库应满足完整性约束. 比如 A+B 有 1000 元, 在 A 转帐到 B 300 后, 事务完成时, A + B 仍是 1000 元, 这保持了一致性&lt;/li&gt;
&lt;li&gt;隔离性(Isolation): 在多并发执行事务时, 事务与事务之间是隔离开执行的.&lt;/li&gt;
&lt;li&gt;持久性(Durability): 已被提交的了事务对数据库的修改被永久保存在数据库中.&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;1.2 数据库并发产生的问题&lt;/h5&gt;
&lt;p&gt;2 种更新丢失(&lt;strong&gt;第一类更新丢失&lt;/strong&gt;, &lt;strong&gt;第二类更新丢失 …&lt;/strong&gt;&lt;/p&gt;</summary><content type="html">&lt;h4&gt;1. 数据库事务知识&lt;/h4&gt;
&lt;h5&gt;1.1 数据库事务的 4 个基本特征: ACID&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;原子性(Atomic): 一个事务是不可分割的整体, 其内的操作要么全部成功, 要么全部失败.&lt;/li&gt;
&lt;li&gt;一致性(Consistency): 事务确保数据库从一个一致状态转变到另一个一致的状态. 一致状态指的是数据库应满足完整性约束. 比如 A+B 有 1000 元, 在 A 转帐到 B 300 后, 事务完成时, A + B 仍是 1000 元, 这保持了一致性&lt;/li&gt;
&lt;li&gt;隔离性(Isolation): 在多并发执行事务时, 事务与事务之间是隔离开执行的.&lt;/li&gt;
&lt;li&gt;持久性(Durability): 已被提交的了事务对数据库的修改被永久保存在数据库中.&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;1.2 数据库并发产生的问题&lt;/h5&gt;
&lt;p&gt;2 种更新丢失(&lt;strong&gt;第一类更新丢失&lt;/strong&gt;, &lt;strong&gt;第二类更新丢失&lt;/strong&gt;), 3 种读错误(&lt;strong&gt;脏读&lt;/strong&gt;, &lt;strong&gt;不可重复读&lt;/strong&gt;, &lt;strong&gt;幻读&lt;/strong&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一类更新丢失: 即 &lt;strong&gt;回滚事务&lt;/strong&gt; 导致的更新丢失, 事务 A, B 分别读取到状态, 事务 B 修改了状态并提交, 但事务 A 回滚了事务, 把 B 的提交给覆盖了&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;时间点&lt;/th&gt;
&lt;th&gt;事务 A&lt;/th&gt;
&lt;th&gt;事务 B&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;事务开始&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;事务开始&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T3&lt;/td&gt;
&lt;td&gt;查询帐户余额为 1000&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;查询帐户余额为 1000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;存入 100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;提交事务, 总额变为 1100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T7&lt;/td&gt;
&lt;td&gt;取出 100, 总额变为 900&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T8&lt;/td&gt;
&lt;td&gt;回滚事务, 总额变为 1000&lt;br /&gt;(事务 B 的提交更新丢失了)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;第二类更新丢失: 即 &lt;strong&gt;提交事务&lt;/strong&gt; 导致了更新丢失. 事务 A, B 分别读取状态, A, B 都修改了状态, 然后 B 先提交了事务, A 再提交事务, A 的提交把 B 的状态给覆盖了&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;时间点&lt;/th&gt;
&lt;th&gt;事务 A&lt;/th&gt;
&lt;th&gt;事务 B&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;事务开始&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;事务开始&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T3&lt;/td&gt;
&lt;td&gt;查询帐户余额为 1000&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;查询帐户余额为 1000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;取出 100, 余额变为 900&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;提交事务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T7&lt;/td&gt;
&lt;td&gt;取出 100, 余额变为 900&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T8&lt;/td&gt;
&lt;td&gt;提交事务&lt;br /&gt;(已经取出了 200, 但余额还是900,&lt;br /&gt;事务 A 的提交覆盖了 B 的提交)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;脏读: 事务 A 读到了事务 B 未提交的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;时间点&lt;/th&gt;
&lt;th&gt;事务 A&lt;/th&gt;
&lt;th&gt;事务 B&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;事务开始&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;事务开始&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T3&lt;/td&gt;
&lt;td&gt;查询帐户余额为 1000&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;查询帐户余额为 1000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;取出 100, 余额变为 900&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T6&lt;/td&gt;
&lt;td&gt;查询帐户余额为 900&lt;br /&gt;(读到了 B 还没提交的数据)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;撤消事务, 余额变为 1000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T8&lt;/td&gt;
&lt;td&gt;存入 100, 余额变为 1000&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T9&lt;/td&gt;
&lt;td&gt;提交事务&lt;br /&gt;(B 已经回滚了事务, 但存入 100 后余额还是 1000)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;不可重复读: 事务 A 在别的事务 B 提交前和提交后的两次读取到的数据不一致&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;时间点&lt;/th&gt;
&lt;th&gt;事务 A&lt;/th&gt;
&lt;th&gt;事务 B&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;事务开始&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;事务开始&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T3&lt;/td&gt;
&lt;td&gt;查询帐户余额为 1000&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;查询帐户余额为 1000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;取出 100, 余额变为 900&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T6&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;提交事务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T7&lt;/td&gt;
&lt;td&gt;查询余额变为 900&lt;br /&gt;(同一个事务中, &lt;br /&gt;两次读取得到的数据不一致)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;幻读: 事务 A 讲到了事务 B 已提交的新插入的数据, 与不可重复读的区别是, 不可重复读读到的是更新的老数据, 幻读读到的新插入的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;时间点&lt;/th&gt;
&lt;th&gt;事务 A&lt;/th&gt;
&lt;th&gt;事务 B&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;T1&lt;/td&gt;
&lt;td&gt;事务开始&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;事务开始&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T3&lt;/td&gt;
&lt;td&gt;查询 Z 所有的帐户总余额为 1000&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;为 Z 添加新帐户, 并存入 100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;提交事务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T6&lt;/td&gt;
&lt;td&gt;再次查询 Z 所有的帐户总额变为 1100&lt;br /&gt;(同一个事务中, &lt;br /&gt;两次读取得到的数据不一致)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5&gt;1.3 事务的隔离级别&lt;/h5&gt;
&lt;p&gt;事务的并发导入了上面的 5 个问题, 两类更新丢失, 三种读问题, 根所业务的不同需要, 使用不同级别的事务隔离&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读未提交的数据 &lt;code&gt;READ UNCOMMITED&lt;/code&gt;: 事务 A 可以读取别的事务 B 还未提交数据&lt;/li&gt;
&lt;li&gt;读已提交的数据 &lt;code&gt;READ COMMITED&lt;/code&gt;: 该事务 A 可以读取别的是事务 B 已提交的数据&lt;/li&gt;
&lt;li&gt;可重复读 &lt;code&gt;REPEATABLE READ&lt;/code&gt;: 事务 A 可以读到别的事务 B 提交的新插入的数据, 但不能读到对已经的记录更新后的数据&lt;/li&gt;
&lt;li&gt;串行化 &lt;code&gt;SERIALIZABLE&lt;/code&gt;: 事务隔离的最高级别, 一个事务完全看到不别的是事务的提交, 只有一个事务完成时, 别的事务才能开始, 严格的队列顺序执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;✘ 指在这个隔离级别时可避免这个问题, ✔︎ 指在该隔离级别时会产生该问题&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;隔离级别&lt;/th&gt;
&lt;th align="center"&gt;第一类更新丢失&lt;/th&gt;
&lt;th align="center"&gt;第二类更新丢失&lt;/th&gt;
&lt;th align="center"&gt;脏读&lt;/th&gt;
&lt;th align="center"&gt;不可重复读&lt;/th&gt;
&lt;th&gt;幻读&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;读未提交的数据 &lt;code&gt;READ UNCOMMITED&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;✘&lt;/td&gt;
&lt;td align="center"&gt;✔︎&lt;/td&gt;
&lt;td align="center"&gt;✔︎&lt;/td&gt;
&lt;td align="center"&gt;✔︎&lt;/td&gt;
&lt;td&gt;✔︎&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;读已提交的数据 &lt;code&gt;READ COMMITED&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;✘&lt;/td&gt;
&lt;td align="center"&gt;✔︎&lt;/td&gt;
&lt;td align="center"&gt;✘&lt;/td&gt;
&lt;td align="center"&gt;✔︎&lt;/td&gt;
&lt;td&gt;✔︎&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可重复读 &lt;code&gt;REPEATABLE READ&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;✘&lt;/td&gt;
&lt;td align="center"&gt;✘&lt;/td&gt;
&lt;td align="center"&gt;✘&lt;/td&gt;
&lt;td align="center"&gt;✘&lt;/td&gt;
&lt;td&gt;✔︎&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;串行化 &lt;code&gt;SERIALIZABLE&lt;/code&gt;&lt;/td&gt;
&lt;td align="center"&gt;✘&lt;/td&gt;
&lt;td align="center"&gt;✘&lt;/td&gt;
&lt;td align="center"&gt;✘&lt;/td&gt;
&lt;td align="center"&gt;✘&lt;/td&gt;
&lt;td&gt;✘&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="mysql"></category><category term="事务"></category><category term="事务隔离"></category><category term="数据库并发问题"></category></entry><entry><title>Spring 数据库事务处理</title><link href="https://ivicel.info/2019/01/spring-shu-ju-ku-shi-wu-chu-li.html" rel="alternate"></link><published>2019-01-12T00:00:00+08:00</published><updated>2019-01-12T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2019-01-12:/2019/01/spring-shu-ju-ku-shi-wu-chu-li.html</id><summary type="html">&lt;h4&gt;1. 事务的传播行为&lt;/h4&gt;
&lt;p&gt;事务的传播行为是 Spring 对数据库事务添加的特定功能, 指的是当方法 A 调用另一个方法 B 时, B 事务中所采取的不同策略的行为, 比如新建事务, 挂起事务等. 事务的传播注解修饰的是方法 B 自己, 当被别的方法调用时才起的作用, 而不是方法内起作用&lt;/p&gt;
&lt;h4&gt;1.1 Spring 中七种事务传播行为&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事务传播行为类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;PROPAGATION_REQUIRED&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1. 如果当前没有事务, 则新建一个事务&lt;br /&gt;2. 有的话就则加入到这个事务中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PROPAGATION_SUPPORTS&lt;/td&gt;
&lt;td&gt;有则沿用, 没有也不新建&lt;br /&gt;1. 如果当前存在事务, 则沿用当前事务 &lt;br /&gt;2. 如果当前没有事务, 就以非事务方式运行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PROPAGATION_MANDATORY&lt;/td&gt;
&lt;td&gt;确保必须使用当前事务&lt;br /&gt;1. 如果当前存在, 使用当前事务. &lt;br /&gt;2. 如果当前没有事务, 就抛出异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;PROPAGATION_REQUIRES_NEW&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;总是新建自己事务 …&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</summary><content type="html">&lt;h4&gt;1. 事务的传播行为&lt;/h4&gt;
&lt;p&gt;事务的传播行为是 Spring 对数据库事务添加的特定功能, 指的是当方法 A 调用另一个方法 B 时, B 事务中所采取的不同策略的行为, 比如新建事务, 挂起事务等. 事务的传播注解修饰的是方法 B 自己, 当被别的方法调用时才起的作用, 而不是方法内起作用&lt;/p&gt;
&lt;h4&gt;1.1 Spring 中七种事务传播行为&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事务传播行为类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;PROPAGATION_REQUIRED&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1. 如果当前没有事务, 则新建一个事务&lt;br /&gt;2. 有的话就则加入到这个事务中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PROPAGATION_SUPPORTS&lt;/td&gt;
&lt;td&gt;有则沿用, 没有也不新建&lt;br /&gt;1. 如果当前存在事务, 则沿用当前事务 &lt;br /&gt;2. 如果当前没有事务, 就以非事务方式运行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PROPAGATION_MANDATORY&lt;/td&gt;
&lt;td&gt;确保必须使用当前事务&lt;br /&gt;1. 如果当前存在, 使用当前事务. &lt;br /&gt;2. 如果当前没有事务, 就抛出异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;PROPAGATION_REQUIRES_NEW&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;总是新建自己事务, 这样新事务总是拥有新的锁和隔离级别等特性, 如果当前存在事务, 先把当前事务挂起.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PROPAGATION_NOT_SUPPORTED&lt;/td&gt;
&lt;td&gt;确保以非事务运行&lt;br /&gt;1. 当前不存在事务, 以非事务方式运行&lt;br /&gt;2. 如果当前存在事务则先挂起当前事务, 以非事务运行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PROPAGATION_NEVER&lt;/td&gt;
&lt;td&gt;确保当前没有事务&lt;br /&gt;1. 以非事务方式运行&lt;br /&gt;2. 如果当前存在事务则抛出异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;PROPAGATION_NESTED&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1. 如果当前存在事务, 是嵌套在事务内运行&lt;br /&gt;2. 如果当前没有事务, 创建新的事务来运行, 但与 &lt;code&gt;PROPAGATION_REQUIRED&lt;/code&gt; 不同的是, 内部方法发生的异常不会当前方法的 SQL&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;加&lt;strong&gt;黑体&lt;/strong&gt;的三个是常用的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;2. 传播行为的代码测试&lt;/h4&gt;
&lt;p&gt;在数据库中有两张表 &lt;code&gt;t_user1&lt;/code&gt; 和 &lt;code&gt;t_user2&lt;/code&gt;, 以及对应 POJO, 简单的 Service 操作&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下方所有的 &lt;code&gt;test*()&lt;/code&gt; 方法都应该在不在 &lt;code&gt;User1Service&lt;/code&gt; 或 &lt;code&gt;User2Service&lt;/code&gt; 类内, 避免产生类内自调用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 表 t_user1 对应的 POJO
public Class User1 {
        private Long id;
    private String name;
    // getters and setters...
}

// 表 t_user2 对应的 POJO
public Class User2 {
        private Long id;
    private String name;
    // getters and setters...
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;2.1 &lt;code&gt;PROPAGATION_REQUIRED&lt;/code&gt; 行为&lt;/h5&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// user1 和 user2 的 service 的插入操作都在事务中, 传播都为 PROPAGATION_REQUIRED
public class User1Service {
        @Transactional(propagation = Propagation.REQUIRED)
    public void addRequired(User1 user1) {
        // Mybatais mapper: insert into `t_user1` (`name`) values (#name)
        user1Mapper.insert(user1);
    }
}

public class User2Service {
        @Transactional(propagation = Propagation.REQUIRED)
    public void addRequired(User2 user2) {
        user2Mapper.insert(user2);
    }

    @Transactional(propagation = Propagation.REQUIRED)
    public void addRequiredWithException(User2 user2) {
        user2Mapper.insert(user2);
        throw new RuntimeException("手动抛出异常");
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在外围非事务的方法中调用, 各个事务都是相对独立的, 成功或失败都不互相干扰&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 测试一
public void test1(){
    User1 user1 = new User1();
    user1.setName("张三");
    user1Service.addRequired(user1);

    User2 user2=new User2();
    user2.setName("李四");
    user2Service.addRequired(user2);
        // 即使在最后抛出异常, 上面的两个独立事务都插入成功
    throw new RuntimeException();
}

// 测试二
public void test2(){
    User1 user1 = new User1();
    user1.setName("张三");
    user1Service.addRequired(user1);

    User2 user2 = new User2();
    user2.setName("李四");
      // 在 user2Service 抛出异常, 
    // 但 user1Service, user2Service 是两个独立事务,
    // 所以 user1Service 插入成功, user2Service 失败
    user2Service.addRequiredWithException(user2);
}&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在外围调用方法是开启事务时, 这时的要将被调用方法加入到这个事务当中而不是自己新创建事务&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 三个测试都开启了事务

// 测试一
@Transactional
public void test1(){
    User1 user1 = new User1();
    user1.setName("张三");
    user1Service.addRequired(user1);

    User2 user2=new User2();
    user2.setName("李四");
    user2Service.addRequired(user2);
        // user1Service, user2Service 都加入了当前方法的同一事务当中
    // 所以最后事务抛出异常时, 所有的插入都失败
    throw new RuntimeException();
}

// 测试二
@Transactional
public void test2(){
    User1 user1 = new User1();
    user1.setName("张三");
    user1Service.addRequired(user1);

    User2 user2 = new User2();
    user2.setName("李四");
      // user1Service, user2Service 都加入了当前方法的同一事务当中
    // 当内部方法抛出异常时, 事务回滚, 则所有的插入都失败
    user2Service.addRequiredWithException(user2);
}

// 测试三
@Transactional
public void test2(){
    User1 user1 = new User1();
    user1.setName("张三");
    // 依赖外围方法事务, 成功插入
    user1Service.addRequired(user1);

    User2 user2 = new User2();
    user2.setName("李四");

    try {
        // user1Service, user2Service 都加入了当前方法的同一事务当中
            // 当内部方法抛出异常时, 在外围方法捕获, 处理了这些异常, 事务还是成功的
        // user2 插入失败
            user2Service.addRequiredWithException(user2);
    } catch (Exception e) {

    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;2.2 &lt;code&gt;PROPAGATION_REQUIRED_NEW&lt;/code&gt; 行为&lt;/h5&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// user1 和 user2 的 service 的插入操作都在事务中
public class User1Service {
        @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void addRequiresNew(User1 user1) {
        // Mybatais mapper: insert into `t_user1` (`name`) values (#name)
        user1Mapper.insert(user1);
    }

    @Transactional(propagation = Propagation.REQUIRED)
    public void addRequired(User1 user1) {
        // Mybatais mapper: insert into `t_user1` (`name`) values (#name)
        user1Mapper.insert(user1);
    }
}

public class User2Service {
        @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void addRequiresNew(User2 user2) {
        user2Mapper.insert(user2);
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void addRequiresNewWithException(User2 user2) {
        user2Mapper.insert(user2);
        throw new RuntimeException("手动抛出异常");
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;外围调用方法没有添加事务&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 测试一
public void test1() {
    User1 user1 = new User1();
    user1.setName("张三");
    user1Service.addRequiresNew(user1);

    User2 user2 = new User2();
    user2.setName("李四");
    user2Service.addRequiresNew(user2);
    // 调用方法抛出异常, 但两个内部方法都是自己很生成自己的事务, 互不影响, 都成功插入新数据
    throw new RuntimeException();
}

// 测试二
public void test2() {
    User1 user1 = new User1();
    user1.setName("张三");
    // 内部方法一独立的事务, 成功插入新数据
    user1Service.addRequiresNew(user1);

    User2 user2 = new User2();
    user2.setName("李四");
    // 内部方法二自己抛出异常, 自回滚自己的事务
    user2Service.addRequiresNewWithException(user2);
}&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;外围调用方法是在事务中&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 测试一, 测试外围事务的异常对内部方法的影响
@Transactional
public void test1() {
    User1 user1 = new User1();
    user1.setName("张三");
    // Propagation.REQUIRED 会加入到外部事务中, 外部事务回滚则插入失败
    user1Service.addRequired(user1);

    User2 user2 = new User2();
    user2.setName("李四");
    // Propagation.REQUIRED_NEW 会自己创建新的事务来运行, 无论外部事务如何, 插入数据成功
    user2Service.addRequiresNew(user2);
        // 外围事务回滚
    throw new RuntimeException();
}
// 测试二, 测试内部方法在自己新创建的事务对其他内部方法的影响
@Transactional
public void test2() {
    User1 user1 = new User1();
    user1.setName("张三");
    // 依赖外围事务, 插入失败
    user1Service.addRequired(user1);

    User2 user2 = new User2();
    user2.setName("李四");
    // 自己新创建事务, 插入成功
    user2Service.addRequiresNew(user2);

    User2 user3 = new User2();
    user3.setName("王五");
    // 自己新创建事务, 抛出异常, 并且异常向调用方法抛出, 自已的事务回滚, 外围事务也回滚
    user2Service.addRequiresNewWithException(user3);
}
// 测试三, 与测试二惟一不同的是, 新创建的事务向外围抛出的异常在外围事务中捕获并处理了
@Transactional
public void test3() {
    User1 user1 = new User1();
    user1.setName("张三");
    // 插入成功, 依赖外围事务
    user1Service.addRequired(user1);

    User2 user2 = new User2();
    user2.setName("李四");
    // 插入成功, 自己新创建的事务
    user2Service.addRequiresNew(user2);

    User2 user3 = new User2();
    user3.setName("王五");
    try {
        // 插入失败, 自己创建的事务, 然后把异常抛到了外围方法, 在这里处理了异常
        user2Service.addRequiresNewWithException(user3);
    } catch (Exception e) {
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;2.3 &lt;code&gt;PROPAGATION_NESTED&lt;/code&gt; 行为&lt;/h5&gt;
&lt;p&gt;该行为在外围开启事务时, 内部方法嵌套在外围事务中运行, 外围事务的回溯导致内部方法也一起回滚; 而内部方法的事务则可以自己单独回滚, 不用影响到外围的事务&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;PROPAGATION_NESTED&lt;/code&gt; 事务嵌套行为需要数据库中的&lt;strong&gt;保存点(save point)&lt;/strong&gt;, Hibernate 并不支持这个功能, 会抛出: &lt;code&gt;JpaDialect does not support savepoints - check your JPA provider's capabilities&lt;/code&gt; 异常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public class User1Service {
        @Transactional(propagation = Propagation.NESTED)
    public void addNested(User1 user1) {
        user1Mapper.insert(user1);
    } 
}

public class User2Service {
    @Transactional(propagation = Propagation.NESTED)
    public void addNested(User2 user2) {
        user2Mapper.insert(user2);
    }

    @Transactional(propagation = Propagation.NESTED)
    public void addNestedWithException(User2 user2) {
        user2Mapper.insert(user2);
        throw new RuntimeException("抛出异常");
    }  
}&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;外围方法没有开启事务&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 测试一, 外围方法抛出异常
public void test1() {
    User1 user1 = new User1();
    user1.setName("张三");
    // 创建新事务, 插入成功
    user1Service.addNested(user1);

    User2 user2 = new User2();
    user2.setName("李四");
    // 创建新事务, 插入成功
    user2Service.addNested(user2);
    // 外围抛出的异常
    throw new RuntimeException();
}

// 测试二, 内部方法抛出异常
public void test2() {
    User1 user1 = new User1();
    user1.setName("张三");
    // 创建新事务, 插入成功
    user1Service.addNested(user1);

    User2 user2 = new User2();
    user2.setName("李四");
    // 创建新事务, 自己回滚事务, 插入失败
    user2Service.addNestedWithException(user2);
}&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;外围方法开启事务&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 测试一, 外围方法抛出异常
@Transactional
public void test1() {
    User1 user1 = new User1();
    user1.setName("张三");
    // 创建新事务, 嵌套在外围事务中, 插入失败
    user1Service.addNested(user1);

    User2 user2 = new User2();
    user2.setName("李四");
      // 创建新事务, 嵌套在外围事务中, 插入失败
    user2Service.addNested(user2);
    // 外围事务的回滚影响内部方法的事务
    throw new RuntimeException();
}

// 测试二, 内部方法抛出异常
@Transactional
public void test2() {
    User1 user1 = new User1();
    user1.setName("张三");
    // 创建新事务, 嵌套在外围事务中, 插入失败
    user1Service.addNested(user1);

    User2 user2 = new User2();
    user2.setName("李四");
      // 内部方法的异常抛到了外围事务中, 所有的插入都失败
    user2Service.addNestedWithException(user2);
}

// 测试三, 内部方法抛出异常并有外围捕获
@Transactional
public void test2() {
    User1 user1 = new User1();
    user1.setName("张三");
    // 创建新事务, 嵌套在外围事务中, 插入成功
    user1Service.addNested(user1);

    User2 user2 = new User2();
    user2.setName("李四");
      // 内部方法的异常抛到了外围事务中并被处理, 内部方法插入失败
    try {
        user2Service.addNestedWithException(user2);
    } catch(Exception e) {}
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2.4 &lt;code&gt;@Transactional&lt;/code&gt; 自调用类中方法失效问题&lt;/h4&gt;
&lt;p&gt;Spring 的事务处理是基于 AOP, 通过动态代理生成一个类的代理对象, 而当我们在类的方法中再调用同一个类的事务方法, 其实际还是在同一个事务中, 是类自身的调用, 而不是代理调用, 这样就还是在同一次 AOP 中.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;@Service("userService")
public class UserServiceImple implements IUserService {
        @Override
    @Transactional
    public void insertUsers(List&amp;lt;User&amp;gt; users) {
            for (User user : users) {
            // 调用自已类自身的方法, 还是处于同一 AOP 处理中
                insertUser(user); 
        }
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void insertUser(User user) {
            userMapper.insert(user); 
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以通过手动每次获取类的代理对象, 来手动调用类的方法&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;@Service("userService")
public class UserServiceImple implements IUserService, ApplicationContextAware {
    private ApplicationContext applicationContext;

        @Override
    @Transactional
    public void insertUsers(List&amp;lt;User&amp;gt; users) {
        // 从 IoC 容器中取出代理对象
        IUserService userService = applicationContext.getBean(IUserService.class);
            for (User user : users) {
            // 使用代理对象来调用类方法, 这样总是能通过 AOP
                userService.insertUser(user); 
        }
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void insertUser(User user) {
            userMapper.insert(user); 
    }

    // spring 框架在扫描包时, 会对生成的 bean 检查其是否实现了 ApplicationContextAware 接口
    // 如果实际了则会调用 setApplicationContext 方法, 并把当前 Spring 上下文容器作为参数
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) 
                throws BeansException {
        this.applicationContext = applicationContext;
    }
}&lt;/code&gt;&lt;/pre&gt;</content><category term="spring 事务"></category><category term="spring 开发"></category><category term="事务传播"></category></entry><entry><title>Spring POST 重定向接收错误信息(BindingResult)</title><link href="https://ivicel.info/2019/01/spring-post-zhong-ding-xiang-jie-shou-cuo-wu-xin-xi-bindingresult.html" rel="alternate"></link><published>2019-01-10T00:00:00+08:00</published><updated>2019-01-10T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2019-01-10:/2019/01/spring-post-zhong-ding-xiang-jie-shou-cuo-wu-xin-xi-bindingresult.html</id><summary type="html">&lt;h4&gt;1. POST 请求的错误信息重定向&lt;/h4&gt;
&lt;p&gt;在发送 POST 之后, 如果遇到错误, 我们经常会重定向(GET)回到原页面, 而不是直接返回页面, 这样做是为了避免如果我们点击浏览器刷新按钮时, 会再次发送 POST 请求. 重定向之后, 我们需要获得前面的错误信息.&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;@ModelAttribute&lt;/code&gt; 注解来修饰 &lt;code&gt;RequestMapping&lt;/code&gt; 方法的参数, &lt;code&gt;ModelAttibute&lt;/code&gt; 注解实际上是接收请求参数, 添加到 Model 中, 在取出后自动删除.&lt;/p&gt;
&lt;p&gt;需要注意的几点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 GET 处理方法中, 因为我们在渲染的 html/jsp 页面中使用了 &lt;code&gt;User&lt;/code&gt; 对象, 所以要检测是重定向过来的, 还是用户新的请求来的. 从 POST 重定向过来的, 我们添加了 user 对象, 所以使用 &lt;code&gt;model.containsAttricute("user …&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;h4&gt;1. POST 请求的错误信息重定向&lt;/h4&gt;
&lt;p&gt;在发送 POST 之后, 如果遇到错误, 我们经常会重定向(GET)回到原页面, 而不是直接返回页面, 这样做是为了避免如果我们点击浏览器刷新按钮时, 会再次发送 POST 请求. 重定向之后, 我们需要获得前面的错误信息.&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;@ModelAttribute&lt;/code&gt; 注解来修饰 &lt;code&gt;RequestMapping&lt;/code&gt; 方法的参数, &lt;code&gt;ModelAttibute&lt;/code&gt; 注解实际上是接收请求参数, 添加到 Model 中, 在取出后自动删除.&lt;/p&gt;
&lt;p&gt;需要注意的几点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 GET 处理方法中, 因为我们在渲染的 html/jsp 页面中使用了 &lt;code&gt;User&lt;/code&gt; 对象, 所以要检测是重定向过来的, 还是用户新的请求来的. 从 POST 重定向过来的, 我们添加了 user 对象, 所以使用 &lt;code&gt;model.containsAttricute("user")&lt;/code&gt; 来检测. 如果是用户自己的请求, 那么我们生成一个空的 user 对象, 避免渲染页面时出错&lt;/li&gt;
&lt;li&gt;POST 处理方法中, &lt;code&gt;BindingResult&lt;/code&gt; 参数一定要跟在 &lt;code&gt;@Valid&lt;/code&gt; 之后.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RedirectAttributes.addFlashAttribute()&lt;/code&gt; 方法实际是使用了 session, 但会使用后系统自动删除这个属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BindingResult&lt;/code&gt; 类内的错误信息的 key 值是 &lt;code&gt;BindingResult.class.getName() + "." + ModelAttribute修饰的名称&lt;/code&gt;. 如 &lt;code&gt;org.springframework.validation.BindingResult.user&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;@RequestMapping(value = "/register", method = RequestMethod.GET)
public String register(Model model) {
    // 注意检测 user 对象, 不能在参数中添加 User 参数, 这会优先使用从页面请求参数
    if (!model.containsAttribute("user")) {
        model.addAttribute(new User());
    }
    return "register";
}

// BindingResult 只能跟在 @Valid 后面才会起作用
@RequestMapping(value = "/register", method = RequestMethod.POST)
public String register(@Valid @ModelAttribute("user") User user,
                       BindingResult bindingResult,
                       RedirectAttributes ra) {
    if (bindingResult.hasErrors()) {
      ra.addFlashAttribute("user", user);
      // user 对象对应的 BindingResult 错误信息, 注意其 key 名
      ra.addFlashAttribute("org.springframework.validation.BindingResult.user",
                         bindingResult);
      return "redirect:/register";
    }
    return "redirect:/login";
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. Thymeleaf 中错误信息的使用&lt;/h4&gt;
&lt;p&gt;在 thymeleaf 中使用 &lt;code&gt;#fields&lt;/code&gt; 来获得 form 的错误消息. 比如有一个 form, 其提交的是一个 User 对象. &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-html"&gt;&amp;lt;!-- register.html --&amp;gt;
&amp;lt;form th:object="${user}" th:action="@{/register}"&amp;gt;
  &amp;lt;input th:name="*{username}" th:value="*{username}"&amp;gt;
  &amp;lt;!-- 在这里获到错误消息, 检查 username 字段是否有错误消息, 
        th:errors 会自动提取对应的 field 中的错误信息 --&amp;gt;
  &amp;lt;span th:errors="*{username}" th:if="${#fields.hasErrors('username')}"&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;/form&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;Reference:&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/2543797/spring-redirect-after-post-even-with-validation-errors/10049138#10049138"&gt;https://stackoverflow.com/questions/2543797/spring-redirect-after-post-even-with-validation-errors/10049138#10049138&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="spring"></category><category term="bindingresult"></category><category term="POST 重定向"></category></entry><entry><title>Spring Security 的使用</title><link href="https://ivicel.info/2019/01/spring-security-de-shi-yong.html" rel="alternate"></link><published>2019-01-03T00:00:00+08:00</published><updated>2019-01-03T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2019-01-03:/2019/01/spring-security-de-shi-yong.html</id><summary type="html">&lt;h4&gt;1. Spring Security 的开启方式&lt;/h4&gt;
&lt;p&gt;在 Java Web 中一般使用 Filter 来对请求进行拦截, Spring Security 基于此来对在进入 DispatcherServlet 前对 Spring MVC 进行请求拦截, 进行统一难, 从而决定是否放行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果使用 &lt;code&gt;web.xml&lt;/code&gt; 进行配置, Spring Security 提供了一个 &lt;code&gt;DelegatingFilterProxy&lt;/code&gt; 的 Filter 代理器, 只要在 &lt;code&gt;web.xml&lt;/code&gt; 中配置该 Filter&lt;/li&gt;
&lt;li&gt;如果使用注解方式, 则在配置中加入 &lt;code&gt;@EnableWebSecurity&lt;/code&gt;, 该注解会自动生成一个 &lt;code&gt;SecurityFilterChain&lt;/code&gt; 的 Spring Bean, 该 Bean 包含一个 Filter List, 所有的请求都会由 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h4&gt;1. Spring Security 的开启方式&lt;/h4&gt;
&lt;p&gt;在 Java Web 中一般使用 Filter 来对请求进行拦截, Spring Security 基于此来对在进入 DispatcherServlet 前对 Spring MVC 进行请求拦截, 进行统一难, 从而决定是否放行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果使用 &lt;code&gt;web.xml&lt;/code&gt; 进行配置, Spring Security 提供了一个 &lt;code&gt;DelegatingFilterProxy&lt;/code&gt; 的 Filter 代理器, 只要在 &lt;code&gt;web.xml&lt;/code&gt; 中配置该 Filter&lt;/li&gt;
&lt;li&gt;如果使用注解方式, 则在配置中加入 &lt;code&gt;@EnableWebSecurity&lt;/code&gt;, 该注解会自动生成一个 &lt;code&gt;SecurityFilterChain&lt;/code&gt; 的 Spring Bean, 该 Bean 包含一个 Filter List, 所有的请求都会由 DelegatingFilterProxy 派发到 Filter List 中&lt;/li&gt;
&lt;li&gt;如果使用的是 Spring Boot, 在添加 spring-boot-starter-security 依赖后, 根据 srping boot 的自动配置机制, 会对所有的路由进行 security 拦截, 其实际启用了 &lt;code&gt;@EnableWebSecurity&lt;/code&gt;. 如果手动启用该配置, 那么会覆盖自动配置设置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;启用 spring security 之后, 默认会对所有的路由路径进行认证, 默认的用户名为 user, 默认的密码会在每次启动程序时随机生成, 打印在 INFO 日志中. Spring Boot 在 &lt;code&gt;application.properties&lt;/code&gt; 中有 &lt;code&gt;spring.security.*&lt;/code&gt; 配置可以设置简单的配置项&lt;/p&gt;
&lt;p&gt;一般我们都会使用继承 &lt;code&gt;WebSecurityConfigurerAdapter&lt;/code&gt; 来自定义更加复杂精确的过滤, 主要实现其中 3 个方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;configure(AuthenticationManagerBuilder auth)&lt;/code&gt; 用来配置用户签名, 主要是 user-details 机制, 给予用户赋予用户名, 密码, 角色, 加载用户权限&lt;/li&gt;
&lt;li&gt;&lt;code&gt;configure(HttpSecurity http)&lt;/code&gt; 用来配置拦截保护请求, 决定哪些请求放行, 哪些请求需要验证&lt;/li&gt;
&lt;li&gt;&lt;code&gt;configure(WebSecurity web)&lt;/code&gt; 用来配置 Filter 链&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;2. 验证用户(用户名, 密码, 角色...)&lt;/h4&gt;
&lt;h5&gt;2.1 使用内存签名&lt;/h5&gt;
&lt;p&gt;在 Spring 5 之后要求使用一个密码编码器, 用来对密码进行加密以及密码匹配, 其要实现接口 &lt;code&gt;PasswordEncoder&lt;/code&gt;, 以使用内存签名服务为例&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    // 设置使用内在签名验证
    auth.inMemeoryAuthentication()
        // 设置使用的密码编码器
        .passwordEncoder(new BCryptPasswordEncoder())
        // 添加用户
        .withUser("admin")
        // 设置用户密码
        .password("123456")
        // 设置用户角色, 可以添加多个角色, roles() 
        // 方法内部实质调用了 .authorities() 方法, 其会在角色名前自动添加前缀 `ROLE_`
        // 如果我们使用 .authorities() 方法, 则需要手动添加前缀
        .roles("USER", "ADMIN")
        // 使用 and() 来连接多个角色
        .and()
        .withUser("user")
        .psssword("123456")
        .roles("USER");
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;withUser()&lt;/code&gt; 方法返回的是一个用户详情构造器 &lt;code&gt;UserDetailsBuilder&lt;/code&gt;, 其还有以下的常用的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;accountExpired(boolean)&lt;/code&gt; 账号是否过期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;accountLocked(boolean)&lt;/code&gt; 是否锁定账号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;credentialsExpired(boolean)&lt;/code&gt; 定义凭证是否过期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;disabled(boolean)&lt;/code&gt; 是否禁用用户&lt;/li&gt;
&lt;li&gt;&lt;code&gt;username(String)&lt;/code&gt; 定义用户名&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;2.2 使用数据库定义用户认证服务&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;AuthenticationManagerBuilder#jdbcAuthentication&lt;/code&gt; 方法会返回  &lt;code&gt;JdbcUserDetailsManagerConfigurer&lt;/code&gt; 对象, 数据库用户表为  &lt;code&gt;org.springframework.security.core.userdetails.User&lt;/code&gt;, 数据库至少要实现 4 个字段(&lt;code&gt;id&lt;/code&gt;, &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;password&lt;/code&gt;, &lt;code&gt;available&lt;/code&gt;), 并且这顺序是固定的, 另外角色的权限表, 权限表要实现 2 个字段(&lt;code&gt;id&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;), 并且顺序也是固定的, 角色权限查询返回的是一个 List.&lt;/p&gt;
&lt;p&gt;如果没有实现自己的查询方法, 则会使用内部的查询类 &lt;code&gt;org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    // 使用 JDBC 认证
    auth.jdbcAuthentication()
        .passwordEncoder(new BCryptPasswordEncoder())
        .dataSource(dataSource)
        // 设置使用 username 查询的 SQL
        .usersByUsernameQuery("SELECT user_name, pwd, available FROM t_user " +
                              " WHERE user_name = ?")
        // 设置查询角色的 SQL
        .authoritiesByUsernameQuery("SELECT u.user_name, r.role_name FROM " + 
                                    " t_user u, t_user_role ur, t_role r WHERE " +
                                    " u.id = ur.user_id AND r.id = ur.role_id AND " +
                                    " u.user_name = ?");
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要实现自己的查询处理, 那么可以使用 &lt;code&gt;AuthenticationManagerBuilder#userDetailsService()&lt;/code&gt; 方法, 其参数是实现了 &lt;code&gt;UserDetailsService&lt;/code&gt; 接口的类, 只有一个方法 &lt;code&gt;loadUserByUsername&lt;/code&gt;, 该方法返回 &lt;code&gt;UserDetails&lt;/code&gt; 对象, 需要自己实现该接口&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 用户模型
public class User implements UserDetails {
    private String username;
    private String password;
    private boolean isEnabled;
    private boolean isAccountNonExpired;
    private boolean isAccountNonLocked;
    private boolean isCredentialsNonExpired;
    private List&amp;lt;? extends GrantedAuthority&amp;gt; authorities;

    public User(String username, String password, boolean enabled,
               isAccountNonExpired, isAccountNonLocked, isCredentialsNonExpired,
               authorities) {
        // 这些值从数值库中查出后传入
        this.username = username;
        this.password = password;
        this.enabled = enabled;
        this.isAccountNonExpired = isAccountNonExpired;
        this.isAccountNonLocked = isAccountNonLocked;
        this.isCredentialsNonExpired = isCredentialsNonExpired;
        this.authorities = authorities;
    }
    // getter and setter ...
}


// WebMvcSecurity 配置
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    private JdbcTemplate jdbcTemplate;
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService((username) -&amp;gt; jdbcTemplate.queryForObject(userQuery,
                (rs, rowNum) -&amp;gt; {
            if (rs.isAfterLast()) {
                return null;
            }
            // 假设数据库用户为 id, username, password, enabled
            String password = rs.getString(2);
            boolean enabled = rs.getInt(3) == 1;
            return new User(username, password, enabled);
        }, username))
            // 设置密码编码方式
            .passwordEncoder(new BCryptPasswordEncoder());
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;3. 限制请求(对 url 的配置)&lt;/h4&gt;
&lt;p&gt;限制请求主要是对不同的路径(url)实现不同的策略, 通过这能够实现对不同角色赋予不同权限.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;@Override
protected void configure(HttpSecurity http) throws Exception {
    // 开启认证
    http.authorizeRequests()   
        // Ant 风格匹配, 限定 /user/welcome, /user/details 的访问必须为 ADMIN 或 USER 
        .anMatchers("/user/welcome", "/user/details").hasAnyRole("ADMIN", "USER")
        // /admin 下的 url, 注意 hasAuthority 的角色名称, 自动添加 ROLE_ 前缀
        .antMatchers("/admin/**").hasAuthority("ROLE_ADMIN")
        // 其他任何路径都允许访问
        .anyReuqest().permitAll()
        .and().anonymous()
        // Spring Security 默认的登录页面
        .and().formLogin()
        // 开启 HTTP 基础验证
        .and().httpBasic();
}&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;access(String)&lt;/code&gt; 参数为 SpEL, 返回 true 则允许访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;anonymous()&lt;/code&gt; 允许匿名访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;authorizeRequest()&lt;/code&gt; 限定通过签名请求&lt;/li&gt;
&lt;li&gt;&lt;code&gt;anyRequest()&lt;/code&gt; 限定任意的请求&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hasAnyRole(String...)&lt;/code&gt; 将访问权限赋予多个角色(自动添加前缀 ROLE_)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hasRole(String)&lt;/code&gt; 将访问权限赋予一个角色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;permitAll()&lt;/code&gt; 无条件允许访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;and()&lt;/code&gt; 连接词&lt;/li&gt;
&lt;li&gt;&lt;code&gt;httpBasic()&lt;/code&gt; 启动浏览器 HTTP 基础验证&lt;/li&gt;
&lt;li&gt;&lt;code&gt;formLogin()&lt;/code&gt; 启用默认的登录页面&lt;/li&gt;
&lt;li&gt;&lt;code&gt;not()&lt;/code&gt; 对其他方法的访问采取求反&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fullyAuthenticated()&lt;/code&gt; 如果是完整验证(并非 Remember-me), 则允许访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;denyAll()&lt;/code&gt; 不允许访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hasIpAddress(String)&lt;/code&gt; 指定 IP 可以访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rememberme()&lt;/code&gt; 开启 remember-me 功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hasAuthority(String)&lt;/code&gt; 指定角色可以访问, 需要自己添加前缀 ROLE_&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hasAnyAuthority(String...)&lt;/code&gt; 指定的多角定可以访问, 需要自己添加前缀 ROLE_&lt;/li&gt;
&lt;li&gt;&lt;code&gt;regexMatchers(String)&lt;/code&gt; 正则表达式匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有时候我们需要更加强大的验证功能, 可以使用 SpEL(Spring 表达式), 比如 &lt;code&gt;access("hasRole('USER') or hasRole('ADMIN')")&lt;/code&gt; 来表示需要 USER 或 ADMIN 角色&lt;/p&gt;
&lt;h4&gt;3.1. 自定义登录页面&lt;/h4&gt;
&lt;p&gt;在登录页面都有一个 Remember Me 的功能, 默认的实现是&lt;strong&gt;记住一天&lt;/strong&gt;, 记录在浏览器的 Cookie 中, 其键为 &lt;code&gt;remember-me-key&lt;/code&gt;, 其值为 MD5 Hash 过的值&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;@Override
protected void configure(HttpSecurity http) throws Exception {
    http.authorizeRequests().antMatchers("/admin/**").access("hasRole('ADMIN')")
        // 启用 remember me 功能, 设置其时间限制和 cookie key
        .and().rememberMe().tokenValiditySeconds(7 * 24 * 3600).key("remember-me")
        .and().authorizeRequests().antMatchers("/**").permitAll()
        // 设置自定义的登录路由
        .and().formLogin().loginPage("/login/page")
        // 设置登录成功后的跳转路径
        .defaultSuccessUrl("/admin/welcome")
        // 设置自定义登出路由
        .and().logout().logoutUrl("/logout/page")
        // 登出后跳转页面
        .logoutSuccessUrl("/welcome");
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;5. 防止跨站请求伪造(CSRF)&lt;/h4&gt;
&lt;p&gt;添加 Spring Security 后, 会自动添加 CSRF 认证, 可以使用 &lt;code&gt;HttpSecurity#csrf().disable()&lt;/code&gt; 来关闭. Spring Security 会生成一个 &lt;code&gt;_csrf&lt;/code&gt; 变量, 可以在页面模版中使用这个变量&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-html"&gt;&amp;lt;input type=hidden id="${_csrf.parameterName}" name="${_csrf.parameterName}" 
    value="${_csrf.token}"&amp;gt;&lt;/code&gt;&lt;/pre&gt;</content><category term="spring"></category><category term="spring security"></category></entry><entry><title>MyBatis Generator XML 配置详解</title><link href="https://ivicel.info/2019/01/mybatis-generator-xml-pei-zhi-xiang-jie.html" rel="alternate"></link><published>2019-01-01T00:00:00+08:00</published><updated>2019-01-01T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2019-01-01:/2019/01/mybatis-generator-xml-pei-zhi-xiang-jie.html</id><summary type="html">&lt;h4&gt;1. 配置文件&lt;/h4&gt;
&lt;p&gt;固定的文件头, 约束和根结点&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="UTF-8" ?&amp;gt;
&amp;lt;!DOCTYPE generatorConfiguration
    PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
    "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&amp;gt;
&amp;lt;generatorConfiguration&amp;gt;
    &amp;lt;!-- .... --&amp;gt;
&amp;lt;/generatorConfiguration&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;1.1 &lt;code&gt;properties&lt;/code&gt; 标签&lt;/h5&gt;
&lt;p&gt;用于引入外部的 &lt;code&gt;properties&lt;/code&gt; 文件, 只能出现一次或者不使用, 并且如果使用的话要保证其在配置文件的最开始位置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;resource&lt;/code&gt; 属性, 使用 &lt;code&gt;classpath&lt;/code&gt; 来指定资源路径.  &lt;code&gt;resource=test/mypackage/my.properties&lt;/code&gt; 指的是包 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h4&gt;1. 配置文件&lt;/h4&gt;
&lt;p&gt;固定的文件头, 约束和根结点&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="UTF-8" ?&amp;gt;
&amp;lt;!DOCTYPE generatorConfiguration
    PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
    "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&amp;gt;
&amp;lt;generatorConfiguration&amp;gt;
    &amp;lt;!-- .... --&amp;gt;
&amp;lt;/generatorConfiguration&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;1.1 &lt;code&gt;properties&lt;/code&gt; 标签&lt;/h5&gt;
&lt;p&gt;用于引入外部的 &lt;code&gt;properties&lt;/code&gt; 文件, 只能出现一次或者不使用, 并且如果使用的话要保证其在配置文件的最开始位置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;resource&lt;/code&gt; 属性, 使用 &lt;code&gt;classpath&lt;/code&gt; 来指定资源路径.  &lt;code&gt;resource=test/mypackage/my.properties&lt;/code&gt; 指的是包 &lt;code&gt;test.mypackage&lt;/code&gt; 下的 &lt;code&gt;my.properties&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;url&lt;/code&gt; 属性, 使用文件路径, 比如 &lt;code&gt;url=file:///c:/myfolder/my.properties&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;1.2 &lt;code&gt;classPathEntry&lt;/code&gt; 标签&lt;/h5&gt;
&lt;p&gt;使用时位置要放在 &lt;code&gt;properties&lt;/code&gt; 标签后面, 并且有 &lt;code&gt;context&lt;/code&gt; 标签之前, 用来引入其他 java 的 ZIP/JAR 包, classpath, 或者目录, 可以出现多次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;location&lt;/code&gt; 属性, 比如用来引用 mysql 包,  &lt;code&gt;location=F:/mysql/mysql-connector.jar&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;1.3 &lt;code&gt;context&lt;/code&gt; 标签&lt;/h5&gt;
&lt;p&gt;用于指定一组生成对象的环境配置, 至少一个或者多个&lt;/p&gt;
&lt;h6&gt;1.3.1  &lt;code&gt;context&lt;/code&gt; 标签的属性&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt; 必选, 用来确定标签惟一性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;defaultModeType&lt;/code&gt;: 用于指定 MBG 如何生成实体类. &lt;/li&gt;
&lt;li&gt;&lt;code&gt;conditional&lt;/code&gt; 默认值, 如果一个表只含有一个字段, 比如只单有一个主键, 那么不会为该表单独生成一个实体类, 而是合并到基类中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flat&lt;/code&gt; 为每张表生成一个单独的实体类, 推荐使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hierarchical&lt;/code&gt; 如果表有主键则为该表生成一个单独的实体类, 如果表还有 BLOB 字段, 则为表生成一个包含所有 BLOB 字段的单独实体类, 然后为所有其他的字段另外生成一个单独的实体类. MBG 为类之间维护一个继承关系&lt;/li&gt;
&lt;li&gt;&lt;code&gt;targetRuntime&lt;/code&gt; 用于指定生成代码的运行环境, 可选 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;MyBatis3&lt;/code&gt;: 默认值. &lt;/li&gt;
&lt;li&gt;&lt;code&gt;MyBatis3Simple&lt;/code&gt; 选这个时不会生成相应的 Example 方法. &lt;/li&gt;
&lt;li&gt;&lt;code&gt;MyBatis3DynamicSql&lt;/code&gt; 生成兼容 MyBatis 3.4.2 和 Java 8 及以上版本的对象, 依赖于 MyBatis 动态 SQL&lt;/li&gt;
&lt;li&gt;&lt;code&gt;introspectedColumnImpl&lt;/code&gt; 该属性可以指定扩展 &lt;code&gt;org.mybatis.generator.api.IntrospectedColumn&lt;/code&gt; 类的实现类&lt;/li&gt;
&lt;/ul&gt;
&lt;h6&gt;1.3.2 &lt;code&gt;context&lt;/code&gt; 标签子标签&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;property&lt;/code&gt; 0 个或多个. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;autoDelimitKeywords&lt;/code&gt; 根据包 &lt;code&gt;org.mybatis.generator.internal.db.SqlReservedWords&lt;/code&gt; 类中自动给关键字添加分隔符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;beginningDelimiter&lt;/code&gt; 分隔符开始&lt;/li&gt;
&lt;li&gt;&lt;code&gt;endingDelimiter&lt;/code&gt; 分隔符结束&lt;/li&gt;
&lt;li&gt;&lt;code&gt;javaFileEncoding&lt;/code&gt; 设置 Java 文件的编码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;javaFormatter&lt;/code&gt; Java 类名格式方法. 默认为类&lt;code&gt;org.mybatis.generator.api.dom.DefaultJavaFormatter&lt;/code&gt;, 自定义类则要实现 &lt;code&gt;org.mybatis.generator.api.JavaFormatter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;xmlFormatter&lt;/code&gt; XML 文件的名字生成格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;plugin&lt;/code&gt; 0 个或多个, 用来定义扩展插件. 多个插件将按配置顺序来先后执行. &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;org.mybatis.generator.plugins.CachePlugin&lt;/code&gt; 是一个缓存插件, 可以生成 SQL XML 映射文件中的 cache 标签, 只有当 targetRuntime 为 MyBatis3 时插件才有效&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;commentGenerator&lt;/code&gt; 0 个或多个, 用来配置如何生成注释信息.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt; 属性, 用来指定一个实现了 &lt;code&gt;org.mybatis.generator.api.CommentGenerator&lt;/code&gt; 接口的类, 该类用来生成注释信息. 默认值为 &lt;code&gt;DEFAULT&lt;/code&gt;, 默认类为 &lt;code&gt;org.mybatis.generator.internal.DefaultCommentGenerator&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三个可选的属性标签, 需要通过 &lt;code&gt;property&lt;/code&gt; 标签来指定&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;suppressAllComments&lt;/code&gt; 阻止生成注释, 默认为 &lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;suppressDate&lt;/code&gt; 阻止生成注释包含时间戳, 默认 &lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;addRemarkComments&lt;/code&gt; 注释是否添加数据库表的备注信息, 默认 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;jdbcConnection&lt;/code&gt; 1 个. 配置连接数据库方式.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;driverClass&lt;/code&gt; 必选属性. JDBC 驱动程序的完全限定类名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;connectionURL&lt;/code&gt; 必选属性, JDBC 的连接 URL&lt;/li&gt;
&lt;li&gt;&lt;code&gt;userId&lt;/code&gt; 可选属性, 访问数据库的用户名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;password&lt;/code&gt; 可选属性, 访问数据库的密码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除 4 个属性外, 还可以添加 property 子标签, 用于连接数据库其他所需要的属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;javaTypeResolver&lt;/code&gt; 0 个或 1 个, 用于数据库类型与 Java 类型的映射关系.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt; 可选属性. 用于如何映射类型关系, 自定义的话需要类实现 &lt;code&gt;org.mybatis.generator.api.JavaTypeResolver&lt;/code&gt;, 另外还接受一个默认 &lt;code&gt;DEFAULT&lt;/code&gt; 值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;forceBigDecimals&lt;/code&gt; 子标签 &lt;code&gt;property&lt;/code&gt; 属性, 默认为 &lt;code&gt;false&lt;/code&gt;, 用于设置数据库 &lt;code&gt;DECIMAL&lt;/code&gt; 和 &lt;code&gt;NUMERIC&lt;/code&gt; 类型强制映射为 Java 的 &lt;code&gt;java.math.BigDecimal&lt;/code&gt; 类型, 默认情况下的转换规则为.&lt;ol&gt;
&lt;li&gt;精度 &amp;gt; 0 或 长度 &amp;gt; 18, 就转换成 &lt;code&gt;java.math.BigDecimal&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;精度 = 0 并且 10 &amp;lt;= 长度 &amp;lt;= 18, 转成 &lt;code&gt;java.lang.Long&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;精度 = 0 并且 5 &amp;lt;= 长度 &amp;lt;= 9, 转成 &lt;code&gt;java.lang.Integer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;精度 = 0 并且 长度 &amp;lt; 5, 转成 &lt;code&gt;java.lang.Short&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;useJSR310Types&lt;/code&gt; 设置使用 JSR-310 来为时间和日期(&lt;code&gt;DATE&lt;/code&gt;, &lt;code&gt;TIME&lt;/code&gt;, &lt;code&gt;TIMESTAMP&lt;/code&gt;)转换, 而不是使用 &lt;code&gt;java.util.Date&lt;/code&gt; 类. 不管如何设置, 这两个类型转换都是固定的. 1.  JDBC Type &lt;code&gt;TIME_WITH_TIMEZONE&lt;/code&gt; ---&amp;gt; &lt;code&gt;java.time.OffsetTime&lt;/code&gt;, 2. &lt;code&gt;TIMESTAMP_WITH_TIMEZONE&lt;/code&gt; ---&amp;gt; &lt;code&gt;java.time.OffsetDateTime&lt;/code&gt;. 当设置为 &lt;code&gt;true&lt;/code&gt; 时:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JDBC Type: &lt;code&gt;DATE&lt;/code&gt; ---&amp;gt; &lt;code&gt;java.time.LocalDate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TIME&lt;/code&gt; ---&amp;gt; &lt;code&gt;java.time.LocalTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TIMESTAMP&lt;/code&gt; ---&amp;gt; &lt;code&gt;java.time.LocalDateTime&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;javaModelGenerator&lt;/code&gt; 1 个. 用来配置如何生成 java 实体类. 两个必选属性:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;targetPackage&lt;/code&gt; 生成实体类存放的包名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;targetProject&lt;/code&gt; 目标项目的路径, 比如 Maven 中  &lt;code&gt;src/main/java&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他支持的 property 子标签属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;constructorBased&lt;/code&gt; 只对 MyBatis3 有效, 使用构造方法入参, 如果为 &lt;code&gt;false&lt;/code&gt; 则使用 setter 方法. 默认 &lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enableSubPackages&lt;/code&gt; 如果为 &lt;code&gt;true&lt;/code&gt;, 则会根据 catalog 和 schema 来生成子包, 否则使用 targetPackage 属性, 默认 &lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;immutable&lt;/code&gt; 默认 &lt;code&gt;false&lt;/code&gt;, 设置生成实体类对象后, 对象不可变, 即不会生成 setter 方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rootClass&lt;/code&gt; 所有实体类的基类, 值是类的完全限定名. 子类不会覆盖和父类中完全匹配的属性. 1. 属性名完全相同. 2. 属性类型相同. 3. 属性有 getter 方法 4. 属性有 setter 方法&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;trimStrings&lt;/code&gt; 设置是否要对数据库查询结果进行 trim 操作, 默认 false&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sqlMapGenerator&lt;/code&gt; 0 个或 1 个, 用于配置生成 Mapper.xml 文件的属性. 当 targetRuntime 设置为 MyBatis3 时, 如果在 &lt;code&gt;javaClientGenerator&lt;/code&gt; 中配置指明需要 XML 的配置, 此标签才必须要配置, 不然该标签是可选的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;targetPackage&lt;/code&gt; 生成实体类存放的包名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;targetProject&lt;/code&gt; 目标项目的路径, 比如 Maven 中  &lt;code&gt;src/main/java&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果没有配置 &lt;code&gt;javaClientGenerator&lt;/code&gt; 标签, 那么按以下规则:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果指定了一个 &lt;code&gt;sqlMapGenerator&lt;/code&gt;, 那么按这个配置生成&lt;/li&gt;
&lt;li&gt;如果没有指定 &lt;code&gt;sqlMapGenerator&lt;/code&gt;, 那么只生成实体类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外还一个 &lt;code&gt;enableSubPackages&lt;/code&gt; 的子 property 标签&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;javaClientGenerator&lt;/code&gt; 0 个或者 1 个. 如果不配置该标签, 则不会生成 Java Mapper 接口. 有 3 个必选属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt; 用于选择 Mapper 接口生成器, 自定义实现需要继承 &lt;code&gt;org.mybatis.generator.codegen.AbstractJavaClientGenerator&lt;/code&gt; 类, 根据 targetRuntime 的值可以分成两类.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;targetRutime 为 &lt;code&gt;MyBatis3&lt;/code&gt; 时&lt;/li&gt;
&lt;li&gt;ANNOTATEDMAPPER` 基于注解的 Mapper 接口, 不会有对应的 XML 映射文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MIXEDMAPPER&lt;/code&gt; XML 和注解的混合形式, 上面这种情况中的 SQL Provider 廨方法会被 XML 方式替代&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XMLMAPPER&lt;/code&gt; 所有的方法都在 XML 中, 接口调用依赖 XML 文件&lt;/li&gt;
&lt;li&gt;targetRuntime 为 &lt;code&gt;MyBatis3Simple&lt;/code&gt; 时&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ANNOTATEDMAPPER&lt;/code&gt; 基于注解的 Mapper 接口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XMLMAPPER&lt;/code&gt; 所有的方法都在 XML 中, 接口调用依赖 XML 文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;table&lt;/code&gt; 1 个或者多个, 用于配置需要通过内省数据库的表, 只有配置过的表, 才会生成对应的 Java 代码.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tableName&lt;/code&gt; 必选属性, 如果设置为 &lt;code&gt;%&lt;/code&gt;, 则匹配所有表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h6&gt;其他可选的属性&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;schema&lt;/code&gt; 数据库的 schema, 可以使用 SQL 通配符匹配. 如果设置了该值, 生成的 SQL 的表名会变成如 schema.tableName 形式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;catalog&lt;/code&gt; 数据库的 catalog, 如果设置了该值, 生成的 SQL 表名会变成 catalog.tableName 形式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alias&lt;/code&gt; 如果指定, 这个值会用在生成的 select 查询 SQL 表的别名和列名上, 例如 alias_actualColumnName&lt;/li&gt;
&lt;li&gt;&lt;code&gt;domainObjectName&lt;/code&gt; 生成对象的基本名称, 如果没有指定则根据表名来生成名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enableXXX&lt;/code&gt; XXX 代表多种 SQL 方法, 用来指定是否生成对应的 XXX 语句&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selectByPrimaryKeyQueryId&lt;/code&gt; 和 &lt;code&gt;selectByExampleQueryId&lt;/code&gt;: 用于 DBA 跟踪工具&lt;/li&gt;
&lt;li&gt;&lt;code&gt;modelType&lt;/code&gt; 和 context 中的 defaultModelType 含义相同, 覆盖该值 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;escapeWildcards&lt;/code&gt; 查询列是否对 schema 和表名中 SQL 通配符(&lt;code&gt;_&lt;/code&gt; 和 &lt;code&gt;%&lt;/code&gt;)进行转义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delimitIdentifiers&lt;/code&gt; 是否给标识符增加分隔符, 默认为 false&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delimitAllColumns&lt;/code&gt; 是否对所有列添加分隔符, 默认为 false&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h6&gt;其他的 property 子标签属性&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;constructorBased&lt;/code&gt; 构造方法, 和 javaModelGenerator 一样&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ignoreQualifiersAtRuntime&lt;/code&gt; 生成的 SQL 中的表名将不会包含 schema 和 catalog 前缀&lt;/li&gt;
&lt;li&gt;&lt;code&gt;immutable&lt;/code&gt; 和 javaModelGenerator 中含义相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;modeOnly&lt;/code&gt; 用于配置是否只生成实体类, 如果为 &lt;code&gt;true&lt;/code&gt;, 就不会有 Mapper 接口, 并覆盖属性中的 enableXXX 方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rootClass&lt;/code&gt;, &lt;code&gt;rootInterface&lt;/code&gt; 和 javaModelGenerator 中的属性一样&lt;/li&gt;
&lt;li&gt;&lt;code&gt;runtimeCatalog&lt;/code&gt; 运行时的 catalog, 当生成表和运行环境表的 catalog 不一样时可以使用该属性进行配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;runtimeSchema&lt;/code&gt; 运行时的 schema, 当生成表和运行环境表的 schema 不一样时可以使用该属性进行配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;selectAllOrderByClause&lt;/code&gt; 该属性值会追加到 &lt;code&gt;selectAll&lt;/code&gt; 方法后的 SQL 中, 直接与 order by 拼接后添加到 SQL 末尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;useActualColumnNames&lt;/code&gt; 如果为 true, 那么 MBG 会使用从数据库元数据获取的列名作为生成的实体对象的属性, 否则使用驼峰式名称, 可以通过 columnOverride 标签显式指定, 此时将忽略该属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;userColumnIndexes&lt;/code&gt; 如果为 true, MBG 生成 resultMaps 时会使用索引而不是结果中列名的顺序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;useCompoundPropertyNames&lt;/code&gt; 如果为 true, MBG 生成属性名时会将列名和列备注连接起来&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;generatedKey&lt;/code&gt; 0 个或 1 个, 用来指自动生成主键的属性(identity 字段或者 sequences 序列), 当指定这个标签时, MBG 将在生成 insert 的 SQL 映射文件中插入一个 selectKey 标签, 该标签有以下属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;column&lt;/code&gt; 必选, 生成列的列名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sqlStatement&lt;/code&gt; 必选, 返回新值的 SQL 语句, 如果这是一个 identity 语句, 则可以使用一个预定义的特殊值.(&lt;code&gt;Cloudscape&lt;/code&gt;, &lt;code&gt;DB2&lt;/code&gt;, &lt;code&gt;DB2_MF&lt;/code&gt;, &lt;code&gt;Derby&lt;/code&gt;, &lt;code&gt;HSQLDB&lt;/code&gt;, &lt;code&gt;Informix&lt;/code&gt;, &lt;code&gt;MySQL&lt;/code&gt;, &lt;code&gt;SQL Server&lt;/code&gt;, &lt;code&gt;SYBASE&lt;/code&gt;, &lt;code&gt;JDBC&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt; 当 type 为 post 并且 identity 为 true 时, 生成的 selectKey 中 order = AFTER; 当 type 为 pre, identity 只能为 false, 生成的 selectKey 中 order = BEFORE. 自动增长的列只有插入到数据库后才能得到 ID, 所以只能是 AFTER, 当使用序列时, 只有先获取序列之后才能插入数据库, 所以是 BEFORE&lt;/li&gt;
&lt;li&gt;&lt;code&gt;identity&lt;/code&gt; 当设置为 true 时, 该列会被标记为 identity 列, 并且 selectKey 标签会被插入在 insert 后面. 否则 selecteKey 会被插入 insert 之前, 默认 false&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;columnRenamingRule&lt;/code&gt; 0 个或 1 个, 可以使用该标签在生成列之前对列进行重命名. 该标签有一个必选属性 &lt;code&gt;searchString&lt;/code&gt;, 可选属性 &lt;code&gt;replaceString&lt;/code&gt;. MBG 内部使用 &lt;code&gt;java.util.regex.Matcher.replaceAll&lt;/code&gt; 来实现替换功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;columnOverride&lt;/code&gt; 0 个或多个. 该标签用于将某些默认计算的属性值更改为指定的值. 除 column 属性是必选属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;column&lt;/code&gt; 必选 , 表示要重写的列名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;property&lt;/code&gt; 要使用的 Java 属性的名称, 如果没有指定, MBG 会根据列名生成&lt;/li&gt;
&lt;li&gt;&lt;code&gt;javaType&lt;/code&gt; 列的属性值为完全限定的 Java 类型, 如果需要, 可以覆盖 JavaTypeResolver 计算出的类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jdbcType&lt;/code&gt; 列的 JDBC 类型, 如 INTEGER, DECIMAL, NUMERIC, VARCHAR..&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typeHandler&lt;/code&gt; 根据用户定义的需要用来处理列的类型处理器. 必须是一个继承自 TypeHandler 接口的全限定的类名. 如果没有指定或者是空白, MyBatis 会用默认的类型处理器.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delimitedColumnName&lt;/code&gt; 指定是否应在生成的 SQL 的列名称上增加分隔符. 如果列的名称中包含空格, MBG 会自动添加分隔符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ignoreColumn&lt;/code&gt; 0 个或多个, 用来屏蔽不需要生成的列, column 属性指定表列名, delimitedColumnName 用于表示是否要区别大小写进行列名匹配&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="mybatis"></category></entry><entry><title>RTFSC: Flask 的源码阅读(三)</title><link href="https://ivicel.info/2018/09/rtfsc-flask-de-yuan-ma-yue-du-san.html" rel="alternate"></link><published>2018-09-19T00:00:00+08:00</published><updated>2018-09-19T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-09-19:/2018/09/rtfsc-flask-de-yuan-ma-yue-du-san.html</id><summary type="html">&lt;h4&gt;1. 路由的实现&lt;/h4&gt;
&lt;p&gt;有两种方式来添加路由, 通常使用装饰器来添加, 其内部也是通过第二种 &lt;code&gt;add_url_rule()&lt;/code&gt; 方法, 装饰器是一种简洁明了的方式. &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;def add_url_rule(self, rule, endpoint=None, view_func=None,
                 provide_automatic_options=None, **options):
    # endpoint 默认使用的是函数名
    if endpoint is None:
        endpoint = _endpoint_from_view_func(view_func)
    options['endpoint'] = endpoint
    # 提供 HTTP 方法
    # 1) methods 参数 2) 从 view_func 的 methods 属性 3) view_func 的 require_methods 属性
    # 如果这两个都没提供, 则默认只支持 …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;h4&gt;1. 路由的实现&lt;/h4&gt;
&lt;p&gt;有两种方式来添加路由, 通常使用装饰器来添加, 其内部也是通过第二种 &lt;code&gt;add_url_rule()&lt;/code&gt; 方法, 装饰器是一种简洁明了的方式. &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;def add_url_rule(self, rule, endpoint=None, view_func=None,
                 provide_automatic_options=None, **options):
    # endpoint 默认使用的是函数名
    if endpoint is None:
        endpoint = _endpoint_from_view_func(view_func)
    options['endpoint'] = endpoint
    # 提供 HTTP 方法
    # 1) methods 参数 2) 从 view_func 的 methods 属性 3) view_func 的 require_methods 属性
    # 如果这两个都没提供, 则默认只支持 GET
    methods = options.pop('methods', None)
    if methods is None:
        methods = getattr(view_func, 'methods', None) or ('GET',)
    if isinstance(methods, string_types):
        raise TypeError('Allowed methods have to be iterables of strings, '
                        'for example: @app.route(..., methods=["POST"])')
    methods = set(item.upper() for item in methods)

    # Methods that should always be added
    required_methods = set(getattr(view_func, 'required_methods', ()))

    # provide_automatic_options 为非 None 时不会自动提供 OPTIONS 方法
    if provide_automatic_options is None:
        provide_automatic_options = getattr(view_func,
            'provide_automatic_options', None)

    if provide_automatic_options is None:
        if 'OPTIONS' not in methods:
            provide_automatic_options = True
            required_methods.add('OPTIONS')
        else:
            provide_automatic_options = False

    # Add the required methods now.
    methods |= required_methods

    rule = self.url_rule_class(rule, methods=methods, **options)
    rule.provide_automatic_options = provide_automatic_options

    self.url_map.add(rule)
    if view_func is not None:
        old_func = self.view_functions.get(endpoint)
        if old_func is not None and old_func != view_func:
            raise AssertionError('View function mapping is overwriting an '
                                 'existing endpoint function: %s' % endpoint)
        self.view_functions[endpoint] = view_func
&lt;/code&gt;&lt;/pre&gt;</content><category term="flask"></category><category term="python"></category><category term="源代码阅读"></category><category term="RTFSC"></category></entry><entry><title>RTFSC: Flask 的源码阅读(二)</title><link href="https://ivicel.info/2018/09/rtfsc-flask-de-yuan-ma-yue-du-er.html" rel="alternate"></link><published>2018-09-18T00:00:00+08:00</published><updated>2018-09-18T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-09-18:/2018/09/rtfsc-flask-de-yuan-ma-yue-du-er.html</id><summary type="html">&lt;h4&gt;1. 路由派发&lt;/h4&gt;
&lt;p&gt;由 &lt;code&gt;Flask.full_dispatch_request()&lt;/code&gt; 发起路由派发&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;def full_dispatch_request(self):
    # before_first_request 的回调
    self.try_trigger_before_first_request_functions()
    try:
        # signal 注册的回调
        request_started.send(self)
        # before_request 的回调, 在这我们也可以看到
        # 只有 before_request 回调中返回 None, 才继续向下派发
        rv = self.preprocess_request()
        if rv is None:
            rv = self.dispatch_request()
    except Exception as e:
        rv = self.handle_user_exception(e)
    return self.finalize_request(rv)&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;回调程序运行后 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h4&gt;1. 路由派发&lt;/h4&gt;
&lt;p&gt;由 &lt;code&gt;Flask.full_dispatch_request()&lt;/code&gt; 发起路由派发&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;def full_dispatch_request(self):
    # before_first_request 的回调
    self.try_trigger_before_first_request_functions()
    try:
        # signal 注册的回调
        request_started.send(self)
        # before_request 的回调, 在这我们也可以看到
        # 只有 before_request 回调中返回 None, 才继续向下派发
        rv = self.preprocess_request()
        if rv is None:
            rv = self.dispatch_request()
    except Exception as e:
        rv = self.handle_user_exception(e)
    return self.finalize_request(rv)&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;回调程序运行后, 第一次有 request 到达时的注册方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 &lt;code&gt;Flask.try_trigger_before_first_request_functions()&lt;/code&gt; 运行我们在程序中使用 &lt;code&gt;before_first_request()&lt;/code&gt; 注册的回调, 这是在程序运行时接收到第一次请求时调用, 可以注册多个回调方法, 检测第一次 request 只是使用了一个简单的标志位 &lt;code&gt;_got_first_request&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;回调这些方法的时, 使用了线程锁 &lt;code&gt;_before_request_lock&lt;/code&gt; 在保证方法总是在回调用 reqeust 之前被调用, 想像一下多线程版本时, 可以同时到达多个 request. &lt;/li&gt;
&lt;li&gt;在取得锁之后, 我们还在再次检查 &lt;code&gt;_got_first_request&lt;/code&gt; 标志, 确保这些回调只调用过一次&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;with self._before_request_lock:
    if self._got_first_request:
        return
    # before_first_request_funcs 是注册的方法列表
    for func in self.before_first_request_funcs:
        func()
    self._got_first_request = True&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果我们安装了 &lt;code&gt;blinker&lt;/code&gt; , 这是一个同步的事件派发器, flask 为我们注册了一些事件, 像 &lt;code&gt;request-started&lt;/code&gt;, &lt;code&gt;request-finished&lt;/code&gt;, 以便我们在可以在程序外监听, 如果我们没有安装 &lt;code&gt;blinker&lt;/code&gt;, 不会触发这些事件. 事件在 &lt;code&gt;flask.signals&lt;/code&gt; 中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下来便是由 &lt;code&gt;url_value_request&lt;/code&gt; 注册的回调和由 &lt;code&gt;before_request&lt;/code&gt; 注册的回调. 前者是的回调方法里接收两个参数, 一是 &lt;code&gt;reqeust.endpoint&lt;/code&gt; 这个默认就是方法的 &lt;code&gt;__name__&lt;/code&gt;, 二是  &lt;code&gt;request.view_args&lt;/code&gt; 这个是请求的参数 &lt;code&gt;query_string&lt;/code&gt;.  前者回调存放在 &lt;code&gt;Flask.url_value_preprocessor&lt;/code&gt;, 后者在 &lt;code&gt;Flask.before_request_func&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里需要注意的是我们有两个地方可以注册该事件, 一是全局 &lt;code&gt;Flask&lt;/code&gt;, 二是 &lt;code&gt;Blueprint&lt;/code&gt;. 这两种回调方法都存放在同一个变量中. 这是一个 dict, 全局的注册 &lt;code&gt;key&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt;, 对 &lt;code&gt;Blueprint&lt;/code&gt; 则是 blueprint 的名称为 &lt;code&gt;key&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对象 &lt;code&gt;before_request&lt;/code&gt; , 当其中有方法返回非 &lt;code&gt;None&lt;/code&gt; 时, 该 request 便返回给客户端了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;下来派发到我们注册的路由方法&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;def dispatch_request(self):
    # Request 是从 werkzeug.wrapper.Reqeust 继承来的
    # 前面讲过, 当有 exception 时, exception 保存在 Request.routing_exception 中
    req = _request_ctx_stack.top.request
    if req.routing_exception is not None:
        # 抛出异常或者抛出调试异常
        self.raise_routing_exception(req)
  # 没有问题
    rule = req.url_rule
  # 我们在注册 view_func 时, 可以提供一个 provide_automatic_options 参数
    # 当这个为 True, 并且是 OPTIONS 请求时, 直接回复一个默认 option_response
    if getattr(rule, 'provide_automatic_options', False) \
       and req.method == 'OPTIONS':
        return self.make_default_options_response()
    # 终于来到我们自己注册的路由方法
    return self.view_functions[rule.endpoint](**req.view_args)

def raise_routing_exception(self, request):
    # 非 debug 模式, 或者非重定向, 或是 (GET, HEAD, OPTIONS) 之一中的请求
    # 直接抛出
    if not self.debug \
       or not isinstance(request.routing_exception, RequestRedirect) \
       or request.method in ('GET', 'HEAD', 'OPTIONS'):
        raise request.routing_exception
  # 在 debug 模式下, 抛出不同的输出, 也就是我们调试时看到调试页面
    from .debughelpers import FormDataRoutingRedirect
    raise FormDataRoutingRedirect(request)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. 请求异常处理&lt;/h4&gt;
&lt;p&gt;如果在请求处理是发生异常, 会抛到 &lt;code&gt;full_dispatch_request()&lt;/code&gt; 中, 在 &lt;code&gt;handle_user_exception()&lt;/code&gt; 中处理&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;def handle_user_exception(self, e):
    # 确保当前系统中刚发生的异常是原先我们捕捉到的异常
    # 如果不是的话, 那么向上 wsgi_app 中抛出 AssertionError
    # 由 handle_exception() 来处理
    exc_type, exc_value, tb = sys.exc_info()
    assert exc_value is e
    # BadRequestKeyError 指的是比如请求时需要提供某个参数, 但没有提供
    # 像 form 中 csrf_token, 那么会产生一个 KeyError, 而客户端则会收到一个 400 Bad Request
    if (
        (self.debug or self.config['TRAP_BAD_REQUEST_ERRORS'])
        and isinstance(e, BadRequestKeyError)
        # only set it if it's still the default description
        and e.description is BadRequestKeyError.description
    ):
        e.description = "KeyError: '{0}'".format(*e.args)
    # trap_http_exception 受到配置 'TRAP_HTTP_EXCEPTIONS', 这个会使用所有 exception 
    # 返回 True. 配置 'TRAP_BAD_REQUEST_ERRORS' 会单独捕捉 BAD_REQUEST
    if isinstance(e, HTTPException) and not self.trap_http_exception(e):
        # 默认的 http exception 处理.
        # 先查找注册的 error handler, 没有的话直接返回 exception 对象
        return self.handle_http_exception(e)
    # 查找注册了 error handler, 没有话重新抛出, 回到 handle_exception 处理
    handler = self._find_error_handler(e)
    if handler is None:
        reraise(exc_type, exc_value, tb)
    # handler() 要求返回的是一个 response
    return handler(e)

 def handle_exception(self, e):
    """默认的 exception 处理方法, 非 debug 模式下, 返回 500 Internal Server Error
       并记录到日志文件中
    """
    exc_type, exc_value, tb = sys.exc_info()
    # blinker 事件派发
    got_request_exception.send(self, exception=e)
    # 查找注册的 HTTP 状态处理方法, 404 500, 403 之类
    handler = self._find_error_handler(InternalServerError())
    # 查找配置文件 app.config 中 PROPAGATE_EXCEPTIONS, 向上抛出异常
    if self.propagate_exceptions:
        if exc_value is e:
            reraise(exc_type, exc_value, tb)
        else:
            raise e

    self.log_exception((exc_type, exc_value, tb))
    if handler is None:
        # 默认的 500
        return InternalServerError()
    # 使用我们自己的 500 处理方法
    return self.finalize_request(handler(e), from_error_handler=True)   &lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;3. 结束派发&lt;/h4&gt;
&lt;p&gt;如果我们在 &lt;code&gt;handle_user_exception&lt;/code&gt; 不向上抛出异常, 将会运行到 &lt;code&gt;finalize_request()&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;def finalize_request(self, rv, from_error_handler=False):
    # 从 view_func 获得的正常 resepon 
    # 或者由捕获异常后, 生成的 404, 400, 500 之类的 response 对象
    response = self.make_response(rv)
    try:
        # 处理 after_request 注册的方法, 和 before_request 相同
        # 处理 session 相关, 把 session 发送到客户端
        response = self.process_response(response)
        # blinker 注册的事件
        request_finished.send(self, response=response)
    except Exception:
        # 从 handle_exception 过来的就是 True
        # # 从 handle_user_exception 过来就是 False, 那么就会抛到调用 Flask 应用的程序中
        if not from_error_handler:
            raise
        self.logger.exception('Request finalizing failed with an '
                              'error while handling an error')
    return response&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回到 &lt;code&gt;Flask.wsgi_app&lt;/code&gt; 中, 然后依设置来决定是否弹出 &lt;code&gt;RequestContext&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;def auto_pop(self, exc):
    # 通过设置 flask._preserve_context 来保留 context
    # 出错了, 并且通过配置文件设置了 PRESERVE_CONTEXT_ON_EXCEPTION
    # 这个会下次 push 的时候被弹出
    if self.request.environ.get('flask._preserve_context') or \
       (exc is not None and self.app.preserve_context_on_exception):
        self.preserved = True
        self._preserved_exc = exc
    else:
        # 弹出 RequestContext 才会回调 teardown_request
        self.pop(exc)

def pop(self, exc=_sentinel):
    # 非保留情况下, 会每次新创建一个 AppContext 压入 _implicit_app_ctx_stack
    app_ctx = self._implicit_app_ctx_stack.pop()

    try:
        clear_request = False
        # 一般情况下 _implicit_app_ctx_stack 只有一个 AppContext, 上面已经弹出
        if not self._implicit_app_ctx_stack:
            self.preserved = False
            self._preserved_exc = None
            if exc is _sentinel:
                exc = sys.exc_info()[1]
            # app 级别的 teardown_request
            self.app.do_teardown_request(exc)
            if hasattr(sys, 'exc_clear'):
                sys.exc_clear()

            request_close = getattr(self.request, 'close', None)
            if request_close is not None:
                request_close()
            clear_request = True
    finally:
        rv = _request_ctx_stack.pop()

        # get rid of circular dependencies at the end of the request
        # so that we don't require the GC to be active.
        if clear_request:
            rv.request.environ['werkzeug.request'] = None

        # Get rid of the app as well if necessary.
        if app_ctx is not None:
            app_ctx.pop(exc)

        assert rv is self, 'Popped wrong request context.  ' \
            '(%r instead of %r)' % (rv, self)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果在不保留 RequestContext 的话, 每次请求都会弹出 ReqeustContext 和 AppContext, 所以这也说明了如果我们在请求处理方法之外使用 RequestContext 或 AppContext 的话, 就会发生 Working outside of request context 这种情况.&lt;/p&gt;
&lt;h4&gt;3. &lt;code&gt;request&lt;/code&gt;, &lt;code&gt;current_app&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, &lt;code&gt;session&lt;/code&gt; 全局代理&lt;/h4&gt;
&lt;p&gt;从由 &lt;code&gt;_app_ctx_stack&lt;/code&gt; 获得的,  这两个代理, 特别是 &lt;code&gt;g&lt;/code&gt; 代理, 一般我们把一个全局的东西&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;current_app&lt;/code&gt; 指向是当前的 &lt;code&gt;flask.app.Flask&lt;/code&gt; 对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g&lt;/code&gt; 指向的是当前的 &lt;code&gt;flask.app.Flask&lt;/code&gt; 对象 &lt;code&gt;g&lt;/code&gt; 字典, 一般用来&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当使用 &lt;code&gt;with Flask.app_context()&lt;/code&gt; 的时候, 在 &lt;code&gt;with&lt;/code&gt; 语句内 &lt;code&gt;current_app&lt;/code&gt; 便会指向当前的 &lt;code&gt;Flask&lt;/code&gt; 对象.  我们也知道在请求到来的时候, &lt;code&gt;RequestContext.push()&lt;/code&gt; 也会把 &lt;code&gt;AppContext&lt;/code&gt; 压入栈中, 此时 &lt;code&gt;current_app&lt;/code&gt; 也是可以使用的. &lt;code&gt;g&lt;/code&gt; 对象则是 &lt;code&gt;AppContext&lt;/code&gt; 中的一个&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;current_app = LocalProxy(_find_app)
g = LocalProxy(_partial(_loopku_app_object, 'g'))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从由 &lt;code&gt;_request_ctx_stack&lt;/code&gt; 获得的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;request&lt;/code&gt; 指向是当前请求 &lt;code&gt;flask.wrappers.Request&lt;/code&gt; 对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;session&lt;/code&gt; 指向是当前的 session, &lt;code&gt;flask.sessions.SecureCookieSession&lt;/code&gt; 对象&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;# 这两个都是代理对象, 经过 RequestContext 中取得其内部的值
request = LocalProxy(partial(_lookup_req_object, 'request'))
session = LocalProxy(partial(_lookup_req_object, 'session'))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;_lookup_xx_object&lt;/code&gt; 中都是调用对应的 &lt;code&gt;_ctx_xx_stack.top&lt;/code&gt;, 这里检查了 &lt;code&gt;top&lt;/code&gt; 是否存在, 不存在的话抛出 &lt;code&gt;RuntimeError&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;class LocalProxy(object):
    """代理类的源码, 主要是 __getattr__, __getitem__, __setitem__ 这些对应到内部的
       真正的对象
    """
    __slots__ = ('__local', '__dict__', '__name__', '__wrapped__')

    # self.__local 便是我们传入的查找函数
    def __init__(self, local, name=None):
        object.__setattr__(self, '_LocalProxy__local', local)
        object.__setattr__(self, '__name__', name)
        if callable(local) and not hasattr(local, '__release_local__'):
            object.__setattr__(self, '__wrapped__', local)

    def _get_current_object(self):
        # 返回了对应的 _lookup_*_object, 也就是对应的 RequestContext, 或 AppContext
        if not hasattr(self.__local, '__release_local__'):
            return self.__local()
        try:
            return getattr(self.__local, self.__name)
        except AttributeError:
            raise RuntimeError('no object bound to %s' % self.__name)

    # 我们在使用 request.args 这样的方法时, 其实就是 
    # RequestContext['request'][name]
    # 这样就回到了 _request_ctx_stack.request[name] 了
    def __getattr__(self, name):
        if name == '__members__':
            return dir(self._get_current_object())
        return getattr(self._get_current_object(), name)

    def __setitem__(self, key, value):
        self._get_current_object()[key] = value&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以这也说明了为什么当 outside context, &lt;code&gt;current_app&lt;/code&gt;, &lt;code&gt;request&lt;/code&gt;, &lt;code&gt;session&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt; 这些代理都是不可用的, 这些代理都是去 &lt;code&gt;_request_ctx_stack&lt;/code&gt; 或 &lt;code&gt;_app_ctx_stack&lt;/code&gt; 查找对应的值. 当我们使用 &lt;code&gt;with flaks_app.app_context()&lt;/code&gt; 的时候, 会帮我们压入一个 &lt;code&gt;AppContext&lt;/code&gt; 来使用, 并帮我们管理上下文. &lt;/p&gt;</content><category term="flask"></category><category term="python"></category><category term="源代码阅读"></category><category term="RTFSC"></category></entry><entry><title>RTFSC: Flask 的源码阅读(一)</title><link href="https://ivicel.info/2018/09/rtfsc-flask-de-yuan-ma-yue-du-yi.html" rel="alternate"></link><published>2018-09-18T00:00:00+08:00</published><updated>2018-09-18T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-09-18:/2018/09/rtfsc-flask-de-yuan-ma-yue-du-yi.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;使用自带的单线程 server 看源码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;1. 从 WSGI 开始&lt;/h4&gt;
&lt;p&gt;一个最简单的 Flask 程序&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;from flask import Flask

app = Flask(__file__)

@app.route('/')
def index():
    return 'Hello, world'

if __name__ == '__main__':
    app.run()&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;run()&lt;/code&gt; 方法中可以看到调用了 &lt;code&gt;werkzeug.serving.run_simple()&lt;/code&gt; 来运行, 传入的的 &lt;code&gt;WSGI&lt;/code&gt; 应用就是 &lt;code&gt;self&lt;/code&gt; 也就是 &lt;code&gt;Flask&lt;/code&gt; 对象. 根据 &lt;code&gt;WSGI&lt;/code&gt; 协议, 其必定是一个 &lt;code&gt;callable_appliaction(environ, start_response …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;使用自带的单线程 server 看源码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;1. 从 WSGI 开始&lt;/h4&gt;
&lt;p&gt;一个最简单的 Flask 程序&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;from flask import Flask

app = Flask(__file__)

@app.route('/')
def index():
    return 'Hello, world'

if __name__ == '__main__':
    app.run()&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;run()&lt;/code&gt; 方法中可以看到调用了 &lt;code&gt;werkzeug.serving.run_simple()&lt;/code&gt; 来运行, 传入的的 &lt;code&gt;WSGI&lt;/code&gt; 应用就是 &lt;code&gt;self&lt;/code&gt; 也就是 &lt;code&gt;Flask&lt;/code&gt; 对象. 根据 &lt;code&gt;WSGI&lt;/code&gt; 协议, 其必定是一个 &lt;code&gt;callable_appliaction(environ, start_response)&lt;/code&gt;. 所以下来查看类对象的 &lt;code&gt;__call__()&lt;/code&gt; 方法. 可以看到真正的 &lt;code&gt;WSGI&lt;/code&gt; 定义是 &lt;code&gt;Flask.wsgi_app()&lt;/code&gt; 方法. &lt;/p&gt;
&lt;p&gt;代码文档也说明了这样定义的原因, 就是方便我们使用时做 &lt;code&gt;Middleware&lt;/code&gt;, 只要 &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;app.wsgi_app = MyMiddleware(app.wsgi_app)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们依旧还能使用 &lt;code&gt;Flask&lt;/code&gt; 来方便的处理各种 HTTP 请求.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;def wsgi_app(self, environ, start_response):
    # 生成请求上下文
    ctx = self.request_context(environ)
    error = None
    try:
        try:
            # 将其入栈
            ctx.push()
            # 派发请求 url 到对应的处理方法中
            response = self.full_dispatch_request()
        except Exception as e:
            # 属于 HTTP 错误, 记录出错情况, 404, 501, 403...
            error = e
            response = self.handle_exception(e)
        except:
            # 系统程序错误
            error = sys.exc_info()[1]
            # 向上抛, 告知 WSGI server 程序产生了错误
            raise
        # 有 HTTP 返回结果
        return response(environ, start_response)
    finally:
        # 
        if self.should_ignore_error(error):
            error = None
        # 请求完毕时, 将请求出栈
        ctx.auto_pop(error)&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. 请求上下文都初看&lt;/h4&gt;
&lt;p&gt;在进入到 WSGI 之后, 根据传入的环境变量 &lt;code&gt;environ&lt;/code&gt; 生成一个请求上下文对象 &lt;code&gt;RequestContext&lt;/code&gt;, 调用对象的 &lt;code&gt;push&lt;/code&gt; 方法.&lt;/p&gt;
&lt;p&gt;根据类的文档, 上下文把当前请求相当的东西都压入栈,  然后在请求完毕的时候把这些都出栈. 这个栈指的就是 &lt;code&gt;flask.global._request_ctx_stack&lt;/code&gt;, 并且在弹出栈时, 调用所有在 &lt;code&gt;flask.Flask.teardown_request&lt;/code&gt; 的注册方法.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;class RequestContext(object):
    def __init__(self, app, environ, request=None):
        # app 就是 Flask() 对象
        self.app = app
        # 默认的 flask.wrapper.Request 实现是从 werkzeug.wrappers.Request 继承 
        # 这样方便我们自己实现自己的 Request
        if request is None:
            request = app.request_class(environ)
        self.request = request
        # 创建一个 werkzeug.routing.MapAdapter 用于检测匹配 url
        self.url_adapter = app.create_url_adapter(self.request)
        self.flashes = None
        self.session = None
        self._implicit_app_ctx_stack = []
        self.preserved = False
        self._preserved_exc = None
        self._after_request_functions = []
        # 在这里对 url 进行了匹配
        # self.request.url_rule 保存了匹配的 url
        # self.request.view_args 保存了匹配的 query_args
        # 匹配失败的话, self.request.routing_exception 保存了异常对象
        self.match_request()&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;3. 所以什么是上下文: RequestContext, AppContext&lt;/h4&gt;
&lt;p&gt;flask 中实现了两个全局的上下文栈, &lt;code&gt;flask.globals&lt;/code&gt; 文件内&lt;/p&gt;
&lt;p&gt;1) 请求上下文 &lt;code&gt;_request_ctx_stack&lt;/code&gt;, 用来保存每一次 &lt;code&gt;HTTP Request&lt;/code&gt; 的大部分信息, 每次请求开始时都会压入栈中, 在请求结束时被弹出栈. &lt;/p&gt;
&lt;p&gt;2) 应用上下文, 根据 &lt;code&gt;WSGI&lt;/code&gt; 协议, &lt;code&gt;WSGI&lt;/code&gt; 分为 &lt;code&gt;Server&lt;/code&gt;, &lt;code&gt;Client&lt;/code&gt;, &lt;code&gt;Middleware&lt;/code&gt; 三种部件, 但这三种限定也是模糊的. 只要实现 &lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; 端两个方向的都可以叫 &lt;code&gt;Middleware&lt;/code&gt;. 所以我们可以把 &lt;code&gt;Flask&lt;/code&gt; 请求再一次传给另一个 &lt;code&gt;WSGI Application&lt;/code&gt; 来处理, 比如 &lt;code&gt;Django&lt;/code&gt; 或者多个 &lt;code&gt;Flask&lt;/code&gt; 程序, 或者处理完成再返还给 &lt;code&gt;Flask&lt;/code&gt;, 这就有一个应用上下文. 而 flask 自己的应用上下文是在第一次收到 &lt;code&gt;request&lt;/code&gt; 的时候生成的.&lt;/p&gt;
&lt;p&gt;上下文指的是, 简单理解就是记录&lt;strong&gt;一定区域内的信息&lt;/strong&gt;, 离开这个区域, 这个信息就不存在了, 在这个区域内保证了一定的操作. 比如&lt;code&gt;with open&lt;/code&gt;, 我们可以保证 打开/关闭 操作, 在这之内是 可读/可写 的. &lt;/p&gt;
&lt;p&gt;&lt;code&gt;Flask&lt;/code&gt; 内实现的上下文其实只是一个 Python 字典, 字典每一个值就对应一个 stack, 是一个 list. 因为请求是并发/并行的, 也有可能多个应用程序在同时运行.  所以字典的 key 是一个需要能区分不同线程/进程的值.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;try:
    # 首选 greenlet 的当前运行 greenlet 对象的标识符
    from greenlet import getcurrent as get_ident
except ImportError:
    # 没有安装 greenlet 时, 使用当前线程的 thread_local 标识, 注意 py2/3 的兼容
    try:
        from thread import get_ident
    except ImportError:
        from _thread import get_ident&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;两个上下文都是一个栈, 都定义在 &lt;code&gt;flask.globals&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;_request_ctx_stack = LocalStack()
_app_ctx_stack = LocalStack()&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;栈的实现在 &lt;code&gt;werkzeug.local&lt;/code&gt; 中&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;class Local(object):
    """
        实际底层的数据实现, 使用 __slots__ 避免占用大量内存
        __storage__ 为实际储存数据的字典
        __ident_func__ 为 __storage__ 的 key
        实现了一些 magic method 都很简单, 主要是要 get_ident
    """
    __slots__ = ('__storage__', '__ident_func__')

    def __init__(self):
        object.__setattr__(self, '__storage__', {})
        object.__setattr__(self, '__ident_func__', get_ident)

    def __iter__(self):
        return iter(self.__storage__.items())

    def __call__(self, proxy):
        """Create a proxy for a name."""
        return LocalProxy(self, proxy)

    def __release_local__(self):
        self.__storage__.pop(self.__ident_func__(), None)
    # 因为我们把数据存储到 __storage__ 中, 对应的 setter, getter 方法
    def __getattr__(self, name):
        try:
            return self.__storage__[self.__ident_func__()][name]
        except KeyError:
            raise AttributeError(name)

    def __setattr__(self, name, value):
        ident = self.__ident_func__()
        storage = self.__storage__
        # 每个独立的线程或者 greentlet 对象都有一个保存自己的字典
        # 比如在多线程状态下多个 request 时, 就有
        # 每个 request 都在 storage[thread_identification] = {'request': value}
        # 注意存进来的 name 其实是最后的 key
        try:
            storage[ident][name] = value
        except KeyError:
            storage[ident] = {name: value}

    def __delattr__(self, name):
        try:
            del self.__storage__[self.__ident_func__()][name]
        except KeyError:
            raise AttributeError(name)


class LocalStack(object):
    """
        栈的实现, 回过来看
        请求上下文: _request_ctx_stack = LocalStack()
        应用上下文: _app_ctx_stack = LocalStack()
    """

    def __init__(self):
        self._local = Local()

    def __release_local__(self):
        self._local.__release_local__()

    def push(self, obj):
        """
            当在 RequestContext 里调用 _request_ctx_stack.push 时, 也就是相当
            Local.__storage__[Local.__ident_func__()]['stack'] = [RequestContext()]
            对于 _app_ctx_stack, 就是存了 AppContext 对象而已
        """
        rv = getattr(self._local, 'stack', None)
        if rv is None:
            self._local.stack = rv = []
        rv.append(obj)
        return rv

    def pop(self):
        """
            弹出栈顶元素, 当最后只有一个元素在栈中的时候, 这时再弹出元素时, 会把这个栈置为 None
            原因应该是因为这个实现 Request 也是要用的, 请求结束了, 这线程也不需要了
            最终调用的是 Local.__release_local__
            其实就是 __storage__.pop(__ident_func__(), None)
        """
        stack = getattr(self._local, 'stack', None)
        if stack is None        if stack is None:
            return None
        elif len(stack) == 1:
            release_local(self._local)
            return stack[-1]
        else:
            return stack.pop()

    @property
    def top(self):
        """返回栈顶"""
        try:
            return self._local.stack[-1]
        except (AttributeError, IndexError):
            return None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上下文其实是很简单的结构, 关键是怎么使用, 回过来, 我们知道, 请求到来时, 使用环境变量生成了一个请求上下文, 然后调用了对象的 &lt;code&gt;RequestContext.push()&lt;/code&gt; 方法&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;class RequestContext(object):
    def push(self):
        # 查找当前请求栈中顶端的请求, 这里的 top 是 RequestContext 对象, 第一次为 None,
        top = _request_ctx_stack.top
        # RequestContext.preserved 代表这个请求是否保留,
        # 在下一个请求(同一线程中)到来时, 把保留的请求弹出
        if top is not None and top.preserved:
            top.pop(top._preserved_exc)
        # 确保这个请求栈带有应用上下文 AppContext 对象
        # 如果请求被保留的话那么 app_ctx 不为 None, 这时我们就不再创建新的 AppContext
        app_ctx = _app_ctx_stack.top
        if app_ctx is None or app_ctx.app != self.app:
            app_ctx = self.app.app_context()
            app_ctx.push()
            self._implicit_app_ctx_stack.append(app_ctx)
        else:
            self._implicit_app_ctx_stack.append(None)
        # py3 移除了该方法, 清除当前线程的 exception 信息
        if hasattr(sys, 'exc_clear'):
            sys.exc_clear()
        # 压入 Request 栈中
        _request_ctx_stack.push(self)
        # 第一次请求时, 创建一个新的 session
        if self.session is None:
            session_interface = self.app.session_interface
            self.session = session_interface.open_session(
                self.app, self.request
            )
            # 默认的 session 是实现在内存中的 python 对象
            # 当网站并发达到一定规模或者需要分布式时, 我们也可以使用 redis 这样的数据库来实现
            if self.session is None:
                self.session = session_interface.make_null_session(self.app)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就清楚了, &lt;code&gt;_request_ctx_stack&lt;/code&gt; 为我们保存了每一次的请求对象, 而且这个 &lt;code&gt;RequestContext&lt;/code&gt; 对象还有对应指 &lt;code&gt;WSGI&lt;/code&gt; 应用上下文, 存在对应的 &lt;code&gt;_app_ct_stack&lt;/code&gt; 相同的线程标识符里的字典. 另外还有从客户端发过来的对应 &lt;code&gt;session&lt;/code&gt; 信息, 这样回应一个请求的信息都具备完了.&lt;/p&gt;
&lt;h4&gt;Reference:&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://github.com/pallets/flask"&gt;https://github.com/pallets/flask&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/pallets/werkzeug"&gt;https://github.com/pallets/werkzeug&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://flask.pocoo.org"&gt;http://flask.pocoo.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://werkzeug.pocoo.org"&gt;http://werkzeug.pocoo.org&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="flask"></category><category term="python"></category><category term="源代码阅读"></category><category term="RTFSC"></category></entry><entry><title>基于 uwsgi 的实现 flask 的 websocket 连接 -- steamkey 的移植</title><link href="https://ivicel.info/2018/09/ji-yu-uwsgi-de-shi-xian-flask-de-websocket-lian-jie-steamkey-de-yi-zhi.html" rel="alternate"></link><published>2018-09-10T00:00:00+08:00</published><updated>2018-09-10T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-09-10:/2018/09/ji-yu-uwsgi-de-shi-xian-flask-de-websocket-lian-jie-steamkey-de-yi-zhi.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/ivicel/steam-key-python"&gt;steam-key-python&lt;/a&gt; 是 &lt;a href="https://github.com/zyfworks/steam-key"&gt;steam-key&lt;/a&gt; 的python 移植, 原开发基于 node.js.&lt;/p&gt;
&lt;p&gt;使用到的主要开发包:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/ValvePython/steam"&gt;steam&lt;/a&gt; 一个用 python 实现的 steamkit&lt;/li&gt;
&lt;li&gt;flask web 框架&lt;/li&gt;
&lt;li&gt;gevent 异步框架&lt;/li&gt;
&lt;li&gt;uwsgi 后端 server&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;1. flask 结合 websocket 问题&lt;/h5&gt;
&lt;p&gt;根据 Websocket 协议, 从 HTTP 升级到 Websocket 要发送以下 GET 请求, 来协商&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code&gt;GET /websocket HTTP/1.1
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Version: 13
Sec-WebSocket-Key …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/ivicel/steam-key-python"&gt;steam-key-python&lt;/a&gt; 是 &lt;a href="https://github.com/zyfworks/steam-key"&gt;steam-key&lt;/a&gt; 的python 移植, 原开发基于 node.js.&lt;/p&gt;
&lt;p&gt;使用到的主要开发包:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/ValvePython/steam"&gt;steam&lt;/a&gt; 一个用 python 实现的 steamkit&lt;/li&gt;
&lt;li&gt;flask web 框架&lt;/li&gt;
&lt;li&gt;gevent 异步框架&lt;/li&gt;
&lt;li&gt;uwsgi 后端 server&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;1. flask 结合 websocket 问题&lt;/h5&gt;
&lt;p&gt;根据 Websocket 协议, 从 HTTP 升级到 Websocket 要发送以下 GET 请求, 来协商&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code&gt;GET /websocket HTTP/1.1
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: KSk4Wty1NJInqzWMBbQqCQ==&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们收到这个请求时, 返回一个 response 来确定升级到&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code&gt;HTTP/1.1 101 Switching Protocols
Server: nginx/1.15.3
Date: Thu, 13 Sep 2018 05:56:14 GMT
Connection: upgrade
Upgrade: websocket
Sec-WebSocket-Accept: B1HnOTYR2fZO2PT0y6LImuBQtzQ=&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要让 flask 支持 websocket, 就要做到两点.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获得原始的 TCP 连接, 而我们的 WSGI 程序获得的是只要环境变量和一个回调函数, 如 &lt;code&gt;def application(environ, start_response)&lt;/code&gt;. 这样的话, 我们可以在最底层的 &lt;code&gt;middleware&lt;/code&gt; 里把 socket 连接放到 environ 变量中, 比如 &lt;code&gt;environ['socket']&lt;/code&gt;, 这样无论我们在哪一个中间件里都可以处理到最原始的连接. &lt;/li&gt;
&lt;li&gt;在获得到 TCP 连接后, 由于 Websocket 是基于 message 而不是基于 stream 的, 我们还需要实现 websocket 协议, 接管请求到 &lt;code&gt;/websocket&lt;/code&gt; 的连接, 比如 ping/pong, send/receive&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上两点 uWSGI 已经帮我们实现好, 在 &lt;a href="https://uwsgi-docs.readthedocs.io/en/latest/WebSockets.html"&gt;uWSGI 文档&lt;/a&gt;中提到了当使用 &lt;code&gt;--http-socket&lt;/code&gt; 参数来运行的 wsgi 应用时, 只要我们检查 &lt;code&gt;environ['HTTP_SEC_WEBSOCKET_KEY']&lt;/code&gt; 变量, 这是升级到 websocket 里的请求, 便可知道该连接之后想升级到 websocket. uWSGI 已经帮我们把实现了 websocket 协议, 我们只要使用以下几个接口即可&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;# 确定发回 Connection upgrade
uwsgi.websocket_handshake([key, origin, proto])

uwsgi.websocket_recv()
uwsgi.websocket_send(msg)
uwsgi.websocket_send_binary(msg) (added in 1.9.21 to support binary messages)
uwsgi.websocket_recv_nb()
uwsgi.websocket_send_from_sharedarea(id, pos) &lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;2. flask 和 gevent 问题&lt;/h5&gt;
&lt;p&gt;Flask 是同步执行的, 我们主要的请求都在 websocket 中, 所以我们只在每一个 websocket upgrade request 中 patch 所有的 socket 即可. &lt;/p&gt;
&lt;h5&gt;3. 代码实现&lt;/h5&gt;
&lt;p&gt;前面说到, 因为要检测 &lt;code&gt;environ&lt;/code&gt; 的值, 我们可以使用一个中间件 &lt;code&gt;WebsocketMiddleware&lt;/code&gt;, 这样当我们生成 &lt;code&gt;ws = Websocket(app)&lt;/code&gt;, 然后使用 &lt;code&gt;@ws.route('/ws')&lt;/code&gt; 时便说明, url &lt;code&gt;/ws&lt;/code&gt; 使用 websocket 连接.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code&gt;uWSGI ------ Websocket Middleware ---if is websocket---&amp;gt; Websocket Application 
                     |
                     | else
                     |
              Flask Application&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看 flask 的源码可以看到在类 Flask 的最终实现 wsgi 协议的是方法 &lt;code&gt;wsgi_app()&lt;/code&gt;, 并且源码里也说明了最好的中间件实现方式. &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;# 简化实现说明
from flask import Flask
from .websocket import Websocket

app = Flask(__name__)
# websocket_application
ws = Websocket(app)

@app.route('/')
def index():
    return re

# 我们会把 websocket 连接对象传给处理函数
# ws 参数是一个按 websocket 标准接口实现的包装对象
# 只需按标准接口调用
@ws.route('/ws')
def websocket_connect(ws):
    while not ws.closed:
        msg = ws.receive()
        print('receive message: {!r}'.format(msg))
        ws.send(msg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要类的实现, &lt;code&gt;Websocket&lt;/code&gt; 类实现了一个 WGSI 协议, 接收从 uWSGI 的回调, 然后将请求放到 &lt;code&gt;WebsocketMiddleware&lt;/code&gt; 中判断是否为 websocket, 不是的话发送到 flask application 来处理&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;import uwsgi
import gevent
from gevent.queue import Empty, Queue
from gevent.event import Event
from gevent.select import select as gselect
from gevent.monkey import patch_all
from werkzeug.routing import Map, Rule
from werkzeug.exceptions import HTTPException

# Websocket 类
class WebSocket(object):
    def __init__(self, app):
        # 路由表
        self.url_map = Map()
        # 路由处理函数
        self.view_functions = {}
        # 在这里将 wsgi 应用设置为 WebSocketMiddleware
        # 并且我们还保留了原 Flask.wsgi_app 的引用
        app.wsgi_app = WebSocketMiddleware(app.wsgi_app, self)

    def add_url_map(self, url, endpoint=None, view_func=None, **options):
        """添加到路由表"""

    def route(self, rule, **options):
        """路由表"""


# WebSocketMiddleware 类
class WebSocketMiddleware(object):
    def __init__(self, wsgi_app, websocket):
        # Fask application
        self.wsgi_app = wsgi_app
        # Websocket application
        self.ws = websocket

    def __call__(self, environ, start_response):
        # 当请求到达时, 我们先判断该路由是否在 websocket 中绑定了
        adapter = self.ws.url_map.bind_to_environ(environ)
        try:
            endpoint, args = adapter.match()
            handler = self.ws.view_functions[endpoint]
        except HTTPException:
            handler = None
        # websocket 的升级判断, 失败则使用 flask application 处理
        if handler is None or 'HTTP_SEC_WEBSOCKET_KEY' not in environ:    
            return self.wsgi_app(environ, start_response)

        # 回应客户端升级协议到 websocket
        uwsgi.websocket_handshake(environ['HTTP_SEC_WEBSOCKET_KEY'], environ.get('HTTP_ORIGIN', ''))

        # 使用 gevent 来处理, 发送消息的触发事件和队列
        send_event = Event()
        send_queue = Queue()
        # 接收消息的触发事件和队列
        recv_event = Event()
        recv_queue = Queue()

        # WebSocketWrapper 是一个包装类, 提供了众所周知的 websocket 接口
        client = WebSocketWrapper(environ, uwsgi.connection_fd(), send_event,
                                  send_queue, recv_event, recv_queue, self.ws.timeout)

        def listener(client):
            gselect([client.fd], [], [])
            recv_event.set()

        # handler 是我们的设置的路由函数, 在这我们派生出的 greenlet object 并把 weboscket wrapper 传给它
        handler = gevent.spawn(handler, client, *args)
        # 设置当 socket 可读, 也即是有消息从客户端发过来时的回调
        listening = gevent.spawn(listener, client)
        while True:
            if client.closed:
                recv_queue.put(None)
                listening.kill()
                handler.join(client.timeout)
                return ''

            # 一是路由回调需要发送消息, 消息会被加到发送队列等待发送
            # 二是发送队列里有消息需要发送
            # 三是从客户端那收到消息
            gevent.wait([handler, send_event, recv_event], None, 1)

            # 有消息需要发送
            if send_event.is_set():
                try:
                    while True:
                        msg = send_queue.get_nowait()
                        uwsgi.websocket_send(msg)
                except gevent.queue.Empty:
                    send_event.clear()
                except IOError:
                    client.closed = True
            elif recv_event.is_set():    # 接收到消息
                recv_event.clear()
                try:
                    message = uwsgi.websocket_recv_nb()
                    while message:
                        recv_queue.put(message)
                        message = uwsgi.websocket_recv_nb()
                    listening = gevent.spawn(listener, client)
                except IOError:
                    client.closed = True

            elif handler.ready():
                listening.kill()
                return ''&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完整代码在: &lt;a href="https://github.com/ivicel/steam-key-python"&gt;https://github.com/ivicel/steam-key-python&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;Reference&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://uwsgi-docs.readthedocs.io/en/latest/WebSockets.html"&gt;https://uwsgi-docs.readthedocs.io/en/latest/WebSockets.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/zeekay/flask-uwsgi-websocket/"&gt;https://github.com/zeekay/flask-uwsgi-websocket/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content><category term="python"></category><category term="flask"></category><category term="websocket"></category><category term="steam"></category><category term="steamkey"></category></entry><entry><title>python tips</title><link href="https://ivicel.info/2018/09/python-tips.html" rel="alternate"></link><published>2018-09-10T00:00:00+08:00</published><updated>2018-09-10T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-09-10:/2018/09/python-tips.html</id><summary type="html">&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;a = (1, 2, [3, 4])
a[2] += [5, 6]

# 以上在 python 3.6.5 中抛出了 TypeError, 但 a[2] 的值还是变成了 [3, 4, 5, 6]
# 这是因为 a[2] 在增量时是分成两步
# 一是把 a[2] 的列表值入栈, 扩展成 [3, 4, 5, 6], 这是成功的
# 二是赋值回给元组元素 a[2], 这一步就出现的 TypeError&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;不要把可变对象放在元组中&lt;/li&gt;
&lt;li&gt;列表增量赋值不是一个原子, 是分成两步进行的, 其实也可以从 list 没有实现 &lt;code&gt;__iadd__ …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;a = (1, 2, [3, 4])
a[2] += [5, 6]

# 以上在 python 3.6.5 中抛出了 TypeError, 但 a[2] 的值还是变成了 [3, 4, 5, 6]
# 这是因为 a[2] 在增量时是分成两步
# 一是把 a[2] 的列表值入栈, 扩展成 [3, 4, 5, 6], 这是成功的
# 二是赋值回给元组元素 a[2], 这一步就出现的 TypeError&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;不要把可变对象放在元组中&lt;/li&gt;
&lt;li&gt;列表增量赋值不是一个原子, 是分成两步进行的, 其实也可以从 list 没有实现 &lt;code&gt;__iadd__()&lt;/code&gt; 可以看出. 因为自增会调用该方法, 如果没有实现该方法, 便才会调用 &lt;code&gt;__add__()&lt;/code&gt; , 然后把结果赋值给原对象&lt;/li&gt;
&lt;li&gt;可以通过 &lt;code&gt;dis.dis&lt;/code&gt; 来查看 python 的字节码&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Python 代码会在何时运行&lt;/h4&gt;
&lt;h5&gt;1. 代码作用模块导入时&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;代码是从上到下运行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;各种 &lt;code&gt;import&lt;/code&gt; 语句&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般我们会把各种 &lt;code&gt;import&lt;/code&gt; 写在前面时, 会运行 &lt;code&gt;import&lt;/code&gt; 各种模块, 这个和 &lt;code&gt;Java&lt;/code&gt; 是不一样的, &lt;code&gt;Java&lt;/code&gt; 的 &lt;code&gt;import&lt;/code&gt; 只是一种声明并不运行.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全局各种语句&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如 &lt;code&gt;n = 3&lt;/code&gt;, &lt;code&gt;print('hello, world)&lt;/code&gt; 之类写在非函数, 类内的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类定义体&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如属性的初始化, &lt;strong&gt;写在非方法内的语句都会初始化运行&lt;/strong&gt;, 如果类内还有嵌套类, 嵌套类的定义体也会运行. 比如有下面类的定义&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;# print('initial A...'), print('initial B...') 语句 和 m = 3 会被运行

class A(object):
    m = 3
    print('initial A...')

    def __init__(self, a):
        self.a = a

    class B(object):
        print('initial B...')&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类的元类&lt;/strong&gt;
  类的元类会被调用来初始化类, 比如&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;# 作为 B 的元类, A.__new__, A.__init__ 都会被调用
class A(type):
    def __new__(meta, name, bases, attrs):
        # meta 是传入的元类, 也就是类 A 本身
        # name 是要初始化类的名称, 也就是字符 'B'
        # bases 是类 B 的基类, tuple 类型
        # attrs 是类 B 的属性, 包括方法和类属性
        # 最终交给 type 来初始化, 避免无限循环, 元类主要是中间拦截
        print('A.__new__()')
        return type.__new__(meta, name, bases, attrs)
  def __init__(cls, name, bases, attrs):
        # type.__new__ 会调用这个方法
        # cls 是生成的类
        print('A.__init__()')

class B(metaclass=A):
    def __init__&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;只有继承了 &lt;strong&gt;type&lt;/strong&gt; 的才能作为&lt;strong&gt;元类&lt;/strong&gt;, 元类的 &lt;code&gt;__new__&lt;/code&gt;, &lt;code&gt;__init__&lt;/code&gt; 参数是固定的 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;装饰器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;装饰器会被动行, 装饰器的运行顺序比如. &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;# 装饰器相当于 ClassThree = deco_alpha(ClassThree) 
# 所以是先被装饰者运行, 然后才到装饰器本身
@deco_alpha
class ClassThree():
  def m(self):
      pass&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;2. 从命令行中运行&lt;/h5&gt;
&lt;p&gt;跟导入时相同, 但会执行 &lt;code&gt;__name__ == '__main__':&lt;/code&gt; 中的语句&lt;/p&gt;</content><category term="tips"></category></entry><entry><title>数据结构(Python描述) 第 6 章 二叉树与树</title><link href="https://ivicel.info/2018/07/shu-ju-jie-gou-pythonmiao-shu-di-6-zhang-er-cha-shu-yu-shu.html" rel="alternate"></link><published>2018-07-30T00:00:00+08:00</published><updated>2018-07-30T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-07-30:/2018/07/shu-ju-jie-gou-pythonmiao-shu-di-6-zhang-er-cha-shu-yu-shu.html</id><summary type="html">&lt;h4&gt;1. 二叉树&lt;/h4&gt;
&lt;h5&gt;1.1 概念&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;不包含任何结点的称为&lt;strong&gt;空树&lt;/strong&gt;, 只包含一个结点称为&lt;strong&gt;单点树&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;没有子结点的称为&lt;strong&gt;树叶&lt;/strong&gt;, 非树叶结点称为&lt;strong&gt;分支结点&lt;/strong&gt;, 对于二叉树有左分支, 右分支&lt;/li&gt;
&lt;li&gt;一个结点的子结点个数称为该结点的&lt;strong&gt;度数&lt;/strong&gt;, 很明显度只能取 &lt;code&gt;[0, 1, 2]&lt;/code&gt; 三个值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路径&lt;/strong&gt;: 从祖先结点到子孙结点包含的一系列边, 称为路径. &lt;/li&gt;
&lt;li&gt;二叉树是分层的, 根结点所在为第 0 层. 树中结点的最大层数称为树的&lt;strong&gt;高度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;满二叉树&lt;/strong&gt;: 二叉树中的所有分支结点的度数都是 2&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩充二叉树&lt;/strong&gt;: 对于二叉树 T, 加入足够多的新的结点, 使 T 原有的结点的度都变成 2, 得到的这棵新树称为扩充二叉树. 扩充二叉树新加入的结点称为&lt;strong&gt;外部结点&lt;/strong&gt;, 原来的结点称为&lt;strong&gt;内部结点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;完全二叉树&lt;/strong&gt;: 对于高度为 h …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h4&gt;1. 二叉树&lt;/h4&gt;
&lt;h5&gt;1.1 概念&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;不包含任何结点的称为&lt;strong&gt;空树&lt;/strong&gt;, 只包含一个结点称为&lt;strong&gt;单点树&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;没有子结点的称为&lt;strong&gt;树叶&lt;/strong&gt;, 非树叶结点称为&lt;strong&gt;分支结点&lt;/strong&gt;, 对于二叉树有左分支, 右分支&lt;/li&gt;
&lt;li&gt;一个结点的子结点个数称为该结点的&lt;strong&gt;度数&lt;/strong&gt;, 很明显度只能取 &lt;code&gt;[0, 1, 2]&lt;/code&gt; 三个值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路径&lt;/strong&gt;: 从祖先结点到子孙结点包含的一系列边, 称为路径. &lt;/li&gt;
&lt;li&gt;二叉树是分层的, 根结点所在为第 0 层. 树中结点的最大层数称为树的&lt;strong&gt;高度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;满二叉树&lt;/strong&gt;: 二叉树中的所有分支结点的度数都是 2&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩充二叉树&lt;/strong&gt;: 对于二叉树 T, 加入足够多的新的结点, 使 T 原有的结点的度都变成 2, 得到的这棵新树称为扩充二叉树. 扩充二叉树新加入的结点称为&lt;strong&gt;外部结点&lt;/strong&gt;, 原来的结点称为&lt;strong&gt;内部结点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;完全二叉树&lt;/strong&gt;: 对于高度为 h 的二叉树, 其 h - 1 层及到根都是满结点的, 并且在 h 层的结点是从左向右填, 数量不定. 这说明满二叉树一定是棵完全二叉树&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;1.2 性质&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;在非空叉树第 i 层最多有 &lt;code&gt;2&amp;lt;sup&amp;gt;i&amp;lt;/sup&amp;gt; (i &amp;gt;= 0)&lt;/code&gt; 个结点 &lt;/li&gt;
&lt;li&gt;高度为 h 的二叉树, 最多有 &lt;code&gt;2&amp;lt;sup&amp;gt;h+1&amp;lt;/sup&amp;gt; - 1 (h &amp;gt;= 0)&lt;/code&gt; 个结点. 这其实是上面的一个推论, 如果每层都 是满的, 那么则有 &lt;code&gt;S = 1 + 2 + 4 + ... + 2&amp;lt;sup&amp;gt;h&amp;lt;/sup&amp;gt;&lt;/code&gt;, 则有 &lt;code&gt;2S  - S = 2&amp;lt;sup&amp;gt;h+1&amp;lt;/sup&amp;gt; - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对于任何非空二叉树 T, 如果其叶结点个数为 &lt;code&gt;n&amp;lt;sub&amp;gt;0&amp;lt;/sub&amp;gt;&lt;/code&gt;, 度数为 2 的结点个数为 &lt;code&gt;n&amp;lt;sub&amp;gt;2&amp;lt;/sub&amp;gt;&lt;/code&gt;, 那么有 &lt;code&gt;n&amp;lt;sub&amp;gt;0&amp;lt;/sub&amp;gt; = n&amp;lt;sub&amp;gt;2&amp;lt;/sub&amp;gt; + 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;满二叉树中, 分支结点比叶子结点多一个, 这是上面的推论&lt;/li&gt;
&lt;li&gt;扩充二叉树根到各个外部结点的路径和 E 与根到各个内部结点的路径和 I, 有 &lt;code&gt;E = I + 2 * n&lt;/code&gt;, 其中 n 为内部结点个数&lt;/li&gt;
&lt;li&gt;n 个结点的完全二叉树, 其高度 &lt;code&gt;h &amp;lt;= log&amp;lt;sub&amp;gt;2&amp;lt;/sub&amp;gt; n&lt;/code&gt;, 即 &lt;code&gt;h = floor(log&amp;lt;sub&amp;gt;2&amp;lt;/sub&amp;gt;N&lt;/code&gt;. 这是很容易证明, 对于一棵满二叉树, 其结点数有 &lt;code&gt;n = 2&amp;lt;sup&amp;gt;h + 1&amp;lt;/sup&amp;gt; - 1&lt;/code&gt;, 那么对于完全二叉树则有 &lt;code&gt;2&amp;lt;sup&amp;gt;h&amp;lt;/sup&amp;gt; &amp;lt;= n &amp;lt;= 2&amp;lt;sup&amp;gt;h + 1&amp;lt;/sup&amp;gt; - 1&lt;/code&gt;, h, n 都是整数, 则 h 是不大于 &lt;code&gt;log&amp;lt;sub&amp;gt;2&amp;lt;/sub&amp;gt;N&lt;/code&gt; 的整数&lt;/li&gt;
&lt;li&gt;在完全二叉树, 对于任意结点&lt;code&gt;i (0 &amp;lt;= i &amp;lt;= n - 1, n 为结点总数)&lt;/code&gt;, 其左子结点(如果有)为 &lt;code&gt;2 * i + 1&lt;/code&gt;, 右子结点(如果有)为 &lt;code&gt;2 * i + 1&lt;/code&gt;. 我们还可以算出该结点的父结点(如果有)位置为 &lt;code&gt;floor((i - 1) / 2)&lt;/code&gt;. 这是由上面推出来的, 父结点位置应该在区间 &lt;code&gt;((j - 2) / 2, (j - 1) / 2)&lt;/code&gt; 并且是一个整数, 所以对这两个边界作向上或向下取整即可&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;1.3 遍历方式&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;深度优先遍历&lt;/strong&gt;, 这种遍历方法, 在使用非递归实现时, 由于先有上层才有下层, 但我们是要先访问下层, 所以是一个&lt;strong&gt;后进先出(LIFO)&lt;/strong&gt;的栈结构.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;记忆技巧: 三种方法区别方式都是对根来说的, 对于每一棵树, 都最多只有三个结点, 就是 根, 左结点, 右结点, 对于每一棵子树, 我们都要执行一样的遍历顺序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;先根序遍历 Pre-order&lt;/strong&gt;: 根 -&amp;gt; 左 -&amp;gt; 右. 在非递归的方法中, 使用一个辅助栈来保存上层的结点信息. 因为要先访问左结点要再访问右结点. 从栈内弹出结点的顺序就是我们要的遍历顺序, 当栈中为空的时候就完成遍历.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;循环体外先把根结点入栈&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;循环判断栈是否为空, 不为空的话, 弹出栈中结点, 对该节点 node 调用访问函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 node 有右结点, 则右结点入栈&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 node 有左结点, 则左结点入栈. 回到第 2 步&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;一直判断栈中没有节点为止&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;void preorder(BinaryTree *tree)
{
    if (tree == NULL || tree-&amp;gt;root == NULL) {
        return;
    }

    Stack *stack = (Stack *)malloc(sizeof(Stack));
    if (stack == NULL) {
        return;
    }
    stack-&amp;gt;push(tree-&amp;gt;root);
    Node *node = NULL;
    while (!stack-&amp;gt;isEmpty()) {
        node = stack-&amp;gt;pop();
        process(node);
        if (node-&amp;gt;right != NULL) {
            stack-&amp;gt;push(node-&amp;gt;right);   
        }

        if (node-&amp;gt;left != NULL) {
            stack-&amp;gt;push(node-&amp;gt;left);
        }
    }
    free(stack);
}&lt;/code&gt;&lt;/pre&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;中根序遍历 In-order&lt;/strong&gt;: 左 -&amp;gt; 根 -&amp;gt; 右. 依旧还使用一个栈作为辅助, 由于要保存父结点的信息, 所以父结点必须要入栈, 然后再向下访问左结点, 但当我们从栈中 &lt;code&gt;pop&lt;/code&gt; 出父结点时, 处理完后, 不能再访问其左结点, 避免造成死循环&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置一个变量 node, node 首先指向树的根结点, 设置一个栈&lt;/li&gt;
&lt;li&gt;循环判断当 栈不为空, 或者 node 指向不为&lt;code&gt;NULL&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;当 node 不为空, 我们把这个当作一个父结点入栈, 然后把 node 指向 node 的左结点, 回到循环条件.此时, 栈中已经有至少一个结点, 条件成立&lt;/li&gt;
&lt;li&gt;如果 node 此时指向 &lt;code&gt;NULL&lt;/code&gt;, 说明 node 往下再没有左子结点&lt;/li&gt;
&lt;li&gt;处理 node , 然后把 node 指向 node 的右子结点, 回到 循环条件&lt;/li&gt;
&lt;li&gt;这样通过两个条件先向下查找, 到底后再弹出, 弹出再查找其右结点&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;void inorder(BinaryTree *tree)
{
    Stack *stack = (Stack *)malloc(sizeof(Stack));
    if (stack == NULL) {
        return;
    }
    Node *node = tree-&amp;gt;root;
    while (!stack.isEmpty() || node != NULL) {
        if (node != NULL) {
            stack-&amp;gt;push(node);
            node = node-&amp;gt;left;
        } else {
            process(node);
            node = node-&amp;gt;right;
        }
    }
    free(stack);
}&lt;/code&gt;&lt;/pre&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;后根序遍历 Post-order&lt;/strong&gt;: 左 -&amp;gt; 右 -&amp;gt; 根. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单方法, 使用两个栈: 我们使用容易的对 &lt;strong&gt;前序遍历&lt;/strong&gt; 稍加修改便可以得到一个 &lt;strong&gt;根 -&amp;gt; 右 -&amp;gt; 左&lt;/strong&gt; 访问顺序栈 s1, 然后依次把这个遍历压入另一个栈 s2 中, 当 s1 遍历完成时, 对 s2 进行遍历我们便得到一个 &lt;strong&gt;左 -&amp;gt; 右 -&amp;gt; 根&lt;/strong&gt; 的遍历顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;void postorder(BinaryTree *tree)
{
    if (tree == NULL || tree-&amp;gt;root == NULL) {
        return;
    }

    Stack *s1 = (Stack *)malloc(sizeof(Stack));
    Stack *s2 = (Stack *)malloc(sizeof(Stack));
    if (s1 == NULL || s2 == NULL) {
        if (s2 == NULL) {
            free(s1);
        }
        return;
    }


    Node *node;
    s1-&amp;gt;push(tree-&amp;gt;root);
    while (!s1-&amp;gt;isEmpty()) {
        node = s1-&amp;gt;pop();
        s2-&amp;gt;push(node);
        if (s1-&amp;gt;left != NULL) {
            s2-&amp;gt;push(node-&amp;gt;left);
        }
        if (s1-&amp;gt;right != NULL) {
            s2-&amp;gt;push(node-&amp;gt;right)
        }
    }

    while (!s2-&amp;gt;isEmpty()) {
        process(s2-&amp;gt;pop())
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;当使用递归方式遍历时, 每次我们都是递归左子树再递归又子树, 所以这两次递归中, 每层函数在栈中都保存有递归节点, 不同的遍历方式只是体现在, 处理访问节点的时机不两路;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;void preorder(Node *node)
{
    if (node == NULL) {
        return;
    }
    process(node);
    preorder(node-&amp;gt;left);
    preorder(node-&amp;gt;right);
}

void inorder(Node *node)
{
    if (node == NULL) {
        return;
    }
    inorder(node-&amp;gt;left);
    process(node);
    inorder(node-&amp;gt;right);
}

void postorder(Node *node)
{
    if (node == NULL) {
        return;
    }
    postorder(node-&amp;gt;left);
    process(node);
    postorder(node-&amp;gt;right);
}&lt;/code&gt;&lt;/pre&gt;

&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;宽度优先遍历&lt;/strong&gt;: 把每一层的所有结点都访问完, 再访问下层. 一般我们都从同层的左边结点开始&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;2. 优先队列&lt;/h4&gt;
&lt;p&gt;优先队列是一种带权值的队列, 队列总保持一种可以按优先级的访问顺序. 根据需要从高到低或从低到高&lt;/p&gt;
&lt;h5&gt;2.1 基于线性表的实现&lt;/h5&gt;
&lt;p&gt;如果基于线表来实现优先队列, 从外部使用角度看, 我们只关心每一次出队的元素都是队列中优先级最高的, 向其中插入值时, 按优先级排到队列中最合适的位置. 这样插入的话可能出产生 &lt;code&gt;O(n)&lt;/code&gt;, 取出都是 &lt;code&gt;O(1)&lt;/code&gt;. 我们也可以不保持队列的存储顺序, 在取出时再查找最优先元素. 这样插入是 &lt;code&gt;O(1)&lt;/code&gt;, 取出是 &lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;
&lt;h5&gt;2.2 基于树形结构的实现&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;堆&lt;/strong&gt;: 堆是一种完全二叉树, 其有一个主要性质, 从任意一条&lt;strong&gt;根 -&amp;gt; 叶子结点的这条路径&lt;/strong&gt;, 总有 &lt;strong&gt;父结点 &amp;gt; 子结点&lt;/strong&gt; 的叫&lt;strong&gt;最大堆&lt;/strong&gt;, 反之叫&lt;strong&gt;最小堆&lt;/strong&gt;. 同一兄弟结点没有特定的大小关系&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;向上筛选&lt;/strong&gt;: 向堆中末尾插入一个结点, 这个结点跟其父结点比较大小, 根据需要来交换位置, 依次循环这两个操作, 直到确定位置, 或者到根结点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;向下筛选&lt;/strong&gt;: 当我们拿走根结点后, 其两个子树依然还是两个堆, 这样我们从原堆中取出最后一个结点, 因为我们取出最后一个结点, 堆序是不变. 把这个结点当作新的根结点, 形成新的二叉树. 对比两个左右子结点, 找到最小或大(根据堆序)的, 然后跟根结点比较, 如果根结点大小不合适, 那么交换这两结点, 然后在新的子树层里, 重复上两步比较操作. 这看起来就像结点在往树底下移动.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完全二叉树可以用一个线性的结构来表示, 我们只关心其父子结点的位置, 对于一个结点 i, 其左结点就是 &lt;code&gt;2 * i + 1&lt;/code&gt;, 右结点就是 &lt;code&gt;2 * i + 2&lt;/code&gt;, 其父结点就是 &lt;code&gt;floor((i - 1) / 2)&lt;/code&gt;. 所以用一个数组很容易的表示堆, 并且每个结点的访问都是 &lt;code&gt;O(1)&lt;/code&gt;.&lt;/p&gt;</content><category term="二叉树"></category><category term="树"></category><category term="堆"></category></entry><entry><title>数据结构(Python描述) 第 7 章 图</title><link href="https://ivicel.info/2018/07/shu-ju-jie-gou-pythonmiao-shu-di-7-zhang-tu.html" rel="alternate"></link><published>2018-07-29T00:00:00+08:00</published><updated>2018-07-29T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-07-29:/2018/07/shu-ju-jie-gou-pythonmiao-shu-di-7-zhang-tu.html</id><summary type="html">&lt;h4&gt;1. 概念, 性质, 实现&lt;/h4&gt;
&lt;h5&gt;1.1 定义&lt;/h5&gt;
&lt;p&gt;图是一个二元组 &lt;code&gt;G=(V, E)&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt; 是非空有穷的顶点集合, &lt;code&gt;E&lt;/code&gt; 是顶点的边, 也是顶点之间的相互直接联系&lt;/p&gt;
&lt;p&gt;图分为有向图, 无向图. 根据边的关系类型来分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;邻接点&lt;/strong&gt;: 无向图中, 相互连接起来的就叫邻接点, 有向图中, x 指向 y, y 是 x 的邻接点. 这个连接的边就叫 &lt;strong&gt;邻接边&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;顶点的 &lt;strong&gt;度&lt;/strong&gt;: 一个顶点有几条邻接边, 叫做该点的度. 对于无向图和邻接点是一个意思. 不过对于有向图就不一样了. 有&lt;strong&gt;出度&lt;/strong&gt;和&lt;strong&gt;入度&lt;/strong&gt;之分. 意思是指出去的方向的邻接边数量, 和指向自己的边的数量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路径长度&lt;/strong&gt;: 点 a 到点 b …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h4&gt;1. 概念, 性质, 实现&lt;/h4&gt;
&lt;h5&gt;1.1 定义&lt;/h5&gt;
&lt;p&gt;图是一个二元组 &lt;code&gt;G=(V, E)&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt; 是非空有穷的顶点集合, &lt;code&gt;E&lt;/code&gt; 是顶点的边, 也是顶点之间的相互直接联系&lt;/p&gt;
&lt;p&gt;图分为有向图, 无向图. 根据边的关系类型来分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;邻接点&lt;/strong&gt;: 无向图中, 相互连接起来的就叫邻接点, 有向图中, x 指向 y, y 是 x 的邻接点. 这个连接的边就叫 &lt;strong&gt;邻接边&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;顶点的 &lt;strong&gt;度&lt;/strong&gt;: 一个顶点有几条邻接边, 叫做该点的度. 对于无向图和邻接点是一个意思. 不过对于有向图就不一样了. 有&lt;strong&gt;出度&lt;/strong&gt;和&lt;strong&gt;入度&lt;/strong&gt;之分. 意思是指出去的方向的邻接边数量, 和指向自己的边的数量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路径长度&lt;/strong&gt;: 点 a 到点 b 的边的条数总和&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回路&lt;/strong&gt;: 起点和终点是相同的路径&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简单回路&lt;/strong&gt;: 回路里除起点和终点相同, 其他点都不相同&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简单路径&lt;/strong&gt;: 不包含回路的路径&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连通&lt;/strong&gt;: 存在一条路径使得顶点 x 可以到达顶点 y, 则叫 x 到 y 是连通的. 注意到, 在有向图中, x -&amp;gt; y 连通, 并不意味 y -&amp;gt; x 也是连通的&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.2 一些图有名字的图&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;有根图&lt;/strong&gt;: 图中至少存在一个顶点 v, 从顶点 v 能到图中的任意一个顶点, 意思顶点 v 和任意一个点都是连通的(&lt;strong&gt;注意边通不等于邻接&lt;/strong&gt;). 这个顶点 v 就叫图的 &lt;strong&gt;根&lt;/strong&gt;. &lt;em&gt;"至少"&lt;/em&gt; 两个字说明一个有根图中可能存在许多个根&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;完全图&lt;/strong&gt;: 任意两个顶点之间都互为邻接点的图. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;n 个顶点的无向完全图有 &lt;code&gt;n * (n - 1) / 2&lt;/code&gt; 条边&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;n 个顶点的有向完全图有 &lt;code&gt;n * (n - 1)&lt;/code&gt; 条边&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;连通图&lt;/strong&gt;: 连通图指的是对于图中的任意两个顶点x, y, 这两顶点都是连通的. 对于有向图和无向图连通图可以具体些. 在无向图中称为, &lt;strong&gt;连通无向图&lt;/strong&gt;, 在有向图中称为, &lt;strong&gt;强连通有向图&lt;/strong&gt;.  在强连通的有向图中需要注意的是, 两顶点的连通的路径是有可能不一样的, x -&amp;gt; y 可能是直接的, y -&amp;gt; x 就有可能绕路间接连通. 而对于无向图, 如果不存在回路的话, 路径是固定的. 这从看, 只有完全图一定是连通的, 反过就不一定了&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;强连通指是有向图, 无向图一般叫连通&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;最小连通图&lt;/strong&gt;: 指的是去掉任意一条边, 图不再是连通图&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;包含 &lt;code&gt;n&lt;/code&gt; 个顶点的最小连通无向图有 &lt;code&gt;n -1&lt;/code&gt;条边&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;最小根图&lt;/strong&gt;: 指的是去掉任意一条边, 图不再是有根图 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;包含 &lt;code&gt;n&lt;/code&gt; 个顶点的最小根图恰好包含 &lt;code&gt;n - 1&lt;/code&gt; 条边&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;子图&lt;/strong&gt;: 对于图 G=(V, E) 和图 G'=(V', E'), 总是有 &lt;code&gt;V' ⊆ V&lt;/code&gt; 而且 &lt;code&gt;E' ⊆ E&lt;/code&gt;, G' 便叫做 G 的子图. 所以任意图也是自己的子图&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;连通子图&lt;/strong&gt;: 一个图可能不是连通图, 但它的一些子图是连通图, 则叫这些子图为连通子图&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;极大连通子图(连通分量)&lt;/strong&gt;: 图 G 中的连通子图 G' 里, 不能再多加一个顶点或去掉任一条边, 否则就会导致子图不能构成连通, 要点是&lt;strong&gt;不能再添加.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这说明是 G' 取出的顶点不一定是最多的. 所以对于连通图来说, 连通分量就是它自己本身, 而对于非连通图来说, 有多种可能. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;而对于有向图来说, 称为&lt;strong&gt;极大强连通子图(强连通分量)&lt;/strong&gt;, 一个强连通图并不一定等于其本身&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;带权图&lt;/strong&gt;: 图中的每条边都有一个权值&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;1.2 图的表现形式&lt;/h5&gt;
&lt;p&gt;一般用两种形式来表现图, 一是邻接矩阵, 二是邻接表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;邻接矩阵&lt;/strong&gt;: 一个二维的数组, 图中的每一个元素表示其对应的顶点是否邻接. 如果是一个带权的邻接矩阵图, 一般我们会用一个无穷大来表示其不邻接. 然后可以用 0 来表示自身到自身是邻接的. 邻接矩阵的缺点就是占空间, 但其某个点到某个点是否为邻接是 &lt;code&gt;O(1)&lt;/code&gt;, 因为是数组实现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;邻接表&lt;/strong&gt;: 用一个数组来记录所有的顶点, 然后这个数组元素里的顶点都有一个指针指向一个自己邻接顶点集合, 这个集合可以用数组或者用链表来实现. 集合中的邻接点不同的位置会导致我们在遍历图时有不同的顺序. 邻接表就是省空间, 而且使用链表实现的邻接集合也是很容易添加新的邻接关系, 但在查找邻接关系所需时间就需要看具体实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;1.3 在 Python 中图数据的实现&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;用两个 &lt;code&gt;list&lt;/code&gt; 或者两个 &lt;code&gt;tuple&lt;/code&gt; 都能很好的实现邻接矩阵&lt;/li&gt;
&lt;li&gt;我们也可以自定义一种 &lt;code&gt;dict&lt;/code&gt; 对象, &lt;code&gt;{i: j}&lt;/code&gt; 来表示邻接映射关系, 这种实现可以让我们很容易在 &lt;code&gt;O(1)&lt;/code&gt; 查找到邻接关系, 但由于内置 &lt;code&gt;dict&lt;/code&gt; 是一个顺序储存的 hash 实现, 在大型图上我们需要的容量比图的实际容量大. 还有需要用到一些 python 小技巧, 我们并存储非邻接关系, 而是使用 &lt;code&gt;dict.get&lt;/code&gt; 来默认返回一个 &lt;code&gt;None&lt;/code&gt; 值, 这样所需空间可以小些&lt;/li&gt;
&lt;li&gt;利用 &lt;code&gt;bytearray&lt;/code&gt; 或者内置库 &lt;code&gt;array&lt;/code&gt; 来实现, 这两种都是可变类型&lt;/li&gt;
&lt;li&gt;自定义类型来实现邻接表, 比如集合以上方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;1.4 图的遍历算法&lt;/h5&gt;
&lt;p&gt;遍历指的是把图中的顶点都访问过一遍, 我们需要一个集合来记录已经访问过的顶点, 避免在回路中重复访问顶点, 另外一般图可能不是连通图, 我们可能需要重新选择一个起点来遍历图&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;深度优先&lt;/strong&gt;: 总是先一条路径走到黑, 然后再从邻接点里选一个再走, 直到所有顶点都遍历&lt;/li&gt;
&lt;li&gt;选择一个顶点 v, 然后把 v 的邻接点都&lt;strong&gt;入栈&lt;/strong&gt;, 标记 v 为遍历过&lt;/li&gt;
&lt;li&gt;从栈中弹出一个邻接点 v&lt;sub&gt;1&lt;/sub&gt;, 然后再把这个点的邻接点入栈, 把弹出的顶点标记为遍历过&lt;/li&gt;
&lt;li&gt;重复上面的事, 每当弹出一个, 都表示遍历, 然后会总是找下层的邻接点&lt;/li&gt;
&lt;li&gt;循环终止的条件有两个: 一是栈中没有元素, 二是所有点都被标记为遍历过(&lt;strong&gt;如果图不是连通图的话, 就有跟 v 不连通的顶点, 连通图就不用判断这个了&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;宽度优先&lt;/strong&gt;: 总是先访问该顶点所有的邻接点, 再访问下一层&lt;/li&gt;
&lt;li&gt;选择一个顶点, 然后把 v 的所有邻接点都入队列&lt;/li&gt;
&lt;li&gt;依次访问队列头的顶点, 然后把该顶点的邻接点都加到队尾中&lt;/li&gt;
&lt;li&gt;循环上面操作直到队列中没有顶点为止(&lt;strong&gt;在连通图中&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;2. 生成树&lt;/h4&gt;
&lt;h5&gt;2.1 什么是生成树&lt;/h5&gt;
&lt;p&gt;我们知道 1: 对于&lt;strong&gt;连通无向图/强连通图&lt;/strong&gt;, 从任意一个顶点 v 都能到达其他任意顶点; 2: 对于&lt;strong&gt;有根有向图&lt;/strong&gt;, 从根都可以到达任意一顶点. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生成树&lt;/strong&gt;: 对于图 G 生成树是具有 G 所有的顶点, 并且边数&lt;strong&gt;最少&lt;/strong&gt;的边通子图(因为条件是最少, 所以生成树不存在回路问题), 连通图的生成树可能有多个, 有根有向图只能是从根开始, 所以是一个&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成树的边数: 如果 n 个顶点的连通图 G  生成树包含恰好 &lt;code&gt;n - 1&lt;/code&gt; 条边, 所以在无向图的生成树就是其最小连通子图. 有向图的生成树中所有的边都位于从根到其他顶点的路径上&lt;/li&gt;
&lt;li&gt;包含 n 个顶点, m 个连通分量的无向图 G 的生成树恰好包含 &lt;code&gt;n - m&lt;/code&gt; 条边&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;2.2 生成树构造方法&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;依据图的深度优先算法构造的&lt;strong&gt;尝试优先生成树&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;依据图的广度优先算法构造的&lt;strong&gt;广度优先生成树&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3. 最小生成树&lt;/h4&gt;
&lt;p&gt;如果图是一个带权图, 那么其不同的生成树, 权值可能就不一样. 最小权值合的生成树便叫&lt;strong&gt;最小生成树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显然, 最小生成树也可能惟一. 下面是几种构造最小生成树的算法&lt;/p&gt;
&lt;h5&gt;3.1 Kruskal 算法&lt;/h5&gt;
&lt;p&gt;如果图 G = (V, E) 是一个包含 n 个顶点的连通图, 构造最小生成树步骤如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始时我们取 G 的所有的 n 个顶点, 形成一个孤立的图 &lt;code&gt;T = (V, {})&lt;/code&gt;. 这样每一个顶点都是自成一个连通分量&lt;/li&gt;
&lt;li&gt;将边集 E 中的按权值递增的顺序排序, 然后每次我们都取最小权值的边, 把这条边的对应关系填到 T 中&lt;/li&gt;
&lt;li&gt;不断重复上边的操作, 直到 T 中所有的顶点都包含在一个连通分量为止, 最后 T 便是一棵最小生成树&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;用来判断的条件我们可以构造一个集合, 初始时集合中包含所有的顶点, 每次找到一个邻接关系时, 把对应的邻接点都集合中去掉, 当的集合为空时, 便得到了最小生成树. &lt;/p&gt;
&lt;p&gt;而如果邻接边全都遍历过了, 并且集合也不为空, 说明没有得到最小生成树, 原图是不连通的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;3.2 Prim 算法&lt;/h5&gt;
&lt;p&gt;Prim 算法主要使用了 MST 性质:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设有 &lt;code&gt;G = (V, E)&lt;/code&gt; 图, U 是 V 的一个真子集, 当有一对邻接点(也是边) &lt;code&gt;e = (u, v), u ⊆ U, v ⊆ (V -U)&lt;/code&gt;, 也就是说, 这两个邻接点, 一个点 u 是在集合 U 中, 另一个点不在集合 U中, 并且点 v 是点 u 所有在集合 (V - U) 中邻接边可能会最小的. 这样的话, 图 G 必定有一棵包括边 e 的最小生成树&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;从图 G 中选取任一顶点 v&lt;sub&gt;0&lt;/sub&gt;, 放到集合 U 中, 这里 &lt;code&gt;U = {v&amp;lt;sub&amp;gt;0&amp;lt;/sub&amp;gt;}&lt;/code&gt;, 设一个初始的边集合 &lt;code&gt;E&amp;lt;sub&amp;gt;T&amp;lt;/sub&amp;gt; = {}&lt;/code&gt;, 那么有 &lt;code&gt;T = (U, E&amp;lt;sub&amp;gt;T&amp;lt;/sub&amp;gt;)&lt;/code&gt; 是一棵树, 初始时只包含一个顶点&lt;/li&gt;
&lt;li&gt;查找所有一个商战在集合 U 里而一个端点在集合 V - U 中的边, 也就是对于一个顶点 v, 找到其所有的邻接点, 并且这些个邻接点还没有和顶点 v 一样, 存在在集合 U 中,  我们找出这些点后, 取其中权值最小的边得到邻接点 v', 把 v' 存放到集合 U 中, 把 v 和 v' 的邻接关系 &lt;code&gt;e = (v, v'), v ⊆ U, v' ⊆ (V -U)&lt;/code&gt; 存放到第一步中的 &lt;code&gt;E&amp;lt;sub&amp;gt;T&amp;lt;/sub&amp;gt;&lt;/code&gt; 重复上面的步骤直到 &lt;code&gt;U = V&lt;/code&gt;, 也即是图 G 中的所有顶点 V 都一一存在于集合 U 中, 这时集合 &lt;code&gt;E&amp;lt;sub&amp;gt;T&amp;lt;/sub&amp;gt;&lt;/code&gt; 里有 &lt;code&gt;n - 1&lt;/code&gt; 条边, 子图 &lt;code&gt;T = (U, E&amp;lt;sub&amp;gt;T&amp;lt;/sub&amp;gt; )&lt;/code&gt; 就是 G 的最小生成树&lt;/li&gt;
&lt;/ol&gt;</content><category term="数据结构"></category><category term="图"></category><category term="python"></category><category term="python数据结构"></category></entry><entry><title>数据结构(Python描述) 第 8 章 字典与集合</title><link href="https://ivicel.info/2018/07/shu-ju-jie-gou-pythonmiao-shu-di-8-zhang-zi-dian-yu-ji-he.html" rel="alternate"></link><published>2018-07-29T00:00:00+08:00</published><updated>2018-07-29T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-07-29:/2018/07/shu-ju-jie-gou-pythonmiao-shu-di-8-zhang-zi-dian-yu-ji-he.html</id><summary type="html">&lt;p&gt;字典是一种支持基于关键码的数据存储与检索的数据结构, 也称就查找表, 映射, 关联表等.&lt;/p&gt;
&lt;h4&gt;1. 字典的线性表实现&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;使用一个数组来保存字典的 key, 如果我们不考虑重复问题, 每次添加新的 key 都是在末尾添加, 这样都是 &lt;code&gt;O(1)&lt;/code&gt;, 而在查找方面, 需要遍历所有的值, 所以是 &lt;code&gt;O(n)&lt;/code&gt;, 删除操作也是一样需要 O(n). 基于这种表的字典: &lt;/li&gt;
&lt;li&gt;数据结构和算法简单, 检索方便&lt;/li&gt;
&lt;li&gt;检索效率低, 当表很大时, 检索很耗时&lt;/li&gt;
&lt;li&gt;删除操作也很耗时, 删除后还需要移动后面的数据&lt;/li&gt;
&lt;li&gt;依旧使用的一个数组来实现. 不过我们会保持数组(key)处于一个有序的状态. 这样检索和删除时, 使用二分查找, 查找效率是 &lt;code&gt;O(logN)&lt;/code&gt;, 而在删除或者添加数据时, 为保证数组总是有序, 我们可能需要移动整个数组, 所以最差是 &lt;code&gt;O(n)&lt;/code&gt;. 这种实现方法也不适合经常添加, 删除数据, 而如果一次生成, 多次查找 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;字典是一种支持基于关键码的数据存储与检索的数据结构, 也称就查找表, 映射, 关联表等.&lt;/p&gt;
&lt;h4&gt;1. 字典的线性表实现&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;使用一个数组来保存字典的 key, 如果我们不考虑重复问题, 每次添加新的 key 都是在末尾添加, 这样都是 &lt;code&gt;O(1)&lt;/code&gt;, 而在查找方面, 需要遍历所有的值, 所以是 &lt;code&gt;O(n)&lt;/code&gt;, 删除操作也是一样需要 O(n). 基于这种表的字典: &lt;/li&gt;
&lt;li&gt;数据结构和算法简单, 检索方便&lt;/li&gt;
&lt;li&gt;检索效率低, 当表很大时, 检索很耗时&lt;/li&gt;
&lt;li&gt;删除操作也很耗时, 删除后还需要移动后面的数据&lt;/li&gt;
&lt;li&gt;依旧使用的一个数组来实现. 不过我们会保持数组(key)处于一个有序的状态. 这样检索和删除时, 使用二分查找, 查找效率是 &lt;code&gt;O(logN)&lt;/code&gt;, 而在删除或者添加数据时, 为保证数组总是有序, 我们可能需要移动整个数组, 所以最差是 &lt;code&gt;O(n)&lt;/code&gt;. 这种实现方法也不适合经常添加, 删除数据, 而如果一次生成, 多次查找, 效率就很高了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不管我们是使用数组或者链表来实现线性表, 其表现是一样的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在非有序实现中, 在表头插入时依旧是 O(1), 删除操作依旧顺序扫描整个表, 为 O(n)&lt;/li&gt;
&lt;li&gt;在有序实现中, 查找和插入都是 O(n). 因为链表都是得从表头开始查找&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;2. 基于散列表的实现&lt;/h4&gt;
&lt;h5&gt;2.1 简述&lt;/h5&gt;
&lt;p&gt;如果我们数据在计算机存储方式是连续的, 那么我们只要知道一个数据的下标, 那么我们查找数据时总是 O(1), 而如果这个下标正好是我们的 key 值的话, 那么这个字典的查找就很快了.&lt;/p&gt;
&lt;p&gt;基于这种想法, 带来的问题有:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据的 key 的不一定是整数&lt;/li&gt;
&lt;li&gt;即使 key 是整数, 可能也是很大的整数, 比如 18 位的身份证号就可能有 10&lt;sup&gt;18&lt;/sup&gt; 个数(不考虑非法数值情况)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决问题的方法是, 定义一个函数 h(key), 函数参数为 key 值, 然后我们总是能得到一个较小的整数值. 这个函数称之为 hash 函数, 或者散列函数&lt;/p&gt;
&lt;h5&gt;2.2 冲突问题&lt;/h5&gt;
&lt;p&gt;一般来说, key 的值是不确定性的, 可能会很大. 这就决定了, 如果我们在设计 hash 函数时产生的下标范围过小时, 在大量的 hash(key) 计算后, 总有可能得到相同的下标值. 比如我们采用 &lt;code&gt;mod 100&lt;/code&gt; 来计算下标, 如果 key 的范围是 10000 甚至以上, 总会有相同的下标产生. 这时我们就称之为产生了冲突.&lt;/p&gt;
&lt;p&gt;如果冲突过多, 会导致哈希表查找效率下降. 但如果要完全无冲突, 就得使用一个很大的表. 我们需要一个负载因子系数来衡量这种情况.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;负载因子 𝜶 = 散列表中实际数据大小 n / 散列表的存储大小 m&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一般我们都会取 0.70, 0.75 左右的值, 也就是说, 表中数据存储的了 70% 左右就考虑扩容&lt;/p&gt;
&lt;h5&gt;2.3 散列函数&lt;/h5&gt;
&lt;p&gt;散列函数的设计优劣会影响散列表的性能, 在设计散列函数时, 应当考虑以下几点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数的值要在设计的散列表下标范围内, 如果总是超出, 我们只能扩大散列表, 不然这下标是无意义的&lt;/li&gt;
&lt;li&gt;函数的值最好能均匀的分布在散列表中, 这说明更不容易产生的冲突&lt;/li&gt;
&lt;li&gt;函数的计算方式要简单快速. 这很明显, 如果 hash 比查找的时间长的多, 还不如直接查找来的快&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果我们知道 key 的范围或者一些相似的特征集合, 就能设计出最适合的散列函数, 甚至还可能不出现冲突. 不过只对特定的值, 一般我们面对的 key 值都是变化多端的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;数字分析法&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在给定的关键集合中, 分析出一些数字出现的频率, 从中选出分布情况较好的若干数字作为散列函数的值. 从这需要我们事先知道会出现的值的范围, 否则不能使用. &lt;/p&gt;
&lt;p&gt;比如给出若干 000125672, 000125873, 000125776, 000125472, 000125379, 000125672 这些个数字, 可以统计出个位和百位的集合像, 62, 73, 76, 42, 39, 62 是不太重复的, 这样我们就可以取 100 内作为下标的散列表&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;折叠法&lt;/strong&gt;
   将较长的关键码切分为几段, 通过某种运算将它们合并, 比如加法, 二进制运算等.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如有 1456268793, 分成 1 + 456 + 268 + 793 = 1518, 去掉进位后为 518, 这样就把 10 位数散列到了 [0, 999] 区间内&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;中平方法&lt;/strong&gt;
   先求出关键码的平方, 然后取出中间的几位作为散列值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如有 1456268793, 平方后是 2120718797465676849, 从中取出连续的三位数作为散列值, 比如万位开始的 768&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;除余法&lt;/strong&gt;
   关键码是整数时, 用关键码除以散列表的大小 m, 得到的余数即是对应的下标&lt;code&gt;(key mod m)&lt;/code&gt;. 由于计算机是二进制运算, 所以我们常取 m 的大小为 2&lt;sup&gt;n&lt;/sup&gt;. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;基数转换法&lt;/strong&gt;
   把数转换成其他进制数, 然后再使用除余法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;2.4 冲突的解决&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;开地址法&lt;/strong&gt;: 开地址法最主要的思想就是, 当冲突发生时, 就在散列表中的下一个为空的地方来放. 
  查找下一个空槽的方法也有多种, 像线性查找, 就是按顺序一个一个查找过去, 直到找到一个为空的槽. 这导致了当我们的散列表冲突比较多时, 查找会越来越长, 并且数据会比较集中在一个地方. 还有一种方法, 就是隔几个槽来放置而不是挨着放, 比如产生冲突时, 隔 3 个查找位置, 这样能稍微使数值平均分布些&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;溢出区方法&lt;/strong&gt;: 设置一个溢出存储区, 一般是一个线性表. 当发生冲突时, 就把这个冲突的后来者放入来溢出存储区中. 然后在查找的时候, 查找到的是原先的冲突项, 如果槽是空说明值不存在. 如果是非空, 对比其中的数值标志, 不相同的话, 说明先前有过冲突, 再去溢出区查找, 直到找到或者找不到. 使用这种方法, 当溢出区增大时, 散列表性能会线性下降&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;桶散列&lt;/strong&gt;:  我们假定散列中都有自己一个指针指向一个链表, 当发生冲突时, 我们就把新来的 key 加到指针指向的链表中, 这样我们在查找时, 如果链表长度不是 1, 那么按顺序遍历链表即可.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3. 集合&lt;/h4&gt;
&lt;h5&gt;3.1 简单线性表实现&lt;/h5&gt;
&lt;p&gt;使用线性表, 也就是数组, 链表之类的来实现集合, 简单, 快捷, 这两种实现性能一致的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;in&lt;/code&gt;  操作: 因为要遍历整个表, 所以是 &lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;add&lt;/code&gt; 操作: 因为首先要判断添加的值是否在集合中, 所以是 &lt;code&gt;O(n)&lt;/code&gt;, 虽然添加那步只是 &lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;remove&lt;/code&gt;: 总是先要 &lt;code&gt;in&lt;/code&gt; 操作&lt;/li&gt;
&lt;li&gt;交集, 并集, 差集这样操作会导致 &lt;code&gt;O(n&amp;lt;sup&amp;gt;2&amp;lt;/sup&amp;gt;)&lt;/code&gt;, 因为总是要遍历两个集合所有元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果我们让线性表总是保持其有序, 这样在查找的时候使用二分查找可以使用之降到 &lt;code&gt;O(logN)&lt;/code&gt;&lt;/p&gt;
&lt;h5&gt;3.2 散列表实现&lt;/h5&gt;
&lt;p&gt;我们可以使用散列表来实现集合, 这样查找操作就变成了 &lt;code&gt;O(1)&lt;/code&gt;. 在交集, 并集, 差集操作中, 只要 &lt;code&gt;O(m + n)&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;4. Python 中的 dict 和 set&lt;/h4&gt;
&lt;p&gt;在 CPython 中这两者都是使用散列方法实现的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dict 类型的 key 是一个不可变对象, 不可变对象都实现了 hashable 方法. 值可以是任意对象&lt;/li&gt;
&lt;li&gt;创建空或者很小的字典时, 初始容量为 8&lt;/li&gt;
&lt;li&gt;当负载因为超过 2/3 时自动扩大表的容量, 如果容量不大, 按 4 倍来扩大. 当容量超过 50000 时, 按 2 倍扩大&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;5. 二叉排序树&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;二叉排序树的左子树上的值总是小于(有需要的话也可以等于根)&lt;/li&gt;
&lt;li&gt;二叉排序树的右子树上的值总是大于(有需要的话也可以等于根)&lt;/li&gt;
&lt;li&gt;根结点左边的总是结右边的值小, 也就是说结点的左右子树是有大小关系的, 跟堆使用的不一样, 堆使用的二叉树不要求左右再边的关系&lt;/li&gt;
&lt;li&gt;二叉排序树不一定是满二叉树, 由于值大小的分布不确定性造成的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据二叉排序树的几个性质:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们使用&lt;strong&gt;中序遍历&lt;/strong&gt;(左-根-右)便能得到一个升序的序列&lt;/li&gt;
&lt;/ol&gt;</content><category term="数据结构"></category><category term="字典"></category><category term="哈希表"></category><category term="散列"></category><category term="python"></category><category term="python数据结构"></category></entry><entry><title>A Simple SteamKit implement with using Python(一)</title><link href="https://ivicel.info/2018/07/a-simple-steamkit-implement-with-using-pythonyi.html" rel="alternate"></link><published>2018-07-18T00:00:00+08:00</published><updated>2018-07-18T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-07-18:/2018/07/a-simple-steamkit-implement-with-using-pythonyi.html</id><summary type="html">&lt;h4&gt;1. 连接握手&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;与 steam 客户端进行通信的称为 CM Server, Steam 客户端首先要向发送一个连接请求, 然后服务器会返回一个 &lt;code&gt;CHANNEL_ENCRYPT_REQUEST&lt;/code&gt;, 这个消息包会带有一个 16 字节的 质询 &lt;code&gt;challenge&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们随机生生成一个 256 位长度的密钥 &lt;code&gt;session_key&lt;/code&gt;,  使用 steam 的公钥对密钥加密后再发回给服务器, 加密方法为 &lt;code&gt;RSA&lt;/code&gt;, padding 为 &lt;code&gt;OAEP(mgf=MGF1(algorithm=SHA1), algorithm=SHA1)&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;这里可里选择只发送回 &lt;code&gt;session_key&lt;/code&gt;(legacy mode), 或者回应质询 &lt;code&gt;session_key + challenge&lt;/code&gt;, 发回后者表示在以后的通信中使用每次会生成一个 &lt;code&gt;SHA1-HMAC&lt;/code&gt;. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;收到服务的 &lt;code&gt;session_key&lt;/code&gt; 确认, 结果为 &lt;code&gt;EResult.OK&lt;/code&gt; 时 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;h4&gt;1. 连接握手&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;与 steam 客户端进行通信的称为 CM Server, Steam 客户端首先要向发送一个连接请求, 然后服务器会返回一个 &lt;code&gt;CHANNEL_ENCRYPT_REQUEST&lt;/code&gt;, 这个消息包会带有一个 16 字节的 质询 &lt;code&gt;challenge&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们随机生生成一个 256 位长度的密钥 &lt;code&gt;session_key&lt;/code&gt;,  使用 steam 的公钥对密钥加密后再发回给服务器, 加密方法为 &lt;code&gt;RSA&lt;/code&gt;, padding 为 &lt;code&gt;OAEP(mgf=MGF1(algorithm=SHA1), algorithm=SHA1)&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;这里可里选择只发送回 &lt;code&gt;session_key&lt;/code&gt;(legacy mode), 或者回应质询 &lt;code&gt;session_key + challenge&lt;/code&gt;, 发回后者表示在以后的通信中使用每次会生成一个 &lt;code&gt;SHA1-HMAC&lt;/code&gt;. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;收到服务的 &lt;code&gt;session_key&lt;/code&gt; 确认, 结果为 &lt;code&gt;EResult.OK&lt;/code&gt; 时, 连接成功. 以后的通信会基于 &lt;code&gt;session_key&lt;/code&gt; 加密&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;如果我们启用了 &lt;code&gt;SHA1-HMAC&lt;/code&gt; 消息认证, 那么在 &lt;code&gt;CBC&lt;/code&gt; 模式使用的初始向量 &lt;code&gt;iv&lt;/code&gt; 会有不同, 不是通过直接随机生成, 而是对明文生成 HMAC 后, 取其前 13 bytes, 再加上随机生成 3 bytes. 下面是发送 &lt;code&gt;HMAC&lt;/code&gt; 时的步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;随机生成 3 bytes &lt;code&gt;prefix&lt;/code&gt;, 把这三个字节加到明文的前面, hash key 是 &lt;code&gt;session_key&lt;/code&gt; 的前 16 bytes, 即 &lt;code&gt;hash_key = session_key[:16]&lt;/code&gt;. 使用 &lt;code&gt;HMAC(hash_key=session[:16], hash_function=SHA1, message=prefix + need_to_encrypt_text)&lt;/code&gt;, 生成的 &lt;code&gt;hmac_msg&lt;/code&gt; 后, &lt;code&gt;iv = hmac_msg[:13] + prefix&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;AES-256-ECB&lt;/code&gt;, 加密 &lt;code&gt;iv&lt;/code&gt;, 分组长度为 128 bits. 得到 &lt;code&gt;enc_iv&lt;/code&gt;, 一共是 16个字节&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;AES-256-CBC&lt;/code&gt;, 加密 &lt;code&gt;need_to_encrypt_text&lt;/code&gt;, 分组长度为 &lt;code&gt;128 bits&lt;/code&gt;, 填充模式为 &lt;code&gt;PKCS7&lt;/code&gt;.  得到 &lt;code&gt;enc_msg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;返回的 &lt;code&gt;enc_iv + env_msg&lt;/code&gt; 即是加密完成的的消息体&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果没有启用 &lt;code&gt;HMAC&lt;/code&gt;, 即不发送 &lt;code&gt;challenge&lt;/code&gt;, 在第一步中把 &lt;code&gt;iv&lt;/code&gt; 换成随机生成的 16 字节即可.&lt;/p&gt;
&lt;p&gt;解密过程就是反向过程, 消息包的前 16 个字节是 &lt;code&gt;env_iv&lt;/code&gt;, 剩下的是加密后 message 本体. 使用对应的加密方法进行解密即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始的 CM Server IP 地址和端口 可以在 &lt;code&gt;steam_installed_directory/config/config.vdf&lt;/code&gt; 找到, 在通信的过程, 服务器会发回新 CM IP 地址和端口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;steam 客户端保持一个 TCP/UDP 长连接, 用来与 CM Server 通信, 并且要定时发送一个 &lt;strong&gt;"heartbeat"&lt;/strong&gt; 用来告诉 CM 不要断开连接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通信的数据结构主要为 &lt;a href="https://developers.google.com/protocol-buffers/"&gt;Protocol Buffer v2&lt;/a&gt;, 在 proto 外包了一层 header, header 里指明了是否为 proto buffer&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;2. 了解 Protocol Bufffer&lt;/h4&gt;
&lt;p&gt;根据 protobuf 的 &lt;a href="https://github.com/google/protobuf"&gt;文档&lt;/a&gt;, 使用 protobuf 要三步走&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义 &lt;code&gt;.proto&lt;/code&gt; 文件原型, steamdb 已经收集好了, 从 &lt;a href="https://github.com/SteamDatabase/SteamTracking"&gt;SteamDB github&lt;/a&gt; 下载, 另外这些都是定义都依赖 Google 定义的 &lt;code&gt;descriptor.proto&lt;/code&gt;, 在 &lt;a href="https://github.com/google/protobuf/blob/master/src/google/protobuf/descriptor.proto"&gt;这里&lt;/a&gt; 可以下载到这个文件, 打包的编译器也带了这个&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;花 &lt;a href="https://space.bilibili.com/423895/"&gt;5 分钟&lt;/a&gt; 了解一下 protobufs 是如何 &lt;a href="https://developers.google.com/protocol-buffers/docs/proto"&gt;定义&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;使用 &lt;code&gt;protobuf&lt;/code&gt; 编译器把 &lt;code&gt;.proto&lt;/code&gt; 文件编译成对应语言文件, 编译器在 &lt;a href="https://github.com/google/protobuf/releases"&gt;这里&lt;/a&gt; 下载, 下载对应系统的版本即可, 带语言标签的是使用特定语言的实现源代码&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;花几分钟读下 &lt;a href="https://developers.google.com/protocol-buffers/docs/pythontutorial"&gt;python tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;使用 Python protocol buffer API 读写, API 文档在 &lt;a href="https://developers.google.com/protocol-buffers/docs/reference/python/"&gt;这里&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;3. 编译 protobuf&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-shell"&gt;# project 目录
mkdir python-steamkit &amp;amp;&amp;amp; cd python-steamkit
python3 -m venv venv
# 用于加密和 protobuf 的依赖包
pip install cryptography protobuf

# Protobufs 目录定义主要的通信格式
# 其他目录是对应的游戏通信格式
git clone https://github.com/SteamDatabase/SteamTracking
cd SteamTracking/Protobufs
mv renderer/rendermessages.proto .
# 删掉重复定义
rm -R steamdatagram_auth_messages.proto renderer
# 在每个 proto 文件的第一行加上 syntax = "proto2"; 语法定义避免编译警告
sed -s -i '1isyntax = "proto2";' *.proto
# optinal 查看来是否所有 .proto 文件都有 proto2 语法定义了, 0 表示成功
test $(find . -type f -name '*.proto' | wc -l) -eq \
    $(grep -E '^syntax\s?=\s?"proto2";$' -R . | wc -l); echo $?

# 新建目录来存放编译后的 .py 文件
mkdir protobufs
# 如果文件名了带有点号, 比如 a.b.proto, 编译后会生成 a/b_pb.py, 我们不需要独立的目录
# 把文件的中点号换成下划线 "_", 文件内的依赖路径相应的也需要更改
for n in `ls`; do; name=$(echo $n | sed -E 's/\./_/g; s/_proto$/\.proto/g'); mv $n $name; done
sed -E -i '/^import/s/\./_/; /^import/s/_proto/\.proto/' *.proto

# 下载的 protoc 编译包里包含了 descriptor.proto, 指定依赖路径即可
protoc --python_out=./protobufs -I. -I protoc/include *.proto
# 将 steam_proto 打包成 python package
touch protobufs/__init__.py
mv protobuf ../../
sed -E '/^import\s+"[^\/]*$/s/"(.*)";$/"steam\/protobufs\/\1";/' steam/protobufs/*.proto -i&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;4. 通信消息的格式&lt;/h4&gt;
&lt;p&gt;通信是按 &lt;strong&gt;Little endian&lt;/strong&gt; 传输的, 通信包的定义主要有三种情况:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前三个握手包, 用来生成加密的通信, 有自己特定的定义&lt;/li&gt;
&lt;li&gt;protobuf 包, 包含一个 protobuf 消息&lt;/li&gt;
&lt;li&gt;multi message, (1) 根据 &lt;code&gt;CMsgMulti.size_unzipped&lt;/code&gt; 是否 &lt;strong&gt;大于 0&lt;/strong&gt; 来判断 &lt;code&gt;CMsgMulti.message_body&lt;/code&gt; 是否启用了  gzip 压缩. (2) 如果是则要先先把 &lt;code&gt;message_body&lt;/code&gt; 解压, 然后再解读里&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这三种包都会包含以下三个字段: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4 bytes 的 包长度 &lt;/li&gt;
&lt;li&gt;固定的 4 bytes magic number, 为 &lt;code&gt;0x31305456&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;4 bytes 的 消息类型, 消息的最高位为 protobuf 消息掩码位, &lt;code&gt;0&lt;/code&gt; 表示非 protobuf, &lt;code&gt;1&lt;/code&gt; 为 protobuf&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-plain"&gt;1. handshake packet: &amp;lt;ChannelEncryptRequest&amp;gt;, &amp;lt;ChannelEncryptResponse&amp;gt;, &amp;lt;ChannelEncryptResult&amp;gt;
+ + + + + + + + + + + + + + +
|   4 bytes msg_len         |
+ - - - - - - - - - - - - - +
|   4 bytes magic_number    |
+ - - - - - - - - - - - - - +
|   4 bytes msg_type        |
+ - - - - - - - - - - - - - +
|   8 bytes target_job_id   |
+ - - - - - - - - - - - - - +
|   8 bytes source_job_id   |
+ - - - - - - - - - - - - - +             
|                           |       
|   body(msg_len - 20 bytes)| 
|                           |
+ + + + + + + + + + + + + + +

body 详细说明
I. recv &amp;lt;ChannelEncryptRequest&amp;gt;
    + - - - - - - - - - - - - - - - + 
    | (msg_len - 20)bytes challenge |
    + - - - - - - - - - - - - - - - + 

II. send &amp;lt;ChannelEncryptResponse&amp;gt;
    + - - - - - - - - - - - - - - - + 
    | 4 bytes protocol_version (1)  |
    + - - - - - - - - - - - - - - - + 
    | 4 bytes key_size (128)        |
    + - - - - - - - - - - - - - - - + 
    | 128 bytes session_key         |
    + - - - - - - - - - - - - - - - +  
    | 4 bytes crc32(session_key)    |       
    + - - - - - - - - - - - - - - - +  
    | 4 bytes end_flag (0)          |
    + + + + + + + + + + + + + + + + +

III. recv &amp;lt;ChannelEncryptResult&amp;gt;
    + - - - - - - - - - - - - - - - + 
    | 4 bytes EResult               |
    + - - - - - - - - - - - - - - - + 

2. Protobuf packet
+ + + + + + + + + + + + + + +
|   4 bytes msg_len         |
+ - - - - - - - - - - - - - +
|   4 bytes magic_number    |
+ - - - - - - - - - - - - - +
|   4 bytes msg_type        |
+ - - - - - - - - - - - - - +
|   4 bytes protobuf_len    |
+ - - - - - - - - - - - - - +          
|                           |       
|   Protobuf Message        |
|                           |
+ + + + + + + + + + + + + + +


3. mutil packet
+ + + + + + + + + + + + + + +
| 4 bytes msg_len           |
+ - - - - - - - - - - - - - +
| 4 bytes magic_number      |
+ - - - - - - - - - - - - - +
| 4 bytes msg_type          |
+ - - - - - - - - - - - - - +
| 1 byte header_size (32)   |
+ - - - - - - - - - - - - - +
| 2 bytes header_version (1)|
+ - - - - - - - - - - - - - +
| 8 bytes target_job_id     |
+ - - - - - - - - - - - - - +
| 8 bytes source_job_id     |
+ - - - - - - - - - - - - - +  
| 1 byte header_canary      |
+ - - - - - - - - - - - - - +
| 8 bytes steam_id          |
+ - - - - - - - - - - - - - + 
| 8 bytes source_job_id     |
+ - - - - - - - - - - - - - +   
| 8 bytes session_id        |
+ - - - - - - - - - - - - - +             
|                           |       
|Protobuf message&amp;lt;CMsgMulti&amp;gt;|
|                           |
+ + + + + + + + + + + + + + +

Multi 包含一个或多个 message, 每个结构为, 前 4 个字节为消息长度 + message
+ - - - - - - - - - - - - - + 
| 4 bytes message_len       |
+ - - - - - - - - - - - - - +   
| message_len bytes message |
+ - - - - - - - - - - - - - +  
| 4 bytes message_len       |
+ - - - - - - - - - - - - - +   
| message_len bytes message |
+ - - - - - - - - - - - - - +


4. send protobuf message
+ + + + + + + + + + + + + + + + + + + +
|   4 bytes msg_len                   |
+ - - - - - - - - - - - - - - - - - - + 
|   4 bytes magic_number              |
+ - - - - - - - - - - - - - - - - - - + 
|   encrypted mesasge body            |
+ - - - - - - - - - - - - - - - - - - +

需要发送的 protobuf message 包含 message header 和 message body 主体
1&amp;gt; 如果已经登录的情况下, 把 header 里的 steamid, client_sessionid 改成对应的值
2&amp;gt; 将这两个序列化生成字节串
3&amp;gt; 使用 session_key 加密, 根据前面的握手过程, 依需要生成 hash message
4&amp;gt; 组合成上面的包. 注意的是包的主体消息长度是指加密后的字节数
+ - - - - - - - - - - - - - - - - - - +  
| Protobuf header&amp;lt;CMsgProtoBufHeader&amp;gt; |
+ - - - - - - - - - - - - - - - - - - +  
| Protobuf message                    |
+ - - - - - - - - - - - - - - - - - - +  &lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;Reference&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://github.com/ValvePython/steam/issues/79"&gt;https://github.com/ValvePython/steam/issues/79&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/ValvePython/steam"&gt;https://github.com/ValvePython/steam&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/SteamRE/SteamKit/issues/555"&gt;https://github.com/SteamRE/SteamKit/issues/555&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="python"></category><category term="steam"></category><category term="steamkit"></category></entry><entry><title>Dart Tutor</title><link href="https://ivicel.info/2018/07/dart-tutor.html" rel="alternate"></link><published>2018-07-01T00:00:00+08:00</published><updated>2018-07-01T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-07-01:/2018/07/dart-tutor.html</id><summary type="html">&lt;h3&gt;一个基本的 Dart 程序&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;printInteger(int aNumber) {
  print('The number is $aNumber.')
}

// 程序入口
main() {
  var number = 42;
  printInteger(number);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;一些重要的概念&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在 Dart 中, 所有的一切都是对象, 继承自 &lt;code&gt;Object&lt;/code&gt; 类, &lt;code&gt;null&lt;/code&gt; 类型也是一个对象&lt;/li&gt;
&lt;li&gt;Dart 是强类型语言, 但变量的声明是可以省略类型的, 程序会在第一次赋值时自动推断类型. 也可以使用 &lt;code&gt;dynamic&lt;/code&gt; 关键字来声明动态类型&lt;/li&gt;
&lt;li&gt;Dart 支持泛型, 如 &lt;code&gt;List&amp;lt;int&amp;gt;&lt;/code&gt; 或 &lt;code&gt;List&amp;lt;dynamic&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Dart 支持 top-level 函数(C 语言中的函数定义), 类成员方法 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h3&gt;一个基本的 Dart 程序&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;printInteger(int aNumber) {
  print('The number is $aNumber.')
}

// 程序入口
main() {
  var number = 42;
  printInteger(number);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;一些重要的概念&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在 Dart 中, 所有的一切都是对象, 继承自 &lt;code&gt;Object&lt;/code&gt; 类, &lt;code&gt;null&lt;/code&gt; 类型也是一个对象&lt;/li&gt;
&lt;li&gt;Dart 是强类型语言, 但变量的声明是可以省略类型的, 程序会在第一次赋值时自动推断类型. 也可以使用 &lt;code&gt;dynamic&lt;/code&gt; 关键字来声明动态类型&lt;/li&gt;
&lt;li&gt;Dart 支持泛型, 如 &lt;code&gt;List&amp;lt;int&amp;gt;&lt;/code&gt; 或 &lt;code&gt;List&amp;lt;dynamic&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Dart 支持 top-level 函数(C 语言中的函数定义), 类成员方法, 静态方法, 也同样支持在函数中再定义函数&lt;/li&gt;
&lt;li&gt;Dart 支持 top-level 变量, 类成员变量, 静态变量&lt;/li&gt;
&lt;li&gt;Dart 没有 &lt;code&gt;pulibc&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt; 关键字, 使用前置下划线 &lt;code&gt;_&lt;/code&gt; 来表示变量只能 library 访问&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Identifiers&lt;/em&gt; 可以以下划线 &lt;code&gt;_&lt;/code&gt; 或大小写字母开始, 可以包含数字&lt;/li&gt;
&lt;li&gt;Dart 编译工具编译时会产生: &lt;code&gt;warnings&lt;/code&gt; 和 &lt;code&gt;errors&lt;/code&gt;, warning 只能产生警告而不会中止程序运行. errors 可能会在编译时或运行产生, 程序不会继续运行, 并产生 exception&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Keywords&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;关键字&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;abstract&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;dynamic&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;implements&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;show&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;as&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;else&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;import&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;static&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;assert&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;in&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;super&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;async&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;export&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;interface&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;switch&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;await&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;extends&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;is&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;break&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;external&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;library&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;this&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;case&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;factory&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;mixin&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;catch&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;new&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;class&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;final&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;null&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;try&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;on&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;typedef&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;for&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;operator&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;var&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;convariant&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Function&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;part&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;default&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;get&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;rethrow&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;while&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;deferred&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;hide&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;return&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;with&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;do&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;if&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;set&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;变量&lt;/h3&gt;
&lt;p&gt;Dart 可以使用 &lt;code&gt;var&lt;/code&gt; 关键字来定义变量, 如 &lt;code&gt;var name = 'Bob'&lt;/code&gt;, Dart 会自动推断会变量的类型, Dart 也可以显示的设置变量类型 &lt;code&gt;String name = 'Bob'&lt;/code&gt;, 设置一但设置便不能更改, 若要使用动态类型, 可以使用 &lt;code&gt;dynamic&lt;/code&gt; 类型&lt;/p&gt;
&lt;h4&gt;默认值&lt;/h4&gt;
&lt;p&gt;未初始化的变量是默认值为 &lt;code&gt;null&lt;/code&gt;, 即使其类型为 &lt;code&gt;int&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;Final 和 const 修饰&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;final&lt;/code&gt; 关键字表示变量在定义之后再无法修改, 其值在运行时确定&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt; 关键字表示变量的值在编译(&lt;strong&gt;compile-time constants&lt;/strong&gt;)时就已经确定, 并且无法更改, 也就是&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;final name = 'Bob';    // name 无法再重新赋值

const age = 12;        // 正确, 12 是一个确定的值

int get(int i) {
  return i * i;
}
const j = get(2);      // 错误, j 的值要到运行时才能确定&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Built-in types&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;numbers&lt;/li&gt;
&lt;li&gt;strings&lt;/li&gt;
&lt;li&gt;booleans&lt;/li&gt;
&lt;li&gt;lists ( 列表或数组)&lt;/li&gt;
&lt;li&gt;sets&lt;/li&gt;
&lt;li&gt;maps&lt;/li&gt;
&lt;li&gt;runes (Unicode 字符)&lt;/li&gt;
&lt;li&gt;symbols&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Numbers&lt;/h4&gt;
&lt;p&gt;Dart 数值在 &lt;code&gt;int&lt;/code&gt; 和 &lt;code&gt;double&lt;/code&gt; 两种类型. &lt;code&gt;int&lt;/code&gt; 最大为 64 bits, double 为双精度 64 bits&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int&lt;/code&gt; 和 &lt;code&gt;double&lt;/code&gt; 都是 &lt;code&gt;num&lt;/code&gt; 的子类型, 可以使用 &lt;code&gt;num i = 3&lt;/code&gt; 来定义变量数值&lt;/p&gt;
&lt;h4&gt;Strings&lt;/h4&gt;
&lt;p&gt;字符串可以使用单引号 &lt;code&gt;'&lt;/code&gt; 或双引号 &lt;code&gt;"&lt;/code&gt; 来定义, 引号内可以使用 &lt;code&gt;$&lt;/code&gt; 来引用变量的值, 和 java 不同的是, 字符串值使用 &lt;code&gt;==&lt;/code&gt; 比较&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;var s = 'word';
var str = 'Hello, $s';
print(str);     // Hello, word&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外, dart 中还支持和 python 中一样的多行字符, &lt;code&gt;'''&lt;/code&gt; 和 &lt;code&gt;"""&lt;/code&gt;, 原始字符 &lt;code&gt;r&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;var s` = '''
You can create
multi-line strings like this one.
''';

var s2 = """This is also a
multi-line string.""";

// 使用 r 标志, \n 不会被转义为换行
var s = r'abc,\n gets special';&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;Booleans&lt;/h4&gt;
&lt;p&gt;只有 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 两个值, 在 dart 中 if 判断只能是这两个值, 不会自动推断, 和 java 是一样的. &lt;code&gt;if (a == null)&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;List&lt;/h4&gt;
&lt;p&gt;列表或者数组, &lt;code&gt;var list = [1, 2, 3, 4];&lt;/code&gt; list 类型为 &lt;code&gt;List&amp;lt;int&amp;gt;&lt;/code&gt;. 在 dart 2.3 添加了 &lt;strong&gt;spread operator&lt;/strong&gt;(&lt;code&gt;…&lt;/code&gt;) 和 &lt;strong&gt;null-aware spread operator&lt;/strong&gt;(&lt;code&gt;…?&lt;/code&gt;) 用来添加列表&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;var list = [1, 2, 3];
var list2 = [0, ...list];    // [0, 1, 2, 3, 4]

var l1;
var l2 = [0, ...?l1];    // [0], ...? 用来判断 null 值

// collection if 语句
var nav = [
  'Home',
  'Furniture',
  'Plants',
  if (promoActive) 'Outlet'
];

// collection for 语句
var listOfInts = [1, 2, 3];
var listOfStrings = [
  '#0',
  for (var i in listOfInts) '#$i'
];&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;Sets&lt;/h4&gt;
&lt;p&gt;无序不重复的集合.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;// 字面量定义, 使用 {} 定义
var halogens = {'fluorine', 'bromine'};

// {} 指的是空 map, 当要定义空 set 时, 使用 Set 类
var s = &amp;lt;String&amp;gt;{};&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;Map&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;var gifts = {
  'first': 'partridge',
  'second': 'turtledoves',
  'fifth': 'golden rings'
};

// dart 2 中 new 关键字可以省略
var gift2 = Map();
gift2['first'] = 'partridge';&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;Runes&lt;/h4&gt;
&lt;p&gt;在 dart 中, runes 是 UTF-32 code points 字符串.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;Runes input = Runes('\u2665 \u{1f605}');&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;Symbols&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Symbols&lt;/code&gt; 对象代表的是一个操作符或标识符, 比如 &lt;code&gt;#radix&lt;/code&gt;, 可用于类似 C 中的 goto 跳转&lt;/p&gt;
&lt;h3&gt;Functions&lt;/h3&gt;
&lt;p&gt;Dart 是一个纯面向对象语言, 函数也是一个对象, 所以可以将函数当作一个参数传递给另一个函数. 函数如果没有写返回值, 则默认返回 &lt;code&gt;null&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;// number 的类型和返回值都可以省略, 但为代码阅读方便, 最好不要省略
bool isNoble(int number) {
  return _nobleGases[number] != null;
}

// return 可以简写成 =&amp;gt;, 但和 javascript 的 =&amp;gt; 函数不同
// 这里只是一个语法糖, =&amp;gt; 后面只能是一条表达式, 不能有多条
bool isNoble(int number) =&amp;gt; _nobleGases[number] != null;&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;可选参数和默认参数值&lt;/h4&gt;
&lt;p&gt;有两种方法表示可选参数, 命名参数(Optional named parameters), 使用 &lt;code&gt;{...}&lt;/code&gt;,  位置参数(Optional positional parameters), 使用 &lt;code&gt;[…]&lt;/code&gt;, 两种方式不能混合使用. 另外在可选参数中还可以使用 &lt;code&gt;@required&lt;/code&gt; 标识注明该参数必须传值. 默认的参数值只能是使用在可选参数中设置&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;// 命名参数, 定义时使用 {paramType paramName}
void namedParamFunc({bool bold, bool hidden}) {...}
// 调用时 paramName: value
namedParamFunc(bold: true, hidden: false);

// 也可以使用 @required 表明该参数 hidden 必须传一个值
void namedParamWithRequired({bool bold, @required bool hidden) {...}

// 位置参数, 使用 [], 位置可选参数必须位于必传参数后面
void positionalParamFunc(String from, String msg, [String device]) {...}

// 设置默认参数, 默认参数必须是 const
void defaultParamFunc1({bool bold = false, bool hidden}) {...}
void defaultParamFunc2(String from, String msg, [String device = 'android']) {...}
void defaultParamFunc1({bool bold = false, List&amp;lt;int&amp;gt; numbers = const [1, 2, 3}) {...}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;匿名函数&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;/* 
([[Type] param [, ...]]) {
  codeBlock;
};
*/

var list = ['apples', 'bananas', 'oranges'];
  list.forEach((item) {
    print('${list.indexOf(item)}: $item');
  });&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;几个特殊操作符&lt;/h3&gt;
&lt;h4&gt;级联操作符(Cascade notation ..)&lt;/h4&gt;
&lt;p&gt;类似于 java 中类返回 &lt;code&gt;this&lt;/code&gt; 里可级联的操作, dart 中不必显示返回 this&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;querySelector('#confirm') // Get an object.
  ..text = 'Confirm' // Use its members.
  ..classes.add('important')
  ..onClick.listen((e) =&amp;gt; window.alert('Confirmed!'));

// 相当于, 这里 querySelector 一定要返回一个对象
var button = querySelector('#confirm');
button.text = 'Confirm';
button.classes.add('important');
button.onClick.listen((e) =&amp;gt; window.alert('Confirmed!'));&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;判断 null 操作符&lt;/h4&gt;
&lt;h4&gt;&lt;code&gt;is&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, &lt;code&gt;is!&lt;/code&gt;, &lt;code&gt;??&lt;/code&gt;, &lt;code&gt;?.&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;is&lt;/code&gt; 相当于 java 中 &lt;code&gt;instaceof&lt;/code&gt;, 判断 对象是否是某个类的实例, &lt;code&gt;is!&lt;/code&gt; 反之&lt;/p&gt;
&lt;p&gt;&lt;code&gt;as&lt;/code&gt; 用于类型强制转换或在 library import 中重命别名&lt;/p&gt;
&lt;p&gt;&lt;code&gt;?.&lt;/code&gt; 用于在类对象访问成员方法/成员变量, 先进行判断 &lt;code&gt;null&lt;/code&gt; 操作, 以免产生错误&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;// 用于判断 obj 是否为 null, 以免产生错误
var a = obj?.a;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;??&lt;/code&gt; 用于判断是是否为 &lt;code&gt;null&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;// 如果 b 为 null, a 保持不变, 否则则把 b 的值赋给 a
var a = 'abc';
a ??= b;

// 如果 name 为 null, 则返回 Guest
String playerName(String name) =&amp;gt; name ?? 'Guest';
// 相当
String playerName(String name) =&amp;gt; name != null ? name : 'Guest';&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;控制流程&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt; 语句中, 如果  &lt;code&gt;case&lt;/code&gt; 里面有写了语句, 则 &lt;code&gt;break&lt;/code&gt; 不能缺少, 否则会产生错误. 另外还支持跳转到类似锚点的形式, 使用 &lt;code&gt;continue [tagPosition]&lt;/code&gt; 语句&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;switch (c) {
  case 'OPEN':
    doA();
    // 错误, 缺少 break
  case 'CLOSED':
    doB();
    break;
}

var command = 'CLOSED';
switch (command) {
  case 'CLOSED':
    executeClosed();
    continue nowClosed;
  // Continues executing at the nowClosed label.

  nowClosed:
  case 'NOW_CLOSED':
    // Runs for both CLOSED and NOW_CLOSED.
    executeNowClosed();
    break;
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;异常 Exceptions&lt;/h3&gt;
&lt;p&gt;抛出异常 &lt;code&gt;throw FormatException('error…')&lt;/code&gt;, dart 可以抛出任何非 null 对象, 如 &lt;code&gt;throw 123&lt;/code&gt;. 捕获异常使用 &lt;code&gt;on&lt;/code&gt; 和 &lt;code&gt;catch&lt;/code&gt; 关键字&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;try {
  breedMoreLlamas();
} on OutOfLlamasException {
    // 捕获特定异常
} on Exception catch (e, s) {
  // 捕获特定异常, e 是异常对象, s 是栈错误对象 StackTrace, 可以省略
  print('Unknown exception: $e');
} catch (e) {
  // 捕获所有异常
} finally {
    // 一定执行的语句 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;类 Classes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;类的初始化顺序: 1. 参数列表, 2. 父类 constructor, 3. 本类 constructor&lt;/li&gt;
&lt;li&gt;类的成员变量默认都有 getter/setter 方法, 和 python 中一样直接赋值, 以 &lt;code&gt;_&lt;/code&gt; 开始的为可在 library 内访问, 没有 private, public, protected 修饰&lt;/li&gt;
&lt;li&gt;获取对象的类型可以使用 &lt;code&gt;obj.runtimeType&lt;/code&gt; 成员变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;构造方法&lt;/h4&gt;
&lt;p&gt;如果不声明构造方法, 则类有一个无参的默认构造方法. 构造方法是不继承的. 构造方法有两种写法, 类似 java 的, 和命名构造方法&lt;/p&gt;
&lt;h5&gt;类 Java 的构造方法&lt;/h5&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;class Point {
  num x, y;

  // 也可以简写成 Point(this.x, this.y);
  Point(num x, num y) {
    this.x = x;
    this.y = y;
  }&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;命名构造方法&lt;/h5&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;  // 命名构造方法
  Point.origin() {
    x = 0;
    y = 0;

// 调用
var p1 = Point(1, 2);
var p2 = Point.origin();&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;使用构造方法初始化列表&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;// 类的初始化列表
class MyPoint {
    num x, y;

  // : 后面是初始化表, 会先方法内部进行调用, 类似 C++, 也可以是其他表达式, 比如 assert(x &amp;gt;= 0)
  MyPoint.fromJson(Map&amp;lt;String, num&amp;gt; json):
        x = json['x'],
        y = json['y'] {
    print('In MyPoint.fromJson: ($x, $y)');      
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;constant 类&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;// Constant constructors, 其成员变量必须都是 final
class ImmutablePoint {
    final num x, y;

  const ImmutablePoint(this.x, this.y);
}

// 调用
var immutablePoint = const ImmutablePoint(1, 2);&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;使用 &lt;code&gt;factory&lt;/code&gt; 设置工厂方法&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;// 工厂方法 constructor, 使用 factory 关键字, 工厂方法不能访问 this
class Logger {
  final String name;

  static final Map&amp;lt;String, Logger&amp;gt; _cache = &amp;lt;String, Logger&amp;gt;{};

  factory Logger(String name) {
        if (_cache.containsKey(name) {
        return _cache[name];
      } else {
        final logger = Logger._internal(name);
        _cache[name] = logger;
        return logger;
      }
   }

     Logger._internal(this.name);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;抽象类: &lt;code&gt;abstract&lt;/code&gt;&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;// 抽象类, 使用 abstract 关键字, 继承时必须要覆写
abstract class Dog {
  // 抽象类中不写方法体的便是抽象方法, 不用 abstract 关键字
  void doSomething();
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;code&gt;as&lt;/code&gt; 向上/下转型&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;class Person {}
class Employee extends Person {}

var em = Employee();
(em as Person).doSomething();&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;隐式接口 implicit interfaces&lt;/h4&gt;
&lt;p&gt;每一个类都是一个隐式的接口, dart 里没有像 java 的 interface 关键字, 当我们使用 &lt;code&gt;extends&lt;/code&gt; 继承类时, 会继承类的实现, 而实现 &lt;code&gt;implements&lt;/code&gt; 接口的话, 并不会继承原类里的实现. 可以实现多个接口. 实现接口的时候必须要实现&lt;strong&gt;所有的成员变量和成员方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;class Person {
  final _name;
  Person(this._name);

  String greet(String who) =&amp;gt; 'Hello, $who. I am $_name.';
}

class Impostor implements Person {
  // 别忘实现成员变量
  String _name;

  // 实现成员方法
  String greet(String who) =&amp;gt; 'Hi, $who';
}

String greetBob(Person person) =&amp;gt; person.greet('Bob');

greetBob(Person('Kathy'));
greetBob(Impostor());&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;继承及调用父类&lt;/h4&gt;
&lt;p&gt;使用 &lt;code&gt;extends&lt;/code&gt; 继承类, 只能单继承. 子类构造方法会默认调用父类的&lt;strong&gt;无参&lt;/strong&gt;, &lt;strong&gt;非命名&lt;/strong&gt; 的构造方法, 如果不存在的话, 要手动使用 &lt;code&gt;super&lt;/code&gt; 调用, 调用要放在初始化列表中, 在构造方法函数体之前.&lt;/p&gt;
&lt;p&gt;可以使用 &lt;code&gt;@overirde&lt;/code&gt; 注解标识覆写的方法.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;构造方法不会被继承的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;class A {
  final _name;
  A(this._name);

  void print() =&amp;gt; print(_name);
}

class B extends A {
  B(String name) : super(name);

  @override
  void print() =&amp;gt; print('hello, $_name');
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;覆写操作符&lt;/h4&gt;
&lt;p&gt;dart 支持类似 C++ 对操作符进行覆写, 支持以下操作符, 使用 &lt;code&gt;operator&lt;/code&gt; 关键字. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;~/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;[]=&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意 &lt;code&gt;!=&lt;/code&gt; 并不支持覆写, 如要判断 &lt;code&gt;e1 != e2&lt;/code&gt;, 只能取巧 &lt;code&gt;!(e1 == e2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果覆写 &lt;code&gt;==&lt;/code&gt; 一定要同时覆写 &lt;code&gt;hashCode&lt;/code&gt; 方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;class Vector {
  final int x, y;

  Vector(this.x, this.y);

  Vector operator +(Vector v) =&amp;gt; Vector(x + v.x, y + v.y);
  Vector operator -(Vector v) =&amp;gt; Vector(x - v.x, y - v.y);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;code&gt;noSuchMethod&lt;/code&gt; 方法&lt;/h4&gt;
&lt;p&gt;当访问不存在的&lt;strong&gt;方法或变量&lt;/strong&gt;时, 会调用该方法, 默认的实现抛出 &lt;code&gt;NoSuchMethodError&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;class A {
  @override
  void noSuchMethod(Invocation invocation) {
    print("no such $(invocatino.memberName);");
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;枚举类型 Enumerated types&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;enum Color { red, green, blue }&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;mixins 类(dart 2.1 之后)&lt;/h3&gt;
&lt;p&gt;Mixins 是为了重用类, 解决单继承的另一种方式, 定义一个 mixin 类需要使用 &lt;code&gt;mixin 关键字, 使用&lt;/code&gt;with` 关键字来继承 mixin 类&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;// 定义 mixin 类
mixin Musical {
  bool canPlayPiano = false;

  void entertainMe() {
    // do something....
  }
}

// 使用 with 关键字
class Musician extends Performer with Musical {}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以限制哪个类可以继承 mixin 类, 使用 &lt;code&gt;on&lt;/code&gt; 关键字&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;mixin MusicalPerformer on Musician {
  // something...
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;泛型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;dart 里的泛型类似 java 的泛型, 如定义  &lt;code&gt;class Cache&amp;lt;T&amp;gt;&lt;/code&gt;, 另外还可以限制泛型的类型 &lt;code&gt;class Cache&amp;lt;T extends SomeBaseClass&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;泛型方法, &lt;code&gt;T first&amp;lt;T&amp;gt;(List&amp;lt;T&amp;gt; ts)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;参数化 collection 字面量和构造方法&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;var nameList = &amp;lt;String&amp;gt;['a', 'b', 'c'];
var nameSet = &amp;lt;String&amp;gt;{'a', 'b', 'c'};
var nameMap = &amp;lt;String, String&amp;gt;{
  'a': 'a',
  'b': 'b'
};

var nameSet2 = Set&amp;lt;String&amp;gt;.from[nameSet];&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Libraries&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;library&lt;/code&gt; 关键字用来导入和定义模块, 使用 &lt;code&gt;_&lt;/code&gt; 开始的只能在模块内可见, 每一个 dart app 都是一个模块, 无论是否有用 &lt;code&gt;library&lt;/code&gt; 声明&lt;/p&gt;
&lt;p&gt;导入语句 &lt;code&gt;import 'package:test/test.dart';&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于内置的模块, 其包名都为 &lt;code&gt;dart&lt;/code&gt;, 如 &lt;code&gt;import dart:html;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对导入的包重命别名: &lt;code&gt;import 'package:lib2/lib2.dart' as lib2;&lt;/code&gt;, 使用 &lt;code&gt;as&lt;/code&gt; 关键字&lt;/p&gt;
&lt;h4&gt;部分导入&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;// 只导入 foo
import 'package:lib1/lib1.dart' show foo;
// 导入除 foo 之外
import 'package:lib2/lib2.dart' hide foo;&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;懒导入(deferred loading 或 lazy loading)&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;懒导入只能在 dart2js 中使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;// 使用 deferred as 语句
import 'package:greetings/hello.dart' deferred as hello;

// 调用懒导入的库, 调用之前要先调用 loadLibrary 方法
Future greet() async {
  await hello.loadLibrary();
  hello.printGreeting();
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;异步&lt;/h3&gt;
&lt;p&gt;异步使用 &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt;, 使用 &lt;code&gt;async&lt;/code&gt; 的函数总是会返回 &lt;code&gt;Future&lt;/code&gt; 对象, 不用显示的返回 &lt;code&gt;Future&lt;/code&gt;, 程序会自动包装, 如果没有返回值则是 &lt;code&gt;Future&amp;lt;void&amp;gt;&lt;/code&gt; 类型. &lt;code&gt;awati&lt;/code&gt; 只能在 &lt;code&gt;async&lt;/code&gt; 函数中使用&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;Future checkVersion() async {
  var version = await lookUpVersion();
  // do something
}

// 在 main 中也可以使用 async
Future main() async {
  checkVersion();
  print('.....');
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;异步流 Streams&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;await for&lt;/code&gt; 可以获取异步循环, &lt;code&gt;await for (var id in expression)&lt;/code&gt;. 可以使用 &lt;code&gt;break&lt;/code&gt; 或者 &lt;code&gt;return&lt;/code&gt; 中断循环. 注意 &lt;code&gt;await for&lt;/code&gt; 只能在 &lt;code&gt;async&lt;/code&gt; 函数中使用&lt;/p&gt;
&lt;h3&gt;生成器 Generators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;同步生成器 Synchronous generator, 返回 &lt;code&gt;Iterable&lt;/code&gt; 对象, 使用 &lt;code&gt;sync*&lt;/code&gt; 修饰函数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;Iterable&amp;lt;int&amp;gt; naturalsTo(int n) sync* {
  int k = 0;
  while (k &amp;lt; n) {
    yield k++;
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;异步生成器 Asynchronous generator, 返回 &lt;code&gt;Stream&lt;/code&gt; 对象, 使用 &lt;code&gt;async*&lt;/code&gt; 修饰函数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;Stream&amp;lt;int&amp;gt; asynchronousNaturalsTo(int n) async* {
  int k = 0;
  while (k &amp;lt; n) {
    yield k++;
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似 Python 里的 yield from, 使用 &lt;code&gt;yield*&lt;/code&gt; 在生成器中返回生成器&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;Iterable&amp;lt;int&amp;gt; naturalsDownFrom(int n) sync* {
  if (n &amp;gt; 0) {
    yield n;
    yield* naturalsDownFrom(n - 1);
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;可调用的类对象 Callable classes&lt;/h3&gt;
&lt;p&gt;类似 Python 类对象可调用的魔术方法 &lt;code&gt;__call__&lt;/code&gt;, dart 里也有一个类内置的方法 &lt;code&gt;call()&lt;/code&gt;, 实现这个方法类对象便也可以像函数一样调用&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;class WannableFunction {
  call(String a, String b, String c) =&amp;gt; '$a, $b, $c';
}

var wf = WannableFunction();
print(wf('Hi', 'there', 'gang'));&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Typedefs&lt;/h3&gt;
&lt;p&gt;类似 C 中的 typedef, 定义类型别名, typedefs 让我们能保持类型的信息, 比如&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;class SortedCollection {
  Function compare;

  SortedCollection(int f(Ojbect a, Object b)) {
    compare = f;
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原先 &lt;code&gt;f&lt;/code&gt; 是一个接受两个参数并返回 &lt;code&gt;int&lt;/code&gt; 的函数, 但传给 &lt;code&gt;compare&lt;/code&gt; 之后, 便只能得到一个 &lt;code&gt;Function&lt;/code&gt; 类型, 已经没有参数和返回值的信息, 使用 &lt;code&gt;typedef&lt;/code&gt; 可以解决这问题&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-dart"&gt;typedef Compare = int Function(Object a, Object b);

class SortedCollection {
  Compare compare;

  SortedCollection(this.compare);
}

// 也可以使用泛型
typedef Compare&amp;lt;T&amp;gt; = int Function(T a, T b);&lt;/code&gt;&lt;/pre&gt;</content><category term="dart"></category></entry><entry><title>WSGI 协议</title><link href="https://ivicel.info/2018/06/wsgi-xie-yi.html" rel="alternate"></link><published>2018-06-01T00:00:00+08:00</published><updated>2018-06-01T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-06-01:/2018/06/wsgi-xie-yi.html</id><summary type="html">&lt;h4&gt;1. 简介&lt;/h4&gt;
&lt;p&gt;WSGI(Web Server Gateway Interface) 定义在 &lt;a href="https://www.python.org/dev/peps/pep-3333/"&gt;PEP 3333&lt;/a&gt; 中, WSGI 不是要重新创造一个 web server 或者 framework, 而是定义一个标准接口, 实现这个标准接口的 web server 都可以通过该接口调用 python 程序, 从而使用 python 程序来处理网络数据, 然后再发回给 client.&lt;/p&gt;
&lt;p&gt;WSGI 实现分为 client 端和 server 端, 并且 WSGI 是可以按层堆叠的, 中间层称为 middleware. middleware 其实质就是实现了 client, server 两种, 这样来看, 上层总是下层的 server, 下层是上层的 client …&lt;/p&gt;</summary><content type="html">&lt;h4&gt;1. 简介&lt;/h4&gt;
&lt;p&gt;WSGI(Web Server Gateway Interface) 定义在 &lt;a href="https://www.python.org/dev/peps/pep-3333/"&gt;PEP 3333&lt;/a&gt; 中, WSGI 不是要重新创造一个 web server 或者 framework, 而是定义一个标准接口, 实现这个标准接口的 web server 都可以通过该接口调用 python 程序, 从而使用 python 程序来处理网络数据, 然后再发回给 client.&lt;/p&gt;
&lt;p&gt;WSGI 实现分为 client 端和 server 端, 并且 WSGI 是可以按层堆叠的, 中间层称为 middleware. middleware 其实质就是实现了 client, server 两种, 这样来看, 上层总是下层的 server, 下层是上层的 client.&lt;/p&gt;
&lt;h4&gt;2. Client 端&lt;/h4&gt;
&lt;p&gt;client 端会从被 server 端调用, 所以传给 server 的必须是一个 &lt;code&gt;callable&lt;/code&gt; 对象, 比如 &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;method&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, 实现了 &lt;code&gt;__call__&lt;/code&gt; 方法的对象实例, server 端不会假想 client 是怎么实现的, 是一个函数还是一个方法, 只知道这一定是 callable 的. &lt;/p&gt;
&lt;p&gt;server 调用时, 会传会 client 两个参数, 参数名不是固定的, 只是约定俗成而已. 以 &lt;code&gt;function&lt;/code&gt; 来举例: &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;def application(environ, start_response):
    status = '200 OK'
    response_headers = [('Content-Type', 'text/plain')]
    start_response(status, response_headers)
    return [b'hello, world']&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;environ&lt;/code&gt; 是一个 CGI-style  环境变量字典, 由 server 端来传递过, client 可以修改这个字典&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start_response&lt;/code&gt; 是 一个 server 端的一个回调方法, 用来设置返回的 http headers. 其方法定义为 &lt;code&gt;def start_response(status, response_headers, exec_info=None)&lt;/code&gt;
  &lt;code&gt;status&lt;/code&gt; 和 &lt;code&gt;response_headers&lt;/code&gt; 是必须的, &lt;code&gt;status&lt;/code&gt; 表示返回的状态码(string 类型), 比如 &lt;code&gt;"200 OK"&lt;/code&gt;; &lt;code&gt;response_headers&lt;/code&gt; 表示其他的头部信息, 使用一个列表表示, 列表中每一个都是一个 tuple&lt;code&gt;(header_name, header_value)&lt;/code&gt;, 比如 &lt;code&gt;[('Content-Type', 'text/html'), ('Content-Length', 30)]&lt;/code&gt;. &lt;code&gt;exec_info&lt;/code&gt; 是可选的, boolean 值, 用来控制当发生错误时, 向浏览器发送错误消息&lt;/li&gt;
&lt;li&gt;client 要返回一个一 &lt;code&gt;iterable&lt;/code&gt; 并且对于 python 3, &lt;code&gt;iterable&lt;/code&gt; 内必须是 &lt;code&gt;bytes&lt;/code&gt; 类型, 因为写入 socket 的是按字节写入的. 对于 python 2 来说便是 str 类型(在 python 2 中是 str 是字节类型). 通常我们会返回一个 list, 包含 bytes. 比如 &lt;code&gt;[b'Hello, world']&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;3. &lt;code&gt;environ&lt;/code&gt; 参数&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;environ&lt;/code&gt; 参数是从 server 传过来的一些 CGI-style 字典. &lt;/p&gt;
&lt;p&gt;以下这些 key 是必须包含的, 如果 server 没有从浏览器中获取到对应的值, 则其值会是 empty string&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;REQUEST_METHOD&lt;/code&gt;  请求方法, 如 &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;等 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;SCRIPT_NAME&lt;/code&gt;  The initial portion of the request URL's"path" that corresponds to the application object, so that the application knows its virtual "location". This &lt;strong&gt;may&lt;/strong&gt; be an empty string, if the application corresponds to the "root" of the server.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PATH_INFO&lt;/code&gt; 请求路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QUERY_STRING&lt;/code&gt; 查询键值对, 跟着 &lt;code&gt;?&lt;/code&gt; 后的部分&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CONTENT-TYPE&lt;/code&gt; 对应头部中的 &lt;code&gt;Content-Type&lt;/code&gt; 值, 可为空&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CONTENT-LENGTH&lt;/code&gt; 对应头部中的 &lt;code&gt;Content-Length&lt;/code&gt; 值, 可为空&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SERVER_NAME&lt;/code&gt;, &lt;code&gt;SERVER_PORT&lt;/code&gt; 服务器名和端口, 当存在 &lt;code&gt;HTTP_HOST&lt;/code&gt;这个值时, &lt;code&gt;HTTP_HOST&lt;/code&gt; 才是真正的指 服务器地址, 比如 ip, localhost, 域名等, 而这个值一般是一个别名, 比如 my_server_name 这样好记的名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SERVER_PROTOCOL&lt;/code&gt; 请求的协议版本, 比如 &lt;code&gt;HTTP/1.1&lt;/code&gt;, &lt;code&gt;HTTP/1.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HTTP_[Variables]&lt;/code&gt; variables 代表了一系列的值, 这些值一般都是 http 的请求头部信息比如 &lt;code&gt;HTTP_USER_AGENT&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外还有一些值是可选, 为了兼容性, 不能假设非必须的值一定存在, 在使用非必须值前一定要先测试其值是否存在. 以上的值主要是关于请求的环境变量, WSGI 还要求了一些关于 server 的一些变量值, 也是必须要设置的.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;wsgi.version&lt;/code&gt; server 版本号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wsgi.url_scheme&lt;/code&gt; url scheme, 比如 &lt;code&gt;http&lt;/code&gt;, &lt;code&gt;https&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wsgi.input&lt;/code&gt; 基于字节的 Input stream, 可以读取出浏览器发过来的请求体 body&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wsgi.errors&lt;/code&gt; 基于字符的 output stream, 写入错误信息, 以 &lt;code&gt;'\n'&lt;/code&gt; 作为换行符, 一般传入 &lt;code&gt;sys.stderr&lt;/code&gt; 或者错误日志文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wsgi.multithread&lt;/code&gt; 是否基于多线程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wsgi.multiprocess&lt;/code&gt; 是否基于多进程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wsgi.run_once&lt;/code&gt; application 是否只会被调用一次, 但即使为 &lt;code&gt;True&lt;/code&gt; 也不能保证只运行一次&lt;/li&gt;
&lt;/ul&gt;</content><category term="wsgi"></category><category term="python"></category><category term="服务器"></category><category term="协议"></category><category term="web server"></category></entry><entry><title>Android 通知</title><link href="https://ivicel.info/2018/05/android-tong-zhi.html" rel="alternate"></link><published>2018-05-02T00:00:00+08:00</published><updated>2018-05-02T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-05-02:/2018/05/android-tong-zhi.html</id><summary type="html">&lt;h3&gt;1. 简介&lt;/h3&gt;
&lt;h4&gt;1.1 通知可出现的地方&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;以一个图标出现在 status bar 中, 一般是一个单 alpha 通道的图标, 但有些魔改的系统是可以显示多色图标的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;notification drawer 模式, 也就是下拉状态栏&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;heads-up notification 模式, 在 Android 5.0(SDK 21) 之后, 如果当前 app 全屏显示, 手机处于解锁状态, 然后通知拥有高优先级(high priority, Android 7.1, SDK 25)并产生铃音/震动, 或通知的 channel 拥有重要重级(high  importance, Android 8.0, SDK …&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;h3&gt;1. 简介&lt;/h3&gt;
&lt;h4&gt;1.1 通知可出现的地方&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;以一个图标出现在 status bar 中, 一般是一个单 alpha 通道的图标, 但有些魔改的系统是可以显示多色图标的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;notification drawer 模式, 也就是下拉状态栏&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;heads-up notification 模式, 在 Android 5.0(SDK 21) 之后, 如果当前 app 全屏显示, 手机处于解锁状态, 然后通知拥有高优先级(high priority, Android 7.1, SDK 25)并产生铃音/震动, 或通知的 channel 拥有重要重级(high  importance, Android 8.0, SDK 26)的话, 就会弹出一个浮动的通知窗口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锁屏状态中. 在 Android 5.0(SDK 21) 之后, 通知可以出现在 lock screen 中. 在 app 中可以单独设置通知的私密性,  用户也可以设置全局系统通知私密性, 这会覆盖 app 的设置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 Android 8.0(SDK 26) 之后, 如果 launcher 支持了未读通知的 badge, 当长按该 app 时会弹出一个通知, 可以像 notification drawer 左右滑掉或者点击, 即使 app 没有支持长按 shortcuts 也是可以弹出的通知的&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="notification-badges" src="../../assets/images/notification-badges.png" /&gt;&lt;/p&gt;
&lt;h4&gt;1.2 通知基础结构&lt;/h4&gt;
&lt;p&gt;&lt;img alt="basic-notification" src="../../assets/images/basic-notification.png" /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Small icon: 通过 &lt;code&gt;setSmallIcon()&lt;/code&gt; 来设置, 一般为 app 图标, 这个必须设置&lt;/li&gt;
&lt;li&gt;App name: 系统自动设置&lt;/li&gt;
&lt;li&gt;Time stamp: 通知产生的时间, 可以通过 &lt;code&gt;setWhen()&lt;/code&gt; 来设置或使用 &lt;code&gt;setShowWhen(false)&lt;/code&gt; 来隐藏, 默认是当前系统时间. &lt;/li&gt;
&lt;li&gt;Large icon: 可选, 右边缩略图(Thumbnail), 通过 &lt;code&gt;setLargeIcon()&lt;/code&gt; 来设置&lt;/li&gt;
&lt;li&gt;Title: 可选, 通知的标题, 通过 &lt;code&gt;setContentTitle()&lt;/code&gt; 来设置&lt;/li&gt;
&lt;li&gt;Text: 可选, 通知的内容, 单行显示, 超出部分会显示成 &lt;code&gt;…&lt;/code&gt;, 通过 &lt;code&gt;setContentText()&lt;/code&gt; 来设置&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;1.3 通知的兼容性&lt;/h4&gt;
&lt;p&gt;由于通知在每个版本中都有不同的改动, 所以我们总是使用 v4 support library 里的兼容版本 &lt;code&gt;NotificationCompat&lt;/code&gt; 和 &lt;code&gt;NotificationManagerCompat&lt;/code&gt;, 这样我们可以更少写些 API 版本测试条件语句.下面是一些变更总结&lt;/p&gt;
&lt;h5&gt;Andorid 4.1, API level 16&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;增加了可扩展的通知, 即是 notification style. &lt;code&gt;BigTextStyle&lt;/code&gt;, &lt;code&gt;BigPictureStyle&lt;/code&gt;, &lt;code&gt;InboxStyle&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可设置通知多个点击按钮&lt;/li&gt;
&lt;li&gt;可单独关闭某个 app 的通知&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;Andorid 4.4, API level 19&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;增加了通知监听服务 api, notification listener service&lt;/li&gt;
&lt;li&gt;支持 Wear OS(API 20)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;Andorid 5.0, API level 21&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;增加了锁屏通知(通过 &lt;code&gt;setVisibility()&lt;/code&gt; 来设置)和 heads-up 模式&lt;/li&gt;
&lt;li&gt;增加了 Do Not Disturb 防打扰模式&lt;/li&gt;
&lt;li&gt;可以通过 &lt;code&gt;setPriority()&lt;/code&gt; 来设置通知的等级, 这会影响通知在不同模式下的弹出状况&lt;/li&gt;
&lt;li&gt;增加了通知的分组功能 &lt;code&gt;setGroup()&lt;/code&gt;, 这样不会导致同一个 app 在很短时间内收到多条信息时弹出一排的通知&lt;/li&gt;
&lt;li&gt;增加了新的 &lt;code&gt;MediaStyle&lt;/code&gt;, 音乐后台播放时的通知&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;Andorid 7.0, API level 24&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;重新设计了通知模版, 重点突出了 hero image 和 avatar&lt;/li&gt;
&lt;li&gt;增加了新的 style: &lt;code&gt;MessagingStyle&lt;/code&gt; 像短信息一样的排列, &lt;code&gt;DecoratedCustomViewStyle&lt;/code&gt;, &lt;code&gt;DecoratedMediaCustomViewStyle&lt;/code&gt; 自定义的 view, 但依旧由系统进行装饰&lt;/li&gt;
&lt;li&gt;现在可以使用和 Wear OS 一样的通知分组功能, API 是一样的&lt;/li&gt;
&lt;li&gt;增加了在通知里直接回复消息的功能, 只能单行, 不能分段&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;Andorid 8.0, API level 26&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;增加了通知 channel, 在 app 中要注册 channel, 每个通知都必须放到 channel 中. &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Target SDK &amp;lt; 26, 会按 target sdk 来运行&lt;/li&gt;
&lt;li&gt;Target SDK &amp;gt;= 26, 如果运行在 Android 8.0 及以上时, 必须有设置 channel, 否则会打印出 error log. 非 Android 8.0 则按以前的通知行为&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;用户可以对不同 channel 进行关闭, 打开等操作, 代替了以前只能关闭整个 app 的通知&lt;/li&gt;
&lt;li&gt;现在可以在 launcher 中 app 图标上显示有未读通知了, 需要这个 launcher 支持&lt;/li&gt;
&lt;li&gt;可以在下拉栏中滑动通知来设置&lt;strong&gt;稍后提醒(snooze)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;可以设置通知了背景颜色了&lt;/li&gt;
&lt;li&gt;一些 APIs 从 Notification 移到了 NoitficationChannel 中, 比如设置通知的等级 &lt;code&gt;NotificationCompat.Builder.setPriority()&lt;/code&gt;. 如果 target sdk == 21 并且在 8.0 的机器上运行, &lt;code&gt;NotificationCompat.Builder.setPriority()&lt;/code&gt; 会被忽略, 只使用 &lt;code&gt;NotificationChannel.setImportance()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Andorid 8.1, API level 27 之后, 在同一秒内 app 只能发出一次通知铃音. 并且如果在短时间内(一般少于 1 秒)发生多次通知, 系统可能会丢弃其中的一些通知&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;2. 创建通知及通知行为(Notification actions)&lt;/h3&gt;
&lt;h4&gt;2.1 基本通知的创建&lt;/h4&gt;
&lt;p&gt;以 target sdk 26 来创建新的通知&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public static final String CHANNEL_ID = "my_channel_id";
NotificationCompat.Builder builder = new NotificationCompat.Builder(
        context, CHANNEL_ID)
        .setSmallIcon(R.drawable.notification_icon)
        .setContentTitle(textTitle)
        .setContentText(textContent)
        // 为兼容 8.0 以下系统的优先级
        .setPriority(NotificationCompat.PRIORITY_DEFAULT);  

// 兼容 8.0 系统的 channel 设置
if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.O) {
    // 传入 channel id, channel name, 和优先级, 运行在 8.0 及以上时会忽略 setPriority
    NotificationChannel channel = new NotificationChannel(CHANNEL_ID, channelName,
            NotificationManager.IMPORTANCE_DEFAULT);
    channel.setDescription(description);
    // 向系统注册这个 channel
    NotificationManager manager = (Notification) context.getSystemService(
            Context.NOTIFICATION_SERVICE);
    manager.createNotificationChannel(channel);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在创建完通知后, 可以通过 &lt;code&gt;NotificationManagerCompat.notify()&lt;/code&gt; 来显示通知.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;NotificationMangerCompat notificationManger = NotificationMangerCompat.from(context);
notificationManger.notify(notificationId, builder.build());&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;notificationId&lt;/code&gt; 是一个重要的参数, 之后我们通 &lt;code&gt;cancel(notificationId)&lt;/code&gt; 来取消特定通知, 或者 &lt;code&gt;cancelAll()&lt;/code&gt; 取消所有通知. &lt;/p&gt;
&lt;p&gt;对同一个 &lt;code&gt;notificationId&lt;/code&gt; 进行调用 &lt;code&gt;NotificationManagerCompat.notify()&lt;/code&gt; 便会更新通知&lt;/p&gt;
&lt;h4&gt;2.2 通知的点击行为(tap action)&lt;/h4&gt;
&lt;p&gt;在下拉通知中, 通过点击通知可以跳转到通过的来源处, 通过 &lt;code&gt;setContentIntent(PendingIntent)&lt;/code&gt; 来实现. PendingIntent 可以启动 activity, service, 发送 broadCast. &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 启动一个 activity
Intent intent = new Intent(context, SourceActivity.class);
// 设置一个新栈来跳转, 这样不会影响当前任务栈里的 activity
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
PendingIntent pi = PendingIntent.getActivity(context, 0, intent, 0);

builder.setContentIntent(pi)
        // 设置点击后关闭通知
        .setAutoCancel(true);&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2.3 通知的 action button&lt;/h4&gt;
&lt;p&gt;在 Android 4.1 之后, 通知可设置如下图的 action button, 通过 &lt;code&gt;addAction()&lt;/code&gt; 来设置&lt;/p&gt;
&lt;p&gt;&lt;img alt="notification-basic-action" src="../../assets/images/notification-basic-action.png" /&gt;&lt;/p&gt;
&lt;p&gt;比如点击后, 产生一个广播的代码如下. 可以添加多个 action button&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;Intent snoozeIntent = new Intent(context, MyBroadCastReceiver.class);
snoozeIntent.setAction(ACTION_SNOOZE);
snoozeIntent.putExtra(EXTRA_NOTIFICATION_ID, 0);
PendingIntent pi = PendingIntent.getBroadcast(context, 0, snoozeIntent, 0);
// 向通知添加 action button 事件
builder.addAction(R.drawable.ic_snooze, snoozeString, pi);&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2.4 direct reply 直接回复按钮&lt;/h4&gt;
&lt;p&gt;在 Android 7.0, API level 24 之后添加可以直接在通知栏回复消息的按钮. 点击前和点击后的样式如下图&lt;img alt="reply-button1" src="../../assets/images/reply-button.png" /&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;private static final String KEY_TEXT_REPLY = "key_text_reply";

if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.N) {
    // 1. 创建一个 RemoteInput. 传入的 key 值会在发送的 intent 中用来获得消息体
    RemoteInput remoteInput = new RemoteInput.Builder(KEY_TEXT_REPLY)
            .setLabel(replyLabel)
            .build();

    // 2. 创建一个 PendingIntent 用来产生点击行为
    PendingIntent replyPendingIntent = PendingIntent.getBroadcast(context,
            conversationRequestCode, intent, PendingIntent.FLAG_UPDATE_CURRENT);

    // 3. 使用 addRemoteIput 将 RemoteInput 添加一通知中
    NotificationCompat.Action action = new NotificationCompat.Action.Builder(
            R.drawabl.ic_reply_action, labelString, replyPendingIntent)
            .addRemoteInput(remoteInput)
            .build();

    // 4. 创建并发出通知
    Notification notification = new NotificationCompat.Builder(context, CHANNEL_ID)
            .setSmallIcon(R.drawable.notification_icon)
            .setContentTitle(title)
            .setContentText(text)
            .addAction(action)
            .build();

    NotificationManagerCompat.from(context).notify(id, notification);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 &lt;code&gt;RemoteInput.getResultsFromIntent()&lt;/code&gt; 在 BroadCastReceiver 中获得传过来的 intent 里的消息&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// intent 便是传入 broadcast 里的 intent, 使用原先传入的 key 值
private CharSequence getMessageText(Intent intent) {
    Bundle remoteInput = RemoteInput.getResultsFromIntent(intent);
    if (remoteInput != null) {
        return remoteInput.getCharSequence(KEY_TEXT_REPLY);   
    }

    return null;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在用户使用直接回复之后, 我们还要关闭这个通知, 显示已回复等&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;Notification repliedNotification = new NotificationCompat.Builder(context, CHANNEL_ID)
        .setSmallIcon(R.drawable.message_replied)
        .setContentText(repliedString)
        .build();
// 使用上一个通知的 id, 以便覆盖掉上个通知
notificationManager.notify(id, repliedNotification);&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2.5 通知栏进度条&lt;/h4&gt;
&lt;p&gt;通过 &lt;code&gt;NotificationCompat.Builder.setProgress(max, progress, false)&lt;/code&gt; 不断更改当前进度 &lt;code&gt;progress&lt;/code&gt;, 最大值 &lt;code&gt;max&lt;/code&gt; 一般设置为 100 之类. &lt;/p&gt;
&lt;p&gt;当完成之后, 通过设置 &lt;code&gt;max&lt;/code&gt; 为 0 来隐藏进度条, &lt;code&gt;Notification.Builder.setProgree(0, 0, false)&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最后个参数影响进度条是显示确定的百分比样式, 还是显示一个不断滚动的样式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;2.6 锁屏通知策略&lt;/h4&gt;
&lt;p&gt;我们可以通过 &lt;code&gt;NotificationManger.Builder.setVisibilty()&lt;/code&gt; 方法来设置通知在锁屏时的显示策略. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NotificationCompat.VISIBILITY_PUBLIC&lt;/code&gt;: 显示通知所有内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NotificationCompat.VISIBILITY_SECRET&lt;/code&gt;: 不显示任何通知内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NotificationCompat.VISIBILITY_PRIVATE&lt;/code&gt;: 显示通知的基础信息, 比如 app 名, 通知标题, 或者像 "你有 3 条新的消息" 之类, 这个消息是可以自定义的, 通过 &lt;code&gt;setPublicVersion()&lt;/code&gt; 方法来设置&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;编码时虽然可以设置锁屏通知策略, 但最终会受到用户的系统设置的影响, 被其覆盖掉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;2.7 Notification badge&lt;/h4&gt;
&lt;p&gt;在 Android 8.0, API 26 之后, 可以在 launcher app 图标右上角显示有通知, 需要 launcher 支持 shortcuts. 通知点是系统自动加入的, 如果不需要显示可以使用 &lt;code&gt;setBadge(false)&lt;/code&gt; 来取消显示. &lt;/p&gt;
&lt;p&gt;长按 app 弹出通知时, 系统会自动计算当前 app 共有几条通知, 数量显示在弹出的窗口右上角, 可以通过 &lt;code&gt;setNumber()&lt;/code&gt; 来手动设置自己需要的数字.&lt;/p&gt;
&lt;p&gt;弹出的窗口默认使用的是 large icon, 可以通过 &lt;code&gt;setBadgeIconType(BADGE_ICON_SMALL)&lt;/code&gt; 来更改使用 small icon.&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;setShortcutId()&lt;/code&gt; 来在弹出通知窗口时, 隐藏 shortcut&lt;/p&gt;
&lt;h3&gt;3. 可扩展的通知(Expandable notification)&lt;/h3&gt;
&lt;p&gt;基础的通知是只包含一个标题, 一行文字, 一个或多个操作. 系统内置了一些可扩展开来的通知, 可以通过 &lt;code&gt;setStyle()&lt;/code&gt; 来设置&lt;/p&gt;
&lt;h4&gt;3.1 BigPictureStyle 大图模式&lt;/h4&gt;
&lt;p&gt;大图模式常见的是截图时的样式&lt;/p&gt;
&lt;p&gt;&lt;img alt="bigpicturestyle" src="../../assets/images/bigpicturestyle.png" /&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;Notification noti = new NotificationCompat.Builder(context, CHANNEL_ID)
        .setSmallIcon(R.drawable.new_post)
        .setLargeIcon(myBitmap)
        .setStyle(new NotificationCompat.BigPictureStyle()
                .setBigPicture(myBitmap)
                .bigLargeIcon(null))        // 下拉时, 把右边的缩略图设置为 null
    .build();&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;3.2 BigTextStyle 多文本模式&lt;/h4&gt;
&lt;p&gt;&lt;img alt="large-text" src="../../assets/images/large-text.png" /&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;builder.setStyle(new NotificationCompat.BigTextStyle()
        // 设置长文本, 文本换自动换行, 单行的原本还是使用 setContentText 
        .bigText(textString))
        .build();&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;3.3 InboxStyle&lt;/h4&gt;
&lt;p&gt;这个模式相当于可以设置多个单行, 超出的文本不会自己换行而是使用 &lt;code&gt;…&lt;/code&gt; 来代替&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;builder.setStyle(new NotificationCompat.InboxStyle()
        .addLine(str1)
        .addLine(str2)
        .addLine(str3))
    .build();&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;3.4 MessagingStyle&lt;/h4&gt;
&lt;p&gt;像信息 app 一样能设置对话形式的样式&lt;img alt="messaging-style" src="../../assets/images/messaging-style.png" /&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;Notification notification = new NotificationCompat.Builder(context, CHANNEL_ID)
        .setSmallIcon(R.drawable.new_message)     
        .setLargeIcon(aBitmap)
        .setStyle(new Notification.MessagingStyle(
                resources.getString(R.string.reply_name))
                .addMessage(text1, time1, sender1)
                .addMessage(text2, time2, sender2))
        .build();&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;3.5 MediaStyle&lt;/h4&gt;
&lt;p&gt;MediaStyle 有两个兼容包, &lt;code&gt;android.support.v4.media.app.NotificationCompat.MediaStyle&lt;/code&gt; 和 &lt;code&gt;android.support.v7.app.NotificationCompat.MediaStyle&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;v7 的包是继承了 v4 包的类, 在 API level 26 以上, v7 包类已经弃用, 如果使用 v4 包, 还需要向 build.gradle 中添加 &lt;code&gt;com.andorid.support:support-media-compat:27.1.1&lt;/code&gt; 支持库. &lt;/p&gt;
&lt;p&gt;MediaStyle 一般用于音乐播放器, 其界面类似下图&lt;/p&gt;
&lt;p&gt;&lt;img alt="media-style" src="../../assets/images/media-style.png" /&gt;&lt;/p&gt;
&lt;p&gt;MediaStyle 扩展界面最多可以添加 5 个按钮, 按钮的顺序从左到右为添加的顺序. 非扩展界面最多可以显示 3 个按钮. 显示的按从扩展界面添加的顺序中选出序号(0-4). &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果只添加了 4 个按钮, 却在非扩展里选择超出的下标值, 比如 4 则 app crash&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;builder = new NotificationCompat.Builder(this, CHANNEL_ID)
        .setSmallIcon(R.mipmap.ic_launcher_round)
        .setLargeIcon(bitmap)
        .setContentTitle("Song's name")
        .setContentText("Singer's name")
        // 按钮的显示按添加的顺序从左向右排列
        .addAction(new NotificationCompat.Action(
                R.drawable.ic_thumb_down, "Down", actionPendingIntent))
        .addAction(new NotificationCompat.Action(
                R.drawable.ic_play_previous, "Previous", actionPendingIntent))
        .addAction(new NotificationCompat.Action(
                R.drawable.ic_pause, "Pause", actionPendingIntent))
        .addAction(new NotificationCompat.Action(
                R.drawable.ic_play_next, "Next", actionPendingIntent))
        .addAction(new NotificationCompat.Action(
                R.drawable.ic_thumb_up, "Up", actionPendingIntent))
        .setStyle(new android.support.v4.media.app.NotificationCompat.MediaStyle()
        // 设置非扩展界面显示的按钮, 参数为一个整型下标数组
        .setShowActionsInCompactView(1, 2, 3));&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;4. 通知分组&lt;/h4&gt;
&lt;p&gt;在 Android 7.0, API 24 之后, 可以对通知按 app 来分组. 如果使用分组策略, 在低于 Android 7.0 的系统会忽略这个功能, 还是一条一条的发出来. 在 7.0 以上, 系统也会自动把一个 app 的 4 个及以上的通知归为一个组&lt;/p&gt;
&lt;p&gt;&lt;img alt="notification-group" src="../../assets/images/notification-group.png" /&gt;&lt;/p&gt;
&lt;p&gt;分组的使用方法是, 对想要分组的通知使用 &lt;code&gt;setGroup(key)&lt;/code&gt; 来设置一个 group key, 拥有同一个 group key 的通知会被分到同一个组(这个通知要注意使用不同的 id, 因为这些通知都是独立的). 发送出这个通知后, 我们还要发送一个整理-归类通知, 告诉系统, 把上一个通知分到组里面, 而不是作为一个普通的通知显示出来. &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;String GROUP_KEY_WORK_EMAIL = "com.android.example.WORK_EMAIL";
// 发送普通的通知
final Notification notification = new NotificationCompat.Builder(this, CHANNEL_ID)
        .setSmallIcon(R.mipmap.ic_launcher_round)
        .setContentText(text)
        .setContentTitle(title)
        .setAutoCancel(true)
        .setGroup(GROUP_KEY_WORK_EMAIL)
        .build();

mNotificationManager.notify(getNewNotificationId(), notification);

// 当超过两个通知时, 发送一个合并分组通知
final Notification summaryNotification = new NotificationCompat.Builder(this, 
            CHANNEL_ID)
        .setSmallIcon(R.drawable.ic_notify_summary_status)
        .setStyle(new NotificationCompat.InboStyle()
                  .setBigContentTitle(bigContentTitle)
                  .setSummaryText(summaryText))
        .setGroup(GROUP_KEY_WORK_EMAIL)
        .setGroupSummary(true);
        .build();&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;5. Notification Channel&lt;/h3&gt;
&lt;p&gt;在 Android 8.0, API 26 之后, 增加了通知 channel, 把通知都放在 channel 中, 这样可以单独对 channel 进行设置, 而不用对全局的 app 通知进行设置, 有分类性, 针对性更强. 比如邮件 app 中, 可以关闭该 app 的有新邮件通知, 但可另外设置一个 channel, 在这 channel 中的邮件通知还依然显示.&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;targetSdkVersion&lt;/code&gt; 为 26 及以上, 那么当运行在 8.0 及以上时系统时, 必须要设置 channel, 否则通知将不能显示, 并将打印出错误 log(可以在开发者选项中设置显示通知 channel 警告, 会弹出一个 toast)&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;targetSdkVersion&lt;/code&gt; 为 25 及以下, 那么无论运行在哪个系统上, 行为将和 Android 7.1 及以下版本一样&lt;/p&gt;
&lt;p&gt;&lt;img alt="channel-settings" src="../../assets/images/channel-settings.png" /&gt;&lt;/p&gt;
&lt;h4&gt;5.1 创建 channel 的步骤:&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;由于 &lt;code&gt;NotificationChannel&lt;/code&gt; 类没有兼容版本, 只 API 26 及以上存在, 所以需要对 &lt;code&gt;SDK_INT&lt;/code&gt; 进行版本检查.&lt;/li&gt;
&lt;li&gt;创建一个 &lt;code&gt;NotificationChannel&lt;/code&gt; 对象, 传入一个惟一的 channel id, 一个用户可见的 channel name, 和该 channel 的 importance 等级&lt;/li&gt;
&lt;li&gt;可额外设置 channel 的描述 &lt;code&gt;setDescription()&lt;/code&gt;, 这样用户点开通知设置时可见&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;NotificationManager#createNotificationChannel()&lt;/code&gt; 方法注册该 channel&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;private void createNotificationChannel() {
    // 兼容检查
    if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.O) {
        NotificationChannenl channel = new NotificationChannel(CHANNEL_ID, 
                channelName, NotificationManager.IMPORTANCE_DEFAULT);
        channel.setDescription(channelDescription);
        NotificationManager manager = (NotificationManager) getSystemService(
                Context.NOTIFICATION_SERVICE);
        manager.createNotificationChannel(channel);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;5.2 用户通知 channel 设置&lt;/h4&gt;
&lt;p&gt;一但注册通知 channel 后, 我们在编码时只能更改 channel name 和 channel description, 而其他的设置只能交由用户自己设置更改. 为了能让用户自己作出更改, 需要为用户提供一个 settings ui, 通过 &lt;code&gt;Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS&lt;/code&gt; . 下面是启动一个通知设置的示例&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;Intent intent = new Intent(Settings.ACTIOIN_CHANNEL_NOTIFICATION_SETTINGS);
// 这两个值是必须要值的, 包名和通知 id
intent.putExtra(Settings.EXTRA_APP_PACKAGE, getPackageName());
intent.putExtra(Settings.EXTRA_CHANNEL_ID, myNotificationChannel.getId());
startActivity(intent);&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;5.3 删除通知 channel&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;private void deleteNotification(String notificationId) {
    if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.O) {
        NotificationManager manger = (NotificationManager) getSystemService(
                Context.NOTIFICATION_SERVICE);
        manager.deleteNotificationChannel(notificatioinId);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;5.4 分组 channel&lt;/h4&gt;
&lt;p&gt;可以对 channel 进行不同的分组, 这个在多用户 app 上对不同的用户可以设置不同 channel 策略&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 每一个分组都需要一个惟一的 group id
String groupId = "my_group_id";
// 用户可见的 group name
CharSequence groupName = getString(R.string.group_name);
NotificationManager manger = (NotificationManager) getSystemService(
        Context.NOTIFICATION_SERVICE);
manager.createNotificationChannelGroup(new NotificationChannelGroup(
        groupId, groupName));
// 创建完 channel group 的后, 使用 setGroup 对 channel 进行分组
channel.setGroup(groupId);&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;6. 通知的重要性(Importance)和优先级(Priority)&lt;/h3&gt;
&lt;p&gt;在 Android 8.0 使用通知 channel 后, 通知的优先级 API 被移到了 &lt;code&gt;NotificationChannel&lt;/code&gt; 中. 在低于 8.0 的系统里依旧使用 &lt;code&gt;setPriority()&lt;/code&gt; 设置优先级, 而 8.0 及以上则忽略该设置, 使用 &lt;code&gt;NotificationChannel#setImportance()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下表是 importance(&lt;code&gt;NotificationManager.IMPORTANCE_*&lt;/code&gt;) 和 priority(&lt;code&gt;NotificationMangerCompat.PRIORITY_*&lt;/code&gt;) 的对应设置&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;用户可见通知等级&lt;/th&gt;
&lt;th&gt;Importance(8.0 及以上)&lt;/th&gt;
&lt;th&gt;Priority(7.1 及以下)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Urgent&lt;/strong&gt; (紧急通知)&lt;br&gt;响铃并弹出 heads-up 模式&lt;/td&gt;
&lt;td&gt;&lt;code&gt;IMPORTANCE_HIGHT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;RPIORITY_HIGH&lt;/code&gt; 或 &lt;br&gt;&lt;code&gt;PRIORITY_MAX&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;High&lt;/strong&gt; (高)&lt;br&gt;响铃&lt;/td&gt;
&lt;td&gt;&lt;code&gt;IMPORTANCE_DEFAULT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;PRIORITY_DEFAULT&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Medium&lt;/strong&gt; (中)&lt;br&gt;不响铃&lt;/td&gt;
&lt;td&gt;&lt;code&gt;IMPORTANCE_LOW&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;PRIORITY_LOW&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Low&lt;/strong&gt; (低)&lt;br&gt;不响铃且不会出现在通知栏&lt;/td&gt;
&lt;td&gt;&lt;code&gt;IMPORTANCE_MIN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;PRIORITY_MIN&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;通知的等级不会影响通知提示出现在非打断用户界面(non-inpterruptive system UI location), 比如 launcher 里 app 右上角的提示(badges/notification dots)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;7. 2.7 系统内置的通知分类(system-wide category)和免打扰模式(Do Not Disturb mode)&lt;/h3&gt;
&lt;p&gt;Android 系统内置了一些预定义默认的通知分类, 比如 &lt;code&gt;CATEGORY_ALARM&lt;/code&gt;, &lt;code&gt;CATEGORY_REMIDER&lt;/code&gt;, &lt;code&gt;CATEGORY_EVENT&lt;/code&gt; 等等, 使用 &lt;code&gt;NotificationCompat.Builder#setCategory()&lt;/code&gt; 来为通知设定一个分类. 内置分类会影响在免打扰模式下的通知行为.&lt;/p&gt;
&lt;p&gt;在 Android 5.0, API 21 之后增加了免打扰模式, 一共有 3 个等级&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全部静音(Total silence): 阻止所有铃音, 震动, 包括闹钟, 音乐, 视频, 游戏等&lt;/li&gt;
&lt;li&gt;闹钟除外(Alarms only): 除闹钟之外, 阻止所有铃音和震动&lt;/li&gt;
&lt;li&gt;设置优先级除外(Priority only): 用户可以根据系统分类来设置不同的免打扰策略&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Android 8.0, API 26 及以上, 用户可以通过设置 channel 的影响免打扰模式&lt;/p&gt;
&lt;p&gt;&lt;img alt="do-not-disturb-filter-settings" src="../../assets/images/do-not-disturb-filter-settings.png" /&gt;&lt;/p&gt;
&lt;h3&gt;Reference&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/ui/notifiers/notifications"&gt;https://developer.android.com/guide/topics/ui/notifiers/notifications&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.im/entry/5925be652f301e006b3fd6a7"&gt;https://juejin.im/entry/5925be652f301e006b3fd6a7&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="通知"></category><category term="notification"></category></entry><entry><title>Android 动画分析</title><link href="https://ivicel.info/2018/05/android-dong-hua-fen-xi.html" rel="alternate"></link><published>2018-05-01T00:00:00+08:00</published><updated>2018-05-01T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-05-01:/2018/05/android-dong-hua-fen-xi.html</id><summary type="html">&lt;p&gt;Android 的动画分为以下两类:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;View 动画&lt;/li&gt;
&lt;li&gt;补间动画(Tween Animation, &lt;code&gt;Animation&lt;/code&gt; 类及其子类): 通过对 view 不断的作 rotate, scale, translate 等一系列操作从而达到动画效果, xml 文件放在 &lt;code&gt;res/anim/&lt;/code&gt; 目录中&lt;/li&gt;
&lt;li&gt;帧动画(Frame Animation, &lt;code&gt;AnimationDrawable&lt;/code&gt; 类): 通过播放一系列预先生成好的图片达到的动画效果, 像电影胶片一样, 因为是不断的更换图片, 容易产生 OOM, xml 文件放在 &lt;code&gt;res/drawable/&lt;/code&gt; 目录中&lt;/li&gt;
&lt;li&gt;属性动画(Property Animation): 通过不断的改变 view 的各种属性而达到动画效果,  帧动画存放在 &lt;code&gt;res/animator/&lt;/code&gt; 中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;动画的定义可以由 xml 格式来定义, 也可以直接在 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Android 的动画分为以下两类:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;View 动画&lt;/li&gt;
&lt;li&gt;补间动画(Tween Animation, &lt;code&gt;Animation&lt;/code&gt; 类及其子类): 通过对 view 不断的作 rotate, scale, translate 等一系列操作从而达到动画效果, xml 文件放在 &lt;code&gt;res/anim/&lt;/code&gt; 目录中&lt;/li&gt;
&lt;li&gt;帧动画(Frame Animation, &lt;code&gt;AnimationDrawable&lt;/code&gt; 类): 通过播放一系列预先生成好的图片达到的动画效果, 像电影胶片一样, 因为是不断的更换图片, 容易产生 OOM, xml 文件放在 &lt;code&gt;res/drawable/&lt;/code&gt; 目录中&lt;/li&gt;
&lt;li&gt;属性动画(Property Animation): 通过不断的改变 view 的各种属性而达到动画效果,  帧动画存放在 &lt;code&gt;res/animator/&lt;/code&gt; 中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;动画的定义可以由 xml 格式来定义, 也可以直接在 java 代码中直接生成. 然后在对应的 view 里调用动画的 start 方法&lt;/p&gt;
&lt;h3&gt;1. 补间动画(Tween Animation)&lt;/h3&gt;
&lt;p&gt;补间动画一共有 4 个动画方式, 对应 &lt;code&gt;Animation&lt;/code&gt; 类下的 4 个子类, 也可以用 xml 格式来定义动画&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平移标签 &lt;code&gt;&amp;lt;translate&amp;gt;&lt;/code&gt;, 对应类 &lt;code&gt;TranslateAnimation&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;缩放标签 &lt;code&gt;&amp;lt;scale&amp;gt;&lt;/code&gt;, 对应类 &lt;code&gt;ScaleAnimation&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;旋转标签 &lt;code&gt;&amp;lt;rotate&amp;gt;&lt;/code&gt;, 对应类 &lt;code&gt;RotateAnimation&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;透明度标签 &lt;code&gt;&amp;lt;alpha&amp;gt;&lt;/code&gt;, 对应类 &lt;code&gt;AlphaAnimation&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在 drawable 中也有 scale, rotate 标签, 不过存放目录不同, 生成的 java 类也是不同(Drawable).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;set xmlns:android="http://schemas.android.com/apk/res/android"
    android:interpolator="@[package:]anim/interpolator_resource"
    android:shareInterpolator=["true" | "false"] &amp;gt;
    &amp;lt;alpha
        android:fromAlpha="float"
        android:toAlpha="float" /&amp;gt;
    &amp;lt;scale
        android:fromXScale="float"
        android:toXScale="float"
        android:fromYScale="float"
        android:toYScale="float"
        android:pivotX="float"
        android:pivotY="float" /&amp;gt;
    &amp;lt;translate
        android:fromXDelta="float"
        android:toXDelta="float"
        android:fromYDelta="float"
        android:toYDelta="float" /&amp;gt;
    &amp;lt;rotate
        android:fromDegrees="float"
        android:toDegrees="float"
        android:pivotX="float"
        android:pivotY="float" /&amp;gt;
    &amp;lt;set&amp;gt;
        ...
    &amp;lt;/set&amp;gt;
&amp;lt;/set&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; 代表一个动画组, 可以包括单个/多个动画, 或者包含其他动画组. 对应类 &lt;code&gt;AnimationSet&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:interpolator&lt;/code&gt; 插值器. 本质上就是定义动画如何变化的数学函数, 变化规律&lt;/li&gt;
&lt;li&gt;&lt;code&gt;andorid:shareInterpolator&lt;/code&gt; 是否在子组中共享插值器. 不共享时子动画需要自己指定&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;alpha&amp;gt;&lt;/code&gt; 淡入/淡出标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:fromAlpha&lt;/code&gt; 开始值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:toAlpha&lt;/code&gt; 结束值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;scale&amp;gt;&lt;/code&gt; 缩放标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:fromXScale&lt;/code&gt; 横坐标开始值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:toXScale&lt;/code&gt; 横坐标结束值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:fromYScale&lt;/code&gt; 纵坐标开始值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;andorid:toYScale&lt;/code&gt; 纵坐标结束值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:pivotX&lt;/code&gt; 缩放中心的 x 坐标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:pivotY&lt;/code&gt; 缩放中心的 y 坐标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;translate&amp;gt;&lt;/code&gt; 平移标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:fromXDelta&lt;/code&gt; x 起始位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:toXDelta&lt;/code&gt; x 结束位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:fromYDelta&lt;/code&gt; y 起始位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:toYDelta&lt;/code&gt; y 结束位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rotate&lt;/code&gt; 旋转标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:fromDegrees&lt;/code&gt; 旋转开始的角度, 比如 0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:toDegrees&lt;/code&gt; 旋转结束的角度, 比如 180&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:pivotX&lt;/code&gt; 旋转的中心点横坐标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:pivotY&lt;/code&gt; 旋转的中心点纵坐标&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 java 代码来启动动画&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;ImageView iv = findViewById(R.id.image_view);
Animation animation = AnimationUtils.loadAnimation(this, R.anim.my_animation);
// 另外还可以设置动画时间, 动画完成后是否停留在结束位置
animation.setDuration(3000);
animation.setFillAfter(true);
iv.startAnimation(animation);&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2. 帧动画(Frame Animation)&lt;/h3&gt;
&lt;p&gt;帧动画比较简单, 就是按规定的顺序来播放一系列的图片. 需要注意的是避免加载过多尺寸较大的图片从而引起 OOM. &lt;code&gt;animation-list&lt;/code&gt; 对应的是类 &lt;code&gt;AnimationDrawable&lt;/code&gt;, 可以跟多个 item&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android"
    android:oneshot=["true" | "false"] &amp;gt;
    &amp;lt;item
        android:drawable="@[package:]drawable/drawable_resource_name"
        android:duration="integer" /&amp;gt;
&amp;lt;/animation-list&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;android:oneshot&lt;/code&gt; 是否只播放一次动画&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:drawable&lt;/code&gt; 图片来源&lt;/li&gt;
&lt;li&gt;&lt;code&gt;andorid:duration&lt;/code&gt; 图片播放时间&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;ImageView rocketImage = findViewById(R.id.rocket_image);
rocketImage.setBackgroundResource(R.drawable.rockets);

AnimationDrawable rocketAnimation = (AnimationDrawable) rocketImage.getDrawable();
rocketAnimation.start();&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3. 属性动画(Property Animation)&lt;/h3&gt;
&lt;p&gt;属性动画是 SDK 11 之后加入的特性, 可以对任意的对象而不单单只是 view, 在一定的时间内(默认 300ms)把对象的属性从一个值变化到另一个值. 所以属性动画几乎无所不能. 属性动画对应的类为 &lt;code&gt;Animator&lt;/code&gt;, 资源文件存在 &lt;code&gt;res/animator/&lt;/code&gt; 中&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;set
  android:ordering=["together" | "sequentially"]&amp;gt;
    &amp;lt;objectAnimator
        android:propertyName="string"
        android:duration="int"
        android:valueFrom="float | int | color"
        android:valueTo="float | int | color"
        android:startOffset="int"
        android:repeatCount="int"
        android:repeatMode=["repeat" | "reverse"]
        android:valueType=["intType" | "floatType"]/&amp;gt;

    &amp;lt;animator
        android:duration="int"
        android:valueFrom="float | int | color"
        android:valueTo="float | int | color"
        android:startOffset="int"
        android:repeatCount="int"
        android:repeatMode=["repeat" | "reverse"]
        android:valueType=["intType" | "floatType"]/&amp;gt;

    &amp;lt;set&amp;gt;
        ...
    &amp;lt;/set&amp;gt;
&amp;lt;/set&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; 动画合集, 对应 &lt;code&gt;AnimatorSet&lt;/code&gt; 类, 可以包含 &lt;code&gt;&amp;lt;objectAnimator&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;animator&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; 等. 如果是子 set, 可以有自己的 &lt;code&gt;android:ordering&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;andorid:ordering&lt;/code&gt; 动画的播放顺序. &lt;code&gt;together&lt;/code&gt; 默认, 同时播放; &lt;code&gt;sequentially&lt;/code&gt; 按顺序播放&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;objectAnimator&amp;gt;&lt;/code&gt; 可定义任意对象的属性动画, 对应 &lt;code&gt;ObjectAnimator&lt;/code&gt; 类. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;android:propertyName&lt;/code&gt; 属性名, 比如 "alpha", "backgroundColor", 必须值. 定义之后, 类会通过反射去找对象时对应属性的 getter/setter 方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:duration&lt;/code&gt; 动画播放时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;andorid:valueFrom&lt;/code&gt; 开始值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:valueTo&lt;/code&gt; 结束值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:valueType&lt;/code&gt; 值的类型. 默认 &lt;code&gt;floatType&lt;/code&gt;, 整型 &lt;code&gt;intType&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意开始, 结束值默认是 float 浮点值, 如果是颜色值也是用 float, 如果是 int 型, 需要自己手动设置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;android:startOffset&lt;/code&gt; 调用 &lt;code&gt;ObjectAnimator#start()&lt;/code&gt; 延迟多少毫秒后开始&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:repeatCount&lt;/code&gt; 重复多少次. &lt;code&gt;-1&lt;/code&gt; 表示无限重复. 默认 &lt;code&gt;0&lt;/code&gt; 表示只播放一次. &lt;code&gt;n&lt;/code&gt; 表示一共播放 &lt;code&gt;n + 1&lt;/code&gt;  次&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;android:repeatMode&lt;/code&gt; 重复播放时的模式. &lt;code&gt;repeat&lt;/code&gt; 总是从头开头播放. &lt;code&gt;reverse&lt;/code&gt; 反转播放, 头-&amp;gt;尾-&amp;gt;头-&amp;gt;尾….这样的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;animator&amp;gt;&lt;/code&gt; 可定义在一个指完时间内完成一系列动画. 对应类 &lt;code&gt;ValueAnimator&lt;/code&gt;. 由于 &lt;code&gt;ObjectAnimator&lt;/code&gt; 就是继承的 &lt;code&gt;ValueAnimator&lt;/code&gt; 类, 所以 animator 中定义的值的意思是一样.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于一个定义好的 xml, 可以使用 java 代码来启动动画&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;AnimatorSet as = (AnimatorSet) AnimatorInflater.loadAnimator(myContext, R.animator.property_animator);
as.setTarget(myObject);
as.start();&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4. 属性动画的监听器&lt;/h3&gt;
&lt;p&gt;属性动画主要有两个监听器 &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public interface AnimatorUpdateListener {
    // 开始, 结束, 取消, 重复时调用
    void onAnimationStart(Animator animator);
    void onAnimationEnd(Animator animator);
    void onAnimationCancel(Animator animator);
    void onAnimationRepeat(Animator animator);
}

public interface AnimatorListener {
    // 动画播放每一帧时调用, 即是每一次值改变时调用
    // 这个有时会对一些没有 getter/setter 方法的属性有特别用处, 比如想设置从 0~100 的宽度
    // 可以设置成 0~100 的值变化, 然后在值每次变化时的回调, 更改其宽度
    void onAnimationUpdate(ValueAnimator animation);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;5. 插值器(Interpolator)&lt;/h3&gt;
&lt;p&gt;插值器其实就是一类描述在指定时间内(默认 300ms)变化速率的函数 f(x), 其类都实现了 &lt;code&gt;android.view.animation.Interpolator&lt;/code&gt; 接口. 主要有以下几种, 每个插值类都有对应的 xml 描述. &lt;code&gt;getInterpolation&lt;/code&gt; 方法返回的是一个百分比.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public interface Interpolator {
    abstract float getInterpolation(float input);   
}&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AccelerateDecelerateInterpolator&lt;/code&gt; 动画从开始到结束，变化率是先加速后减速的过程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AccelerateInterpolator&lt;/code&gt; 动画从开始到结束，变化率是一个加速的过程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AnticipateInterpolator&lt;/code&gt; 开始的时候向后，然后向前甩&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AnticipateOvershootInterpolator&lt;/code&gt; 开始的时候向后，然后向前甩一定值后返回最后的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BounceInterpolator&lt;/code&gt; 动画结束的时候弹起&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CycleInterpolator&lt;/code&gt; 动画从开始到结束，变化率是循环给定次数的正弦曲线。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DecelerateInterpolator&lt;/code&gt; 动画从开始到结束，变化率是一个减速的过程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinearInterpolator&lt;/code&gt; 以常量速率改变&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OvershootInterpolator&lt;/code&gt; 向前甩一定值后再回到原来位置&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;6. 估值器(TypeEvaluator)&lt;/h3&gt;
&lt;p&gt;估值器是一个设置值变化的过程, 其参数 fraction 为从 interpolator 接收来的变化百分比, startValue 为初始值, endValue 为最终值, 返回计算后的结果. 默认的有颜色 &lt;code&gt;ArgbEvaluator&lt;/code&gt;, 浮点数/浮点数组 &lt;code&gt;FloatEvaluator&lt;/code&gt;/&lt;code&gt;FloatArrayEvaluator&lt;/code&gt;, 整型/整型数组 &lt;code&gt;IntEvaluator&lt;/code&gt;/&lt;code&gt;IntArrayEvaluator&lt;/code&gt;, 坐标 &lt;code&gt;PoinFEvaluator&lt;/code&gt;, 矩形 &lt;code&gt;RectEvaluator&lt;/code&gt;. 如果不是这些类型的变化, 需要自己定义, 只需要实现 TypeEvaluator&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果不实现 TypeEvaluator, 也可以在监听 Interpolator 的变化时做出值的改变&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public interface TypeEvaluator&amp;lt;T&amp;gt; {
    public T evaluate(float fraction, T starValue, T endValue);   
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Reference:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/resources/animation-resource"&gt;https://developer.android.com/guide/topics/resources/animation-resource&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;&lt;Android 开发艺术探索&gt;&amp;gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="animator"></category><category term="动画"></category><category term="插值器"></category><category term="interpolator"></category><category term="animation"></category></entry><entry><title>Android Drawable资源</title><link href="https://ivicel.info/2018/04/android-drawablezi-yuan.html" rel="alternate"></link><published>2018-04-28T00:00:00+08:00</published><updated>2018-04-28T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-04-28:/2018/04/android-drawablezi-yuan.html</id><summary type="html">&lt;h3&gt;1. drawable 简述&lt;/h3&gt;
&lt;p&gt;drawable 在 Android 中是一个抽象的概念, 对应抽象类 &lt;code&gt;android.graphics.drawable.Drawable&lt;/code&gt;, 包括了各种形式的图片, 层级样式, 状态样式等. drawable 可以在 &lt;code&gt;res/drawable&lt;/code&gt; 中以 &lt;code&gt;xml&lt;/code&gt; 来定义. 也可以在 java 中生成. 大概分为以下 10 种.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/resources/drawable-resource#Bitmap"&gt;Bitmap File&lt;/a&gt; &lt;code&gt;.png&lt;/code&gt;(最好), &lt;code&gt;.jpg&lt;/code&gt;(次), &lt;code&gt;.gif&lt;/code&gt;(尽量不要用)等格式的图片. 对应 &lt;code&gt;BitmapDrawable&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/resources/drawable-resource#NinePatch"&gt;Nine-Patch File&lt;/a&gt; &lt;code&gt;.9.png&lt;/code&gt; 图片.对应 &lt;code&gt;NinePatchDrawable&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/resources/drawable-resource#LayerList"&gt;Layer List&lt;/a&gt; 多层次 drawable …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;h3&gt;1. drawable 简述&lt;/h3&gt;
&lt;p&gt;drawable 在 Android 中是一个抽象的概念, 对应抽象类 &lt;code&gt;android.graphics.drawable.Drawable&lt;/code&gt;, 包括了各种形式的图片, 层级样式, 状态样式等. drawable 可以在 &lt;code&gt;res/drawable&lt;/code&gt; 中以 &lt;code&gt;xml&lt;/code&gt; 来定义. 也可以在 java 中生成. 大概分为以下 10 种.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/resources/drawable-resource#Bitmap"&gt;Bitmap File&lt;/a&gt; &lt;code&gt;.png&lt;/code&gt;(最好), &lt;code&gt;.jpg&lt;/code&gt;(次), &lt;code&gt;.gif&lt;/code&gt;(尽量不要用)等格式的图片. 对应 &lt;code&gt;BitmapDrawable&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/resources/drawable-resource#NinePatch"&gt;Nine-Patch File&lt;/a&gt; &lt;code&gt;.9.png&lt;/code&gt; 图片.对应 &lt;code&gt;NinePatchDrawable&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/resources/drawable-resource#LayerList"&gt;Layer List&lt;/a&gt; 多层次 drawable 数组, 按层绘制到屏幕, 下标大的会绘制在上面, 小的绘制在下面. 对应 &lt;code&gt;LayerDrawable&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/resources/drawable-resource#StateList"&gt;State List&lt;/a&gt; 状态数组, 比如选中, 未选中, 点击等状态. 对应 &lt;code&gt;StateListDrawable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/resources/drawable-resource#LevelList"&gt;Level List&lt;/a&gt; 等级 drawable 数组, 数组中每个 Item 都有一个 minLevel, maxLevel, 可以使用 &lt;code&gt;View#setLevel()&lt;/code&gt;, &lt;code&gt;ImageView#setImageLevel()&lt;/code&gt; 来设置按等级获取图片. 对应 &lt;code&gt;LevelListDrawable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/resources/drawable-resource#Transition"&gt;Transition Drawable&lt;/a&gt; 定义了 drawable 之间过滤的形式, 对应  &lt;code&gt;TransitionDrawable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/resources/drawable-resource#Inset"&gt;Inset Drawable&lt;/a&gt; 定义了一个 drawable 以一个范围差值插入另一个 drawable 中. 比如向一个 view 插入 drawable, 但这个 drawable 比 view 的边界大或小, 可以使用这个来放大或缩小到实际边界. 对应 &lt;code&gt;InsetDrawable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/resources/drawable-resource#Clip"&gt;Clip Drawable&lt;/a&gt; 一个切割其他 drawable 的 drawable. 对应 &lt;code&gt;ClipDrawable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/resources/drawable-resource#Scale"&gt;Scale Drawable&lt;/a&gt; 一个定义了如何放大缩小的 drawable. 对应 &lt;code&gt;ScaleDrawable&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/resources/drawable-resource#Shape"&gt;Shape Drawable&lt;/a&gt; 定义了矩形, 椭圆, 圆, 直线等几何形状, 包含渐变, 颜色的 drawable. 对应 &lt;code&gt;GradientDrawable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Rotate Drawable 定义了图形可旋转的角度, 对应 &lt;code&gt;RotateDrawable&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;2. BitmapDrawable(bitmap 标签)&lt;/h3&gt;
&lt;p&gt;创建方法一是直接把 &lt;code&gt;.png&lt;/code&gt;, &lt;code&gt;.jpg&lt;/code&gt;, &lt;code&gt;.gif&lt;/code&gt; 图片放在 &lt;code&gt;res/drawable&lt;/code&gt; 目录下, 通过 &lt;code&gt;R.drawable.name&lt;/code&gt; 访问. 二是通过 xml 来创建, 使用 &lt;code&gt;bitmap&lt;/code&gt; 为根结点, 也是放在 drawable 目录下, 通过 xml 创建可以对图片进行一些其他比如变形, 前景等更改&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-Xml"&gt;&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;bitmap
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:src="@[package:]drawable/drawable_resource"
    android:antialias=["true" | "false"]
    android:dither=["true" | "false"]
    android:filter=["true" | "false"]
    android:gravity=["top" | "bottom" | "left" | "right" | "center_vertical" |
                      "fill_vertical" | "center_horizontal" | "fill_horizontal" |
                      "center" | "fill" | "clip_vertical" | "clip_horizontal"]
    android:mipMap=["true" | "false"]
    android:tileMode=["disabled" | "clamp" | "repeat" | "mirror"] /&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;android:src&lt;/code&gt; 图片来源, 可以是其他 drawable&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:antialias&lt;/code&gt; 是否开启抗锯齿, 一般都开启以便获得更好的显示效果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:dither&lt;/code&gt; 是否开启抖动, 当屏幕与图片的像素配置不同时会用到, 比如屏幕是 RGB565, 图片是 ARGB8888. 一般都不开启&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:filter&lt;/code&gt; 是否开启过滤以便在图片缩小或放大时获得更平滑的过滤效果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:gravity&lt;/code&gt; 图片对齐方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:mipMap&lt;/code&gt; 设置是否可以使用 mipmap，但 API Level 最低要求是 17，即 Android 4.2&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:tileMode&lt;/code&gt; 平铺模式. &lt;code&gt;disabled&lt;/code&gt; 禁用, &lt;code&gt;clamp&lt;/code&gt; 平铺, &lt;code&gt;repeat&lt;/code&gt; 重复, &lt;code&gt;mirror&lt;/code&gt; 镜像, 以对称翻转铺满.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:autoMirrored&lt;/code&gt; 设置图片是否需要镜像反转，当布局方向是 RTL，即从右到左布局时才有用，API Level 19(Android 4.4) 才添加的属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:tintMode&lt;/code&gt; 着色模式，也是 API Level 21(Android 5.0) 才添加的属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:tileModeX&lt;/code&gt;, &lt;code&gt;android:tileModeY&lt;/code&gt; 水平, 垂直平铺.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3. 点九图片(nine-path 标签)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;nine-patch&lt;/code&gt; 图片一般都用工具生成, 其 &lt;strong&gt;左&lt;/strong&gt; 和 &lt;strong&gt;上&lt;/strong&gt; 边线规定了纵向和橫向拉伸时使用的平铺区域, &lt;strong&gt;右&lt;/strong&gt; 和 &lt;strong&gt;下&lt;/strong&gt; 边线规定了内容区.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;nine-patch
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:src="@[package:]drawable/drawable_resource"
    android:dither=["true" | "false"] /&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;android:src&lt;/code&gt; 必须是 nine-path 图片&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外还有 &lt;code&gt;android:dither&lt;/code&gt;, &lt;code&gt;android:tint&lt;/code&gt;, &lt;code&gt;android:tintMode&lt;/code&gt;, &lt;code&gt;android:alpha&lt;/code&gt; 图片透明度, 0.0-1.0 之间, &lt;code&gt;android:autoMirrored&lt;/code&gt; 属性&lt;/p&gt;
&lt;h3&gt;4. LayerDrawable (layer-list 标签)&lt;/h3&gt;
&lt;p&gt;layer-list 会把一组设置好的 drawable 按顺序从堆叠起来. 跟 level-list 区别的, layer-list 是一个组全, level-list 是按需选取其中的对应等级的图片.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;?&amp;lt;?xml versionxml ver ="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;layer-list
    xmlns:android="http://schemas.android.com/apk/res/android" &amp;gt;
    &amp;lt;item
        android:drawable="@[package:]drawable/drawable_resource"
        android:id="@[+][package:]id/resource_name"
        android:top="dimension"
        android:right="dimension"
        android:bottom="dimension"
        android:left="dimension" /&amp;gt;
&amp;lt;/layer-list&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;android:top&lt;/code&gt;, &lt;code&gt;android:right&lt;/code&gt;, &lt;code&gt;android:bottom&lt;/code&gt;, &lt;code&gt;android:left&lt;/code&gt; 是上右下左的偏移量, 注意这个偏移不会超出 view 的大小. 比如当设定这个为背景时, 背景大小 = view大小 - 左偏移量大小.&lt;/p&gt;
&lt;p&gt;所以一般为保证偏移后, 内容区还是显示为居中, 四个方向都作偏移, 然后在显示的另一层里不需要显示出来的作偏移&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;TextView
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="16dp"
    android:background="@drawable/bg_shadow_corners_rectangle"
    android:gravity="center"
    android:padding="16dp"
    android:text=" 带阴影的圆角矩形 " /&amp;gt;

&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&amp;gt;
    &amp;lt;!-- 灰色阴影 --&amp;gt;
    &amp;lt;item
        android:left="2dp"
        android:top="4dp"&amp;gt;
        &amp;lt;shape&amp;gt;
            &amp;lt;solid android:color="@android:color/darker_gray" /&amp;gt;
            &amp;lt;corners android:radius="10dp" /&amp;gt;
        &amp;lt;/shape&amp;gt;
    &amp;lt;/item&amp;gt;
    &amp;lt;!-- 白色前景, 左右, 上下偏移保持对称 --&amp;gt;
    &amp;lt;item
        android:left="2dp"
        android:top="4dp"
        android:bottom="4dp"
        android:right="2dp"&amp;gt;
        &amp;lt;shape&amp;gt;
            &amp;lt;solid android:color="#FFFFFF" /&amp;gt;
            &amp;lt;corners android:radius="10dp" /&amp;gt;
        &amp;lt;/shape&amp;gt;
    &amp;lt;/item&amp;gt;
&amp;lt;/layer-list&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt="layer-list textview示例" src="../../assets/images/layer-list-textview示例.png" /&gt;&lt;/p&gt;
&lt;h3&gt;5. StateListDrawable(selector 标签)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;StateListDrawable&lt;/code&gt; 表示多个状态联合起来的一个 drawable, 比如点击, focus 等. 状态匹配会按从上到下来匹配, 没匹配到的话就使用最后一个, 匹配到了就结束. 所以一般要把默认状态放在最后, 比如非点击状态在最后, 点击放在前面, 不然无法匹配到点击状态, 因为第一个总是匹配成功.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;selector xmlns:android="http://schemas.android.com/apk/res/android"
    android:constantSize=["true" | "false"]
    android:dither=["true" | "false"]
    android:variablePadding=["true" | "false"] &amp;gt;
    &amp;lt;item
        android:drawable="@[package:]drawable/drawable_resource"
        android:state_pressed=["true" | "false"]
        android:state_focused=["true" | "false"]
        android:state_hovered=["true" | "false"]
        android:state_selected=["true" | "false"]
        android:state_checkable=["true" | "false"]
        android:state_checked=["true" | "false"]
        android:state_enabled=["true" | "false"]
        android:state_activated=["true" | "false"]
        android:state_window_focused=["true" | "false"] /&amp;gt;
&amp;lt;/selector&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;android:state_XXXX&lt;/code&gt; 是 item 可设置的状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;android:state_pressed&lt;/code&gt; 按压&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:state_focused&lt;/code&gt; 是否选中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:state_hovered&lt;/code&gt; 鼠标在上面滑动&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:state_selected&lt;/code&gt; 选中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:state_checkable&lt;/code&gt; 设置一个勾选是否可以使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:state_checked&lt;/code&gt; 是否勾选, 用于 CheckBox 和 RadioButton 中是否勾选&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:state_enabled&lt;/code&gt; 设置触摸或点击是否可用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:state_activated&lt;/code&gt; 设置是否被激活状态, &lt;code&gt;setActivated()&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:state_window_focused&lt;/code&gt; 设置当前窗口是否获得焦点状态. 例如拉下通知栏或弹出对话框时，当前界面就会失去焦点；另外，ListView 的 ListItem 获得焦点时也会触发 true 状态，可以理解为当前窗口就是 ListItem 本身&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;6. LevelListDrawable(level-list 标签)&lt;/h3&gt;
&lt;p&gt;当 View 需要显示不同的图片, 比如电池电量图标, level-list 便可以派上用场. level-list 可以管理一组 drawable, 每个 drawable 都可以设置一组 level 范围, 最终会根据 level 值选取对应的 drawable 绘制出来.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;level-list
    xmlns:android="http://schemas.android.com/apk/res/android" &amp;gt;
    &amp;lt;item
        android:drawable="@drawable/drawable_resource"
        android:maxLevel="integer"
        android:minLevel="integer" /&amp;gt;
&amp;lt;/level-list&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;android:maxLevel&lt;/code&gt; 最大 level&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:minLevel&lt;/code&gt; 最小 level&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;level-list xmlns:android="http://schemas.android.com/apk/res/android"&amp;gt;
    &amp;lt;item
        android:drawable="@drawable/battery_low"
        android:maxLevel="10"
        android:minLevel="0" /&amp;gt;
    &amp;lt;item
        android:drawable="@drawable/battery_below_half"
        android:maxLevel="50"
        android:minLevel="10" /&amp;gt;
    &amp;lt;item
        android:drawable="@drawable/battery_over_half"
        android:maxLevel="99"
        android:minLevel="50" /&amp;gt;
    &amp;lt;item
        android:drawable="@drawable/battery_full"
        android:maxLevel="100"
        android:minLevel="100" /&amp;gt;
&amp;lt;/level-list&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;Drawable#setLevel(10)&lt;/code&gt; 的代码便可以设置 level 为 10. &lt;/p&gt;
&lt;p&gt;level-list 的匹配也是从上至下, 一但有匹配便不会再向下查找. 所以上面的示例也可以把 &lt;code&gt;android:minLevel&lt;/code&gt; 省略不写, 比如第一个 item&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;item
      android:drawable="@drawable/battery_low"
      android:maxLevel="10"/&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样 level 10 便直接命中第一个 item 后便不会再向下查找. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;level-list 的书写顺序需要注意, 如果把 level 100 写在前面, 并省略了 minLevel, 这样总是会匹配到 level 100 而不会向下查找&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;7. TransitionDrawable(transition 标签)&lt;/h3&gt;
&lt;p&gt;transition 继承于 layer-list, 但只能管理两层 drawable. 用于定义这两个 drawable 之间的切换方法, 还可以定义切换时淡入淡出的的动画效果.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;transition
    xmlns:android="http://schemas.android.com/apk/res/android" &amp;gt;
    &amp;lt;item
        android:drawable="@[package:]drawable/drawable_resource"
        android:id="@[+][package:]id/resource_name"
        android:top="dimension"
        android:right="dimension"
        android:bottom="dimension"
        android:left="dimension" /&amp;gt;
&amp;lt;/transition&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;transition 切换时要主动调动 &lt;code&gt;TransitionDrawable#startTransition()&lt;/code&gt; 方法, 从第一个转到第二个 drawable, 调动 &lt;code&gt;TransitionDrawable#reverseTransition()&lt;/code&gt; 从第二个转回第一个 drawable&lt;/p&gt;
&lt;h3&gt;8. InsetDrawable(inset 标签)&lt;/h3&gt;
&lt;p&gt;inset 标签类似于对 drawable 设置 padding, 但 padding 只设置内容区与边框的距离, 而 inset 不仅设置距离还可以设置自己的背景 drawable.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;inset
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:drawable="@drawable/drawable_resource"
    android:insetTop="dimension"
    android:insetRight="dimension"
    android:insetBottom="dimension"
    android:insetLeft="dimension" /&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;android:drawable&lt;/code&gt; 背景图片是必须的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;9. ClipDrawable(clip 标签)&lt;/h3&gt;
&lt;p&gt;clip 标签可以对 drawable 进行裁剪, 比如在做进度条时, 对进度条进行一定的裁剪, level 的取值范围为 0~10000, 默认为 0, 表示完全裁剪. 10000 表示不裁剪.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;clip
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:drawable="@drawable/drawable_resource"
    android:clipOrientation=["horizontal" | "vertical"]
    android:gravity=["top" | "bottom" | "left" | "right" | "center_vertical" |
                     "fill_vertical" | "center_horizontal" | "fill_horizontal" |
                     "center" | "fill" | "clip_vertical" | "clip_horizontal"] /&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;android:clipOrientation&lt;/code&gt; 表示裁剪方向, 可定义水平 &lt;code&gt;horizontal&lt;/code&gt; 裁剪和垂直 &lt;code&gt;vertical&lt;/code&gt; 裁剪. 水平裁剪指的是从图片的水平位置, 即左右两开始向中心位置开始裁剪. 垂直即是从上下位置开始&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:gravity&lt;/code&gt; 表示以这个位置为中心, 从该中心的左右, 上下开始裁剪&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;clip 标签的 level 设置需要使用 &lt;code&gt;Drawable#setLevel()&lt;/code&gt; 来设置, 比如 &lt;code&gt;ImageView.getDrawable.setLevel(5000)&lt;/code&gt;, level 的数值代表了裁剪百分比 &lt;code&gt;level / 10000&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面是两个不同裁剪中心的设置, 都裁剪  50%. Java 代码都为 &lt;code&gt;ImageView.getDrawable().setLevel(5000)&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;!-- 垂直和水平为中心 --&amp;gt;
&amp;lt;clip xmlns:android="http://schemas.android.com/apk/res/android"
    android:drawable="@drawable/poly_test2"
    android:gravity="center"
    android:clipOrientation="horizontal"&amp;gt;
&amp;lt;/clip&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt="clip_gravity_center" src="../../assets/images/clip_gravity_center.png" /&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;clip xmlns:android="http://schemas.android.com/apk/res/android"
    android:drawable="@drawable/poly_test2"
    android:gravity="left"
    android:clipOrientation="horizontal"&amp;gt;
&amp;lt;/clip&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt="clip_gravity_left" src="../../assets/images/clip_gravity_left.png" /&gt;&lt;/p&gt;
&lt;h3&gt;10. ScaleDrawable(scale 标签)&lt;/h3&gt;
&lt;p&gt;scale 标签也是通过设置 level 值来设置缩放, 也是 0~10000&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;scale
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:drawable="@drawable/drawable_resource"
    android:scaleGravity=["top" | "bottom" | "left" | "right" | "center_vertical" |
                          "fill_vertical" | "center_horizontal" | "fill_horizontal" |
                          "center" | "fill" | "clip_vertical" | "clip_horizontal"]
    android:scaleHeight="percentage"
    android:scaleWidth="percentage" /&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;android:scaleGravity&lt;/code&gt; 指的是以哪里为中心进行缩放&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:scaleHeight&lt;/code&gt;, &lt;code&gt;android:scaleWidth&lt;/code&gt; 值都为&lt;strong&gt;百分比&lt;/strong&gt;, 分别为高度和宽度从边框处可以缩放的百分比,  也就是图片会被按 &lt;strong&gt;(1 - 百分比)&lt;/strong&gt; 缩小. 比如如果在 xml 中设置最多能缩进 50%, &lt;code&gt;android:scaleWidth="50%"&lt;/code&gt;, 在 java 代码中设置 level 为 &lt;code&gt;Drawable.setLevel(3000)&lt;/code&gt; 缩小为 30% 大小, 也是会被  xml 的设定给限制最小能缩小到 50%&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;11. ShapeDrawable(shape 标签)&lt;/h3&gt;
&lt;p&gt;shape 标签定义了一些几何形状, 动画过渡等&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;shape
       xmlns:android="http://schemas.android.com/apk/res/android"
       android:shape=["rectangle" | "oval" | "line" | "ring"] &amp;gt;

    &amp;lt;corners
        android:radius="integer"
        android:topLeftRadius="integer"
        android:topRightRadius="integer"
        android:bottomLeftRadius="integer"
        android:bottomRightRadius="integer" /&amp;gt;

    &amp;lt;gradient
        android:angle="integer"
        android:centerX="float"
        android:centerY="float"
        andorid:centerColor="integer"
        android:endColor="color"
        android:gradientRadius="integer"
        android:startColor="color"
        android:type=["linear" | "radial" | "sweep"]
        android:useLevel=["true" | "false"] /&amp;gt;

    &amp;lt;padding
        android:left="integer"
        android:top="integer"
        android:right="integer"
        android:bottom="integer" /&amp;gt;

    &amp;lt;size
        android:width="integer"
        android:height="integer" /&amp;gt;

    &amp;lt;solid
        android:color="color" /&amp;gt;

    &amp;lt;stroke
        android:width="integer"
        android:color="color"
        android:dashWidth="integer"
        android:dashGap="integer" /&amp;gt;

&amp;lt;/shape&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;android:shape&lt;/code&gt; 可以设置 &lt;code&gt;rectangle&lt;/code&gt; 矩形(默认), &lt;code&gt;oval&lt;/code&gt; 椭圆, &lt;code&gt;line&lt;/code&gt; 线形, &lt;code&gt;ring&lt;/code&gt; 环形&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;corners&lt;/code&gt; 标签用于设置圆角&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;android:radius&lt;/code&gt; 同时设置四个角, 会被下面的值覆盖&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:topLeftRadius&lt;/code&gt; 左上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:topRightRadius&lt;/code&gt; 右上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:bottomLeftRadius&lt;/code&gt; 右下&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:bottomRightRadius&lt;/code&gt; 左下&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;只适应用于 rectangle 形状&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;gradient&lt;/code&gt; 标签用于设置渐变. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;android:angle&lt;/code&gt; 渐变角度, 线性渐变时才有用, 必须为 45 度的倍数. 注意 Android 坐标跟数学坐标不同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:centerX&lt;/code&gt; 放射渐变时中心点的横坐标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:centerY&lt;/code&gt; 放射渐变时中心点的纵坐标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:startColor&lt;/code&gt; 渐变的初始颜色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;andorid:centerColor&lt;/code&gt; 渐变的中间颜色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:endColor&lt;/code&gt; 渐变的结束颜色 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:gradientRadius&lt;/code&gt; 放射渐变的渐变半径 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:type&lt;/code&gt; 渐变方式. &lt;code&gt;linear&lt;/code&gt; 线性渐变, &lt;code&gt;radial&lt;/code&gt; 放射渐变(中心渐变), &lt;code&gt;sweep&lt;/code&gt; 扫描渐变, 从钟表 3 点钟方向沿顺时针扫一圈的渐变方式.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;android:useLeve&lt;/code&gt; 是否使用 level 值, 一般不使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;padding&lt;/code&gt; 标签用于设定内容与边界的几个内间距&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;size&lt;/code&gt; 用与设置图形形状的大小, 矩形的宽高, 椭圆的长宽. 在 &lt;code&gt;ring&lt;/code&gt; 中使用时指的是图形的大小, 而不是外边距的大小&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;线形不使用这个值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;solid&lt;/code&gt; 用于设置填充到图形中的颜色&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;line&lt;/code&gt; 不使用这个设置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stroke&lt;/code&gt; 用于设置边线的值. 当形状为&lt;code&gt;line&lt;/code&gt; 时, 指的是线的设置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;android:color&lt;/code&gt; 填充的颜色&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:width&lt;/code&gt; 线的宽度, 或者说是粗细&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:dashGap&lt;/code&gt; 设置虚线和虚线的间隔距离, 也即是中间实线的长度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:dashWidth&lt;/code&gt; 设置虚线的长度&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;针对形状为 &lt;code&gt;ring&lt;/code&gt; 时, 还有 5 个特殊的属性, 写在 shape 标签中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;android:innerRadius&lt;/code&gt; 内圆半径, 覆盖 &lt;code&gt;android:innerRadiusRatio&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:innerRadiusRatio&lt;/code&gt; 以环的宽度比率来表示内环的半径，默认为 3，表示内环半径为环的宽度除以 3，该值会被 android:innerRadius 覆盖&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:thickness&lt;/code&gt; 圆环的厚度, 即外径 - 内径的大小, 覆盖 &lt;code&gt;android:thicknessRatio&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:thicknessRatio&lt;/code&gt; 内径占整个 drawable 的比例, 默认为 9, 如果为 n, 则半径 = 宽度 / n&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:useLevel&lt;/code&gt; &lt;strong&gt;默认为 true. 只有作为 LevelListDrawable 来使用时才设置为 true , 否则设置为 false, 不然可能导致图形无法显示&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;12. RotateDrawable(rotate 标签)&lt;/h3&gt;
&lt;p&gt;设置旋转, 旋转值也是由 &lt;code&gt;Drawable#setLevel()&lt;/code&gt; 来控制. 可旋转的角度在 &lt;code&gt;fromDegress&lt;/code&gt; - &lt;code&gt;toDegress&lt;/code&gt; 之间, 即旋转 (level / 10000) * ( fromDegress - toDegress) 度&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;
&amp;lt;rotate
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:drawable="@drawable/drawable_resource"
    android:fromDegress="float"
    android:toDegress="float"
    android:privotX="float"
    android:privotY="float"
    android:visible=["true" | "false"] /&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;android:drawable&lt;/code&gt; 图片来源, 也可以把图形包含在 rotate 标签之间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:fromDegress&lt;/code&gt; 开始角度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:toDegress&lt;/code&gt; 结束角度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:privotX&lt;/code&gt; 旋转中心横坐标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:privotY&lt;/code&gt; 旋转中心纵坐标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;android:visible&lt;/code&gt; 是否可见&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Reference&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/resources/drawable-resource"&gt;https://developer.android.com/guide/topics/resources/drawable-resource&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://keeganlee.me/post/android/20150916"&gt;https://keeganlee.me/post/android/20150916&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://keeganlee.me/post/android/20150909"&gt;https://keeganlee.me/post/android/20150909&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://keeganlee.me/post/android/20150830"&gt;https://keeganlee.me/post/android/20150830&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="drawable"></category><category term="资源"></category><category term="样式"></category></entry><entry><title>Android View 的坐标系</title><link href="https://ivicel.info/2018/04/android-view-de-zuo-biao-xi.html" rel="alternate"></link><published>2018-04-28T00:00:00+08:00</published><updated>2018-04-28T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-04-28:/2018/04/android-view-de-zuo-biao-xi.html</id><summary type="html">&lt;p&gt;屏幕的坐标原点为屏幕的左上角, 往右为&lt;strong&gt;正向x轴&lt;/strong&gt;, 往下为&lt;strong&gt;正向y轴&lt;/strong&gt;. 坐标参数顺序一般为&lt;code&gt;左&lt;/code&gt;, &lt;code&gt;上&lt;/code&gt;, &lt;code&gt;右&lt;/code&gt;, &lt;code&gt;下&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;子&lt;code&gt;view&lt;/code&gt;可以获取其相对于父&lt;code&gt;ViewGroup&lt;/code&gt;的坐标.  这个要跟点击事件&lt;code&gt;MotionEvent&lt;/code&gt;的坐标获取方法区别开来&lt;/p&gt;
&lt;p&gt;&lt;code&gt;view&lt;/code&gt;由于是一个框模型, 所以当确定左上点和右下点的位置, 我们便可以确定一个&lt;code&gt;view&lt;/code&gt;的大小和位置.
左上点坐标为 &lt;strong&gt;(&lt;code&gt;View.getLeft()&lt;/code&gt;, &lt;code&gt;View.getTop()&lt;/code&gt;)&lt;/strong&gt;, 右下点坐标 &lt;strong&gt;(&lt;code&gt;View.getRight()&lt;/code&gt;, &lt;code&gt;View.getBottom()&lt;/code&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;view&lt;/code&gt; 的大小: &lt;/p&gt;
&lt;p&gt;宽度 &lt;code&gt;width = getRight() - getLeft()&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;高度 &lt;code&gt;height = getBottom() - getTop()&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这也是 &lt;code&gt;getWidth()&lt;/code&gt;, &lt;code&gt;getHeight()&lt;/code&gt; 的算法. 其和 &lt;code&gt;getMeasuredWidth …&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;屏幕的坐标原点为屏幕的左上角, 往右为&lt;strong&gt;正向x轴&lt;/strong&gt;, 往下为&lt;strong&gt;正向y轴&lt;/strong&gt;. 坐标参数顺序一般为&lt;code&gt;左&lt;/code&gt;, &lt;code&gt;上&lt;/code&gt;, &lt;code&gt;右&lt;/code&gt;, &lt;code&gt;下&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;子&lt;code&gt;view&lt;/code&gt;可以获取其相对于父&lt;code&gt;ViewGroup&lt;/code&gt;的坐标.  这个要跟点击事件&lt;code&gt;MotionEvent&lt;/code&gt;的坐标获取方法区别开来&lt;/p&gt;
&lt;p&gt;&lt;code&gt;view&lt;/code&gt;由于是一个框模型, 所以当确定左上点和右下点的位置, 我们便可以确定一个&lt;code&gt;view&lt;/code&gt;的大小和位置.
左上点坐标为 &lt;strong&gt;(&lt;code&gt;View.getLeft()&lt;/code&gt;, &lt;code&gt;View.getTop()&lt;/code&gt;)&lt;/strong&gt;, 右下点坐标 &lt;strong&gt;(&lt;code&gt;View.getRight()&lt;/code&gt;, &lt;code&gt;View.getBottom()&lt;/code&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;view&lt;/code&gt; 的大小: &lt;/p&gt;
&lt;p&gt;宽度 &lt;code&gt;width = getRight() - getLeft()&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;高度 &lt;code&gt;height = getBottom() - getTop()&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这也是 &lt;code&gt;getWidth()&lt;/code&gt;, &lt;code&gt;getHeight()&lt;/code&gt; 的算法. 其和 &lt;code&gt;getMeasuredWidth()&lt;/code&gt;, &lt;code&gt;getMeasuredHeight()&lt;/code&gt; 的差别主要在于后者一般是用于测量时获得的宽高, 并带有模式, 是 view 的原始大小. 一般情况下这两者对应的值是一样的, 不过 &lt;code&gt;getWidth()&lt;/code&gt;, &lt;code&gt;getHeight()&lt;/code&gt; 是在布局后(&lt;code&gt;onLayout&lt;/code&gt;)才能获得, 有时可能某些 ViewGroup 在布局时更改了 view 的大小, 从而导致这两者的值不一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;getLeft()&lt;/code&gt;, &lt;code&gt;getTop()&lt;/code&gt;, &lt;code&gt;getRight()&lt;/code&gt;, &lt;code&gt;getBottom()&lt;/code&gt; 这4个方法获得是&lt;code&gt;view&lt;/code&gt;布局时的原始坐标, 其值在测量布局后不会再改变. 而一个&lt;code&gt;view&lt;/code&gt;真正在屏幕显示的位置是其偏移量&lt;code&gt;translate&lt;/code&gt;和&lt;strong&gt;原始位置&lt;/strong&gt;共同决定的. 这其中我们只要确定左上点的位置便可. 其实际左上点位置关系为:&lt;/p&gt;
&lt;p&gt;左上点横坐标: &lt;code&gt;float View.getX() = int View.getLeft() + float View.getTranslationX()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;左上点纵坐标: &lt;code&gt;float View.getY() = int View.getTop() + float View.getTranslationY()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在引入了&lt;code&gt;Z轴&lt;/code&gt;之后(&lt;strong&gt;API 21&lt;/strong&gt;), &lt;code&gt;Z轴&lt;/code&gt;关系为: &lt;code&gt;float View.getZ() = int View.getElevation() + float View.getTranslationZ()&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;特别需要注意的是, 在 &lt;code&gt;activity&lt;/code&gt; 中调用这些方法时, 得到的值是0, 因为此时 &lt;code&gt;view&lt;/code&gt; 还未布局, 需要等要&lt;code&gt;view.onMeasure&lt;/code&gt; 之后才会进行赋值. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有4种方法来获取这些值.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 &lt;code&gt;ViewTreeObserver&lt;/code&gt;监听&lt;code&gt;view&lt;/code&gt;的 Draw/Layout 事件&lt;/li&gt;
&lt;li&gt;将一个runnable添加到Layout队列中, 使用 &lt;code&gt;View.post&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重写&lt;code&gt;view.onLayout&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;重写&lt;code&gt;Activity.onWindowFocusChange&lt;/code&gt;方法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="view坐标" src="../../assets/images/view坐标.png" /&gt;&lt;/p&gt;</content><category term="view"></category><category term="坐标"></category></entry><entry><title>CircleImageView实现解析</title><link href="https://ivicel.info/2018/04/circleimageviewshi-xian-jie-xi.html" rel="alternate"></link><published>2018-04-28T00:00:00+08:00</published><updated>2018-04-28T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-04-28:/2018/04/circleimageviewshi-xian-jie-xi.html</id><summary type="html">&lt;h3&gt;1. CircleImageView 的实现&lt;/h3&gt;
&lt;h4&gt;1.1 自定义的属性&lt;/h4&gt;
&lt;p&gt;CircleImageView 一共自定义的 5 个自定义属性&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;civ_border_width&lt;/code&gt; 边框的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;civ_border_color&lt;/code&gt; 边框的颜色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;civ_border_overlay&lt;/code&gt; 边框覆盖&lt;/li&gt;
&lt;li&gt;&lt;code&gt;civ_fill_color&lt;/code&gt; 图片背景填充, 已弃用, 使用 &lt;code&gt;civ_circle_background_color&lt;/code&gt; 替代&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;1.2 流程&lt;/h4&gt;
&lt;p&gt;CircleImageView 是继承自系统控件 &lt;code&gt;android.widget.ImageView&lt;/code&gt;, 而不是 support 里的兼容控件 &lt;code&gt;android.support.v7.widget.AppCompatImageView&lt;/code&gt;, 作者的理由是为了使用控件更加简洁, 这样不必在包内依赖 android support v7 包, 减小包的大小. 如果有版本兼容问题的话, 我们可以自己按需求改成继承自 v7 包.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CircleImageView …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;h3&gt;1. CircleImageView 的实现&lt;/h3&gt;
&lt;h4&gt;1.1 自定义的属性&lt;/h4&gt;
&lt;p&gt;CircleImageView 一共自定义的 5 个自定义属性&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;civ_border_width&lt;/code&gt; 边框的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;civ_border_color&lt;/code&gt; 边框的颜色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;civ_border_overlay&lt;/code&gt; 边框覆盖&lt;/li&gt;
&lt;li&gt;&lt;code&gt;civ_fill_color&lt;/code&gt; 图片背景填充, 已弃用, 使用 &lt;code&gt;civ_circle_background_color&lt;/code&gt; 替代&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;1.2 流程&lt;/h4&gt;
&lt;p&gt;CircleImageView 是继承自系统控件 &lt;code&gt;android.widget.ImageView&lt;/code&gt;, 而不是 support 里的兼容控件 &lt;code&gt;android.support.v7.widget.AppCompatImageView&lt;/code&gt;, 作者的理由是为了使用控件更加简洁, 这样不必在包内依赖 android support v7 包, 减小包的大小. 如果有版本兼容问题的话, 我们可以自己按需求改成继承自 v7 包.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CircleImageView 里有两个重要的标志位 &lt;code&gt;mReady&lt;/code&gt;, &lt;code&gt;mSetupPending&lt;/code&gt;. 用来控制解析自定义属性, 和图片来源以及 view 大小的测量. 为什么要使用两个标志位并相互依赖? 这是由于 ImageView 可能通过 xml 和 java 两种方法来设置图片来源, 这两种方法调用的时机也是不同. 另外我们需要确保先要解析我们自定义的值才好计算出边框大小, 颜色等, 还有 view 的大小要到 onMeasure 时才能确定, 所以圆半径大小的要到那时才能确定&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们都知道, xml 的 inflate 使用的是控件里的第二个构造方法, 即 &lt;code&gt;public CircleImageView(Context context, AttributeSet attrs)&lt;/code&gt;, 然后这里调用了 &lt;code&gt;public CircleImageView(Context context, AttributeSet attrs, int defStyle)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;在第三个构造调用了父类 &lt;code&gt;ImageView&lt;/code&gt; 里对应的构造方法, 这里要注意的是, 父类里会解析我们所写的 xml 文件, 然后如果我们写了图片文件来源 &lt;code&gt;android:src&lt;/code&gt;, 这里就会调用了 &lt;code&gt;ImageView#setDrawable&lt;/code&gt; 来设置图片文件来源.&lt;/p&gt;
&lt;p&gt;然后我们看到 CircleImageView 源码里面设置图片的 setXXX 方法都已经被重写了, 都只增加了一行 &lt;code&gt;initializeBitmap()&lt;/code&gt; 来初始化图片 mBitmap 来源.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;private void initializeBitmap() {
    // 通过这个标志可以设定我们是否需要把图片变形为圆形或者不改变
    // 如果设定了 onDraw 那就按 ImageView 来绘画
    if (mDisableCircularTransformation) {
        mBitmap = null;
    } else {
        // 获取图片
        mBitmap = getBitmapFromDrawable(getDrawable());
    }
    setup();
}

private void setup() {
    // 第一次 mReady 初始为 false, 所以总是直接返回, 回到构造方法里解析自定义属性
    if (!mReady) {
        mSetupPending = true;
        return;
    }
    // 这一步判断也是很重要的, 因为图片的设置可能是在 xml 也可能是在 java 中 setXXX 方法
    // 所以当完成调用构造方法后, 再次调用 setup 时并没有测量好 view 的大小, 这里就会直接返回
    if (getWidth() == 0 &amp;amp;&amp;amp; getHeight() == 0) {
        return;
    }

    /* .... */
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来看两种情况:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过 xml 设置图片来源. &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;setImageDrawable()&lt;/code&gt; -&amp;gt; &lt;code&gt;initializeBitmap()&lt;/code&gt; -&amp;gt; &lt;code&gt;setup()&lt;/code&gt;, 遇到 &lt;code&gt;mReady == false&lt;/code&gt; 返回 -&amp;gt; 构造方法里解析自定义属性, 然后 &lt;code&gt;init()&lt;/code&gt; -&amp;gt; 这时 &lt;code&gt;mSetupPending == true&lt;/code&gt;, 再次调用 &lt;code&gt;setup()&lt;/code&gt;, 但此时 view 的大小还没测量好, &lt;code&gt;getWidth() == 0&lt;/code&gt;, &lt;code&gt;getHeight() == 0&lt;/code&gt; 直接返回. &lt;/p&gt;
&lt;p&gt;当 view 测量完成后调用 &lt;code&gt;onSizeChanged()&lt;/code&gt; -&amp;gt; 再次 &lt;code&gt;setup&lt;/code&gt;, 这时一切就绪可以测量圆的半径大小, 位置等种种&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过 java 代码来设置图片来源.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;重写 &lt;code&gt;setImageXXXX()&lt;/code&gt; 方法, 里面都调用了 &lt;code&gt;initializeBitmap()&lt;/code&gt;. 然后跟上面的一样, 只不过这时候 &lt;code&gt;mReady&lt;/code&gt; 已经是 &lt;code&gt;true&lt;/code&gt;, 因为在 &lt;code&gt;init()&lt;/code&gt; 里已经设置了, 并且此时我们已经完成了对 view 的测量, 这样在 &lt;code&gt;setup()&lt;/code&gt; 里就直接测量圆的半径等等所需的值&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;private void init() {
    super.setScaleType(SCALE_TYPE);
    mReady = true;

    if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.LOLLIPOP) {
        setOutlineProvider(new OutlineProvider());
    }
    // 如果已经在 xml 设置了图片, 就会直接设置图片的大小等
    if (mSetupPending) {
        setup();
        mSetupPending = false;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来看如何获得 bitmap.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;private Bitmap getBitmapFromDrawable(Drawable drawable) {
    if (drawable == null) {
        return null;
    }
    // 如果是 BitmapDrawable 对象, 直接使用 BitmapDrawable#getBitmap() 获得
    if (drawable instanceof BitmapDrawable) {
        return ((BitmapDrawable) drawable).getBitmap();
    }

    try {
        Bitmap bitmap;
        // 如果是 ColorDrawable 对象, 因为填充颜色没有所谓的大小, 是根据要填充的 view 来确定大小的. 
        // 所以给一个初始的大小来生成 bitmap, 到时把这个 bitmap 拉伸便可
        if (drawable instanceof ColorDrawable) {
            bitmap = Bitmap.createBitmap(COLORDRAWABLE_DIMENSION, COLORDRAWABLE_DIMENSION, BITMAP_CONFIG);
        } else {
            // 其余情况下由传入的 drawable 大小来确定生成新的 bitmap
            bitmap = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), BITMAP_CONFIG);
        }
        Canvas canvas = new Canvas(bitmap);
        drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());
        drawable.draw(canvas);
        return bitmap;
    } catch (Exception e) {
        e.printStackTrace();
        return null;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;回过来看最重要的 setup 方法&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;private void setup() {
    if (!mReady) {
        mSetupPending = true;
        return;
    }

    if (getWidth() == 0 &amp;amp;&amp;amp; getHeight() == 0) {
        return;
    }
    // 设置为不要变形为圆形时的情况, 会执行这个
    if (mBitmap == null) {
        invalidate();
        return;
    }
    // 设置着色器
    mBitmapShader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP,
            Shader.TileMode.CLAMP);
    // 图片画笔, 反锯齿, 着色器
    mBitmapPaint.setAntiAlias(true);
    mBitmapPaint.setShader(mBitmapShader);
    // 边框画笔样式
    mBorderPaint.setStyle(Paint.Style.STROKE);
    mBorderPaint.setAntiAlias(true);
    mBorderPaint.setColor(mBorderColor);
    mBorderPaint.setStrokeWidth(mBorderWidth);
    // 背景画笔样式
    mCircleBackgroundPaint.setStyle(Paint.Style.FILL);
    mCircleBackgroundPaint.setAntiAlias(true);
    mCircleBackgroundPaint.setColor(mCircleBackgroundColor);
    // 图片宽高
    mBitmapHeight = mBitmap.getHeight();
    mBitmapWidth = mBitmap.getWidth();
    // 计算圆形的外切矩形大小
    mBorderRect.set(calculateBounds());
    // 计算边框的半径, 我们在 xml 中设置的是边框大小 * 2, 这里要除以 2
    // 因为在画圆时, Paint#setStrokeWidth 的参数就是圆边框线的两倍
    mBorderRadius = Math.min((mBorderRect.height() - mBorderWidth) / 2.0f,
            (mBorderRect.width() - mBorderWidth) / 2.0f);
    mDrawableRect.set(mBorderRect);
    // overlay 为 true 时, 向内缩小 1px
    if (!mBorderOverlay &amp;amp;&amp;amp; mBorderWidth &amp;gt; 0) {
        mDrawableRect.inset(mBorderWidth - 1.0f, mBorderWidth - 1.0f);
    }
    // 图形圆的半径大小, 可以看到取这个大小时, 边框是画在图像上的
    mDrawableRadius = Math.min(mDrawableRect.height() / 2.0f, mDrawableRect.width() / 2.0f);
    // 过滤颜色, 只在 java 代码中设置调用
    applyColorFilter();
    updateShaderMatrix();
    invalidate();
}

 private RectF calculateBounds() {
    // 注意先要减去上下左右的 padding 才是 view 真正的内容区大小
    int availableWidth  = getWidth() - getPaddingLeft() - getPaddingRight();
    int availableHeight = getHeight() - getPaddingTop() - getPaddingBottom();
    // 取长宽里的最小值来作一个内切圆, 该值就是边框圆的直径
    int sideLength = Math.min(availableWidth, availableHeight);
    // 以左, 上的 padding 为准来定位圆
    // 如果长, 高很大, 那么 paddingRight, paddingBottom 可能不会产生什么影响 
    float left = getPaddingLeft() + (availableWidth - sideLength) / 2f;
    float top = getPaddingTop() + (availableHeight - sideLength) / 2f;
    // 将在这个矩形内作一个内切圆
    return new RectF(left, top, left + sideLength, top + sideLength);
}

private void updateShaderMatrix() {
    float scale;
    float dx = 0;
    float dy = 0;
    mShaderMatrix.set(null);
    // 我们已经计算好一个矩形, 我们需要知道图片比预定矩形大还是小, 以便作缩放
    // 下面是 mDrawableRect.height() / mBitmapHeight &amp;gt; 
    // mDrawableRect.width() / mBitmapWidth 的变形
    // 因为图片有放大或缩小, 缩放中心为原点, 所以图片要进行移动
    if (mBitmapWidth * mDrawableRect.height() &amp;gt; 
            mDrawableRect.width() * mBitmapHeight) {
        // 按高进行缩放时, 要在 x 轴平移
        scale = mDrawableRect.height() / (float) mBitmapHeight;
        dx = (mDrawableRect.width() - mBitmapWidth * scale) * 0.5f;
    } else {
        // 按宽进行缩放时, 要在 y 轴平移
        scale = mDrawableRect.width() / (float) mBitmapWidth;
        dy = (mDrawableRect.height() - mBitmapHeight * scale) * 0.5f;
    }

    mShaderMatrix.setScale(scale, scale);
    mShaderMatrix.postTranslate((int) (dx + 0.5f) + mDrawableRect.left, (int) (dy + 0.5f) + mDrawableRect.top);

    mBitmapShader.setLocalMatrix(mShaderMatrix);
}

protected void onDraw(Canvas canvas) {
    // 禁用变形
    if (mDisableCircularTransformation) {
        super.onDraw(canvas);
        return;
    }
    // 没有获得图片源
    if (mBitmap == null) {
        return;
    }
    // 有背景颜色
    if (mCircleBackgroundColor != Color.TRANSPARENT) {
        canvas.drawCircle(mDrawableRect.centerX(), mDrawableRect.centerY(), mDrawableRadius, mCircleBackgroundPaint);
    }
    // 画图片
    canvas.drawCircle(mDrawableRect.centerX(), mDrawableRect.centerY(),
            mDrawableRadius, mBitmapPaint);
    // 画边框
    if (mBorderWidth &amp;gt; 0) {
        canvas.drawCircle(mBorderRect.centerX(), mBorderRect.centerY(), 
                mBorderRadius, mBorderPaint);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Reference&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0806/3268.html"&gt;http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0806/3268.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.im/entry/593108c4a22b9d0058c08a2c"&gt;https://juejin.im/entry/593108c4a22b9d0058c08a2c&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/hdodenhof/CircleImageView"&gt;https://github.com/hdodenhof/CircleImageView&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="CircleImageView"></category><category term="源码解析"></category><category term="实现"></category></entry><entry><title>啊哈算法1</title><link href="https://ivicel.info/2018/04/a-ha-suan-fa-1.html" rel="alternate"></link><published>2018-04-22T00:00:00+08:00</published><updated>2018-04-22T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-04-22:/2018/04/a-ha-suan-fa-1.html</id><summary type="html">&lt;h3&gt;1. 简单桶排序&lt;/h3&gt;
&lt;p&gt;对于要排序的数据, 其有范围在 n &amp;lt;= k &amp;lt;= m 之内, 则令有 m - n + 1 个桶, 然后对需要排序的 x 个数据, 依次遍历后, 装到对应的桶中, 最后再对桶进行遍历可得到排序后的数据.&lt;/p&gt;
&lt;p&gt;比如有 [8, 5, 2, 3, 1, 5, 10] 这 7 个数据, 其值在 1 - 100 之间, 则有桶的个数为 100 个.  对数据进行遍历, 每次把数据装到桶中, 8 则装到 第 8 个桶, 依次进行. 最后再遍历这 100 个桶个分别有几个数据可得出排序后的序列.&lt;/p&gt;
&lt;p&gt;对于 N …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;1. 简单桶排序&lt;/h3&gt;
&lt;p&gt;对于要排序的数据, 其有范围在 n &amp;lt;= k &amp;lt;= m 之内, 则令有 m - n + 1 个桶, 然后对需要排序的 x 个数据, 依次遍历后, 装到对应的桶中, 最后再对桶进行遍历可得到排序后的数据.&lt;/p&gt;
&lt;p&gt;比如有 [8, 5, 2, 3, 1, 5, 10] 这 7 个数据, 其值在 1 - 100 之间, 则有桶的个数为 100 个.  对数据进行遍历, 每次把数据装到桶中, 8 则装到 第 8 个桶, 依次进行. 最后再遍历这 100 个桶个分别有几个数据可得出排序后的序列.&lt;/p&gt;
&lt;p&gt;对于 N 个数据, 其对应的范围为 M, 则需要初始化遍历 M 次, 然后再对数据序列遍历 N 次来排序, 简单桶排序的时间复杂度为 &lt;code&gt;O(N+M)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于小型的数据范围, 简单桶排序是一个非常快的算法, 而一但当数据量非常大, 或者范围非常大, 但有效数据只是很小的值, 比如范围为 1-1 亿, 数据只是为 [8, 5, 2, 3, ….] 这几个数时, 一样还需要 1 亿个桶, 但其中只用到了某几个桶而已, 这就造成了巨大的空间浪费, 而且所需要的时间也呈直线上升.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;def randnumber():
    return [randint(0, 101) for n in range(20)]

def bucket_sort(data, max):
    print("Before:\t", data)
    sorted_data = [0] * (max + 1)
    for i in data:
        sorted_data[i] += 1
    data = [j for j in range(len(sorted_data)) for _ in range(sorted_data[j])]
    print("After:\t", data)&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Before:    [18, 97, 1, 59, 38, 70, 34, 32, 21, 80, 87, 33, 42, 49, 63, 99, 33, 5, 45, 39]&lt;/p&gt;
&lt;p&gt;After:     [1, 5, 18, 21, 32, 33, 33, 34, 38, 39, 42, 45, 49, 59, 63, 70, 80, 87, 97, 99]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;2. 冒泡排序&lt;/h3&gt;
&lt;p&gt;冒泡排序的基本思想是: 每次都比较相邻的两个元素, 如果它们的顺序是错误的, 就交换位置.&lt;/p&gt;
&lt;p&gt;比如对于  [8, 5, 2, 3, 1, 5, 10] , 要从小到大来排序的话, 从 8 开始比较, 8 &amp;gt; 5, 则交换变成 [5, 8, 2, 3, 1, 5, 10]. 再比较 8 &amp;gt; 2, 变成  [5, 2, 8, 3, 1, 5, 10], 一直比下去直到第一轮完成时 [5, 2, 3, 1, 5, 8, 10], 第一轮便确定了最大值在最右边. 第二轮再从 5 开始比较, 一直比较到 8, 便可确定第二大的数.&lt;/p&gt;
&lt;p&gt;所以对于冒泡排序, 当有 n 个数时, 一共要比较 (n - 1 + n - 2 + … + 1) 次, 即该算法的时间复杂度为 &lt;code&gt;O( n&amp;lt;sup&amp;gt;2&amp;lt;/sup&amp;gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;def bubble_sort(data):
    print("Befor:\t", data)
    for i in range(1, len(data)):
        for j in range(len(data) - i):
            if data[j] &amp;gt; data[j + 1]:
                data[j], data[j + 1] = data[j + 1], data[j]
    print("After:\t", data)&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Befor:     [55, 4, 88, 68, 77, 49, 13, 14, 20, 69, 46, 54, 88, 41, 82, 47, 92, 27, 37, 2]
After:     [2, 4, 13, 14, 20, 27, 37, 41, 46, 47, 49, 54, 55, 68, 69, 77, 82, 88, 88, 92]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;3. 快速排序&lt;/h3&gt;
&lt;p&gt;快速排序主要的思想是采用分而治之的思想, 每次选取一个数, 然后比较剩余的数值, 比选定的数小的放在左边, 大的放在右边. 这样一来, 左右两边的数都确定了比该数大或小, 然后再对左边和右边分别进行现样的操作, 直到左右两边都分到只有一个数的时, 这样排序便完成.&lt;/p&gt;
&lt;p&gt;快速排序的内存优化方法在于, 在选定数之后, 从左边开始循环, 如果找一个比选定的数大的停止下来; 右边也是同样的循环, 直到找到比选定数小的, 这样交换两边找到的数, 交换之后再继续循环下来, 循环终止的条件是左右两边都指向同一个位置里的数据, 或者如果选定的数的位置为中间, 则循环到该位置. 如果选定的数为其他地方, 在循环停止后, 把选定的数移到分好类的数据中间.&lt;/p&gt;
&lt;p&gt;快速排序时间复杂度, 最坏情况下为 &lt;code&gt;O(n&amp;lt;sup&amp;gt;2&amp;lt;/sup&amp;gt;)&lt;/code&gt;, 平均时间复杂度为 &lt;code&gt;O(nlog n)&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;def quick_sort(data, left, right):
    if left &amp;gt;= right:
        return
    pivot = data[left]
    l, r = left, right
    while l &amp;lt; r:
        while data[r] &amp;gt;= pivot and r &amp;gt; l:
            r -= 1
        data[l] = data[r]

        while data[l] &amp;lt;= pivot and l &amp;lt; r:
            l += 1
        data[r] = data[l]
    data[l] = pivot

    quick_sort(data, left, l - 1)
    quick_sort(data, l + 1, right)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为我们总是指定左边第一个为标杆数, 所以总是要先从右边开始查找, 这样才能保证在停止从左右两边查找时, 停止的位置总是小于(或大于, 当降序时)指定的数. 反之, 如果指定右边的数, 要先从左边先检查起.&lt;/p&gt;
&lt;p&gt;递归版本的快排, 在数据量大的时候可能会爆栈, 解决办法是使用循环来代替递归, 或者使用尾递归&lt;/p&gt;
&lt;p&gt;下面是一个用循环来实现的快排, 用栈来保存左右边界值&lt;/p&gt;
&lt;p&gt;快排的时间复杂度能选择的标杆值 pivot 有很大的关系, 最好是能随机选择三个数, 排序后选择中间值&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public int partition(int[] arr, int left, int right) {
    if (left &amp;gt;= right) {
        throw new ArrayIndexOutOfBoundsException();
    }

    int start = left;
    int pivot = arr[start];
    while (left &amp;lt; right) {
        while (right &amp;gt; left &amp;amp;&amp;amp; arr[right] &amp;lt; pivot) {
            right--;
        }

        while (left &amp;lt; right &amp;amp;&amp;amp; arr[left] &amp;gt; pivot) {
            left++;
        }

        if (left &amp;lt; right) {
            int tmp = arr[left];
            arr[left] = arr[right];
            arr[right] = tmp;
            // 因为设定的是当该数 == pivot 时也是需要交换, 所以为避免死循环, 需要手动移位
            right--;
            left++;
        }
    }
    return left;
}

public void qsort(int[] arr) {
    Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
    stack.push(0);
    stack.push(arr.length - 1);
    while (!stack.empty()) {
        int high = stack.pop();
        int low = stack.pop();
        int pos = partition(arr, low, high);
        if (pos &amp;gt; low) {
            // push left
            stack.push(low);
            stack.push(pos);
        }
        if (pos + 1 &amp;lt; high) {
            //push right
            stack.push(pos + 1);
            stack.push(high);
        }
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Reference:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.yebangyu.org/blog/2016/03/09/quicksort/"&gt;http://www.yebangyu.org/blog/2016/03/09/quicksort/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="算法"></category><category term="排序"></category></entry><entry><title>Android 代码 values 目录下说明</title><link href="https://ivicel.info/2018/04/android-dai-ma-values-mu-lu-xia-shuo-ming.html" rel="alternate"></link><published>2018-04-22T00:00:00+08:00</published><updated>2018-04-22T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-04-22:/2018/04/android-dai-ma-values-mu-lu-xia-shuo-ming.html</id><summary type="html">&lt;p&gt;对于 Android 源代码目录下 &lt;code&gt;values/*&lt;/code&gt; 文件, 其所有的 xml 文件根标签都是 &lt;code&gt;resource&lt;/code&gt;. aapt 会把这个目录下的文件全部 build  出 java 可引用的整型数值, 这样的便可以通过 &lt;code&gt;R.[type].[name]&lt;/code&gt; 来引用到. 其类型只和标签名有关, 对放在哪个文件无关. 一般我们会把这些个类型不同的分别放在不 &lt;code&gt;values/*&lt;/code&gt; 下不同的文件里只是为了方便编码时自己查看.一般有以下几种类型:&lt;/p&gt;
&lt;h3&gt;1. style 主题文件&lt;/h3&gt;
&lt;p&gt;主题文件一般有两种, 一个是 &lt;code&gt;style&lt;/code&gt;, 一个是属性 &lt;code&gt;attr&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;style 标签是主题文件. 一般我们会从系统中的主题, 或者是某个 view 来继承. 或者也可以自己单独写而不继承. &lt;strong&gt;style 标签里 item 的 name 值需要已经是有定义过了的, 可以是系统预先定义好的, 或者是自己再使用 attr …&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;对于 Android 源代码目录下 &lt;code&gt;values/*&lt;/code&gt; 文件, 其所有的 xml 文件根标签都是 &lt;code&gt;resource&lt;/code&gt;. aapt 会把这个目录下的文件全部 build  出 java 可引用的整型数值, 这样的便可以通过 &lt;code&gt;R.[type].[name]&lt;/code&gt; 来引用到. 其类型只和标签名有关, 对放在哪个文件无关. 一般我们会把这些个类型不同的分别放在不 &lt;code&gt;values/*&lt;/code&gt; 下不同的文件里只是为了方便编码时自己查看.一般有以下几种类型:&lt;/p&gt;
&lt;h3&gt;1. style 主题文件&lt;/h3&gt;
&lt;p&gt;主题文件一般有两种, 一个是 &lt;code&gt;style&lt;/code&gt;, 一个是属性 &lt;code&gt;attr&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;style 标签是主题文件. 一般我们会从系统中的主题, 或者是某个 view 来继承. 或者也可以自己单独写而不继承. &lt;strong&gt;style 标签里 item 的 name 值需要已经是有定义过了的, 可以是系统预先定义好的, 或者是自己再使用 attr 定义的.&lt;/strong&gt; 使用 &lt;code&gt;R.style.[name]&lt;/code&gt; 来引用. 在 xml 文件中使用 &lt;code&gt;style=@style/[name]&lt;/code&gt; . 一般放在 &lt;code&gt;values/styles.xml&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;!-- 自定义主题并继承 support 包里的主题 
 继承的主题可以在 3 个地方使用, 全局 application, 单个 activity, 某个 view  
 --&amp;gt;
&amp;lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&amp;gt;
    &amp;lt;!-- 覆写 support 主题里的值 --&amp;gt;
    &amp;lt;item name="colorPrimary"&amp;gt;@color/colorPrimary&amp;lt;/item&amp;gt;
    &amp;lt;!-- 覆写系统主题里的值, 这其实是一个 framework 里的内部 attr --&amp;gt;
    &amp;lt;item name="android:textViewStyle"&amp;gt;@style/BlueTextStyle&amp;lt;/item&amp;gt;
    &amp;lt;!-- 覆写系统主题里的值 --&amp;gt;
    &amp;lt;item name="android:textSize"&amp;gt;18sp&amp;lt;/item&amp;gt;
    &amp;lt;!-- 自定义的属性值 --&amp;gt;
    &amp;lt;item name="source_name"&amp;gt;sources&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;
&amp;lt;attr name="source_name" format="string"/&amp;gt; 
&amp;lt;!-- 自定义的 style, 可以在 layout 中的 view 直接引用 style=@style/BlueTextStyle --&amp;gt;
&amp;lt;style name="BlueTextStyle"&amp;gt;
    &amp;lt;item name="android:textColor"&amp;gt;@android:color/holo_blue_light&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;使用 attr 的原因是为自定义 view 添加属性, 另外是方便更改属性的值. 有两种定义方式. &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一种是直接在 &lt;code&gt;resources&lt;/code&gt; 下定义&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;resources&amp;gt;
    &amp;lt;attr name="one" format="reference"/&amp;gt;
&amp;lt;/resources&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一种是在外面包一层 &lt;code&gt;declare-styleable&lt;/code&gt; 标签. &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;!-- 引用整组为 R.styleable.MyAttrs, 单个为 R.styleable.MyAttrs_other_one --&amp;gt;
&amp;lt;resources&amp;gt;
    &amp;lt;declare-styleable name="MyAttrs"&amp;gt;
        &amp;lt;!-- 这个是 attr 的定义 --&amp;gt;
     &amp;lt;attr name="other_one" format="reference"/&amp;gt;
        &amp;lt;!-- 这个是对已经定义的 attr 引用, 没有 format 值 --&amp;gt;
        &amp;lt;attr name="one"/&amp;gt;
 &amp;lt;/declare-styleable&amp;gt;
&amp;lt;/resources&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;declare-styleable&lt;/code&gt; 主要有两点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它提供了一个数组的引用 &lt;code&gt;R.styleable.[styleable-name]&lt;/code&gt; 引用(组里成员引用为 &lt;code&gt;R.styleable.[styleable-name]_[attr-name]&lt;/code&gt; 注意组名和成员名是用下划线_连接) 由于在使用 &lt;code&gt;Theme#obtainStyledAttributes()&lt;/code&gt; 的参数, 如果我们直接引用 &lt;code&gt;R.attr.one&lt;/code&gt; 也是要组成一个数组的&lt;/li&gt;
&lt;li&gt;如果我们有不同的自定义的 view, 比如 MyTextView, MyOtherTextView, 这样使用分组便于管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#### attr 属性的 format 取值&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当 attr 中没有 format 值时, 是对已经定义了的 attr 的引用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;reference&lt;/code&gt; 引用. 某个资源 ID.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;attr name="my_bg" format="reference"/&amp;gt;

&amp;lt;TextView
  app:my_bg="@drawable/bg"/&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;color&lt;/code&gt; 颜色值.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;boolean&lt;/code&gt; 布尔值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;dimension&lt;/code&gt; 尺寸值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;float&lt;/code&gt; 浮点数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;integer&lt;/code&gt; 整型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt; 字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fraction&lt;/code&gt; 百分数. 使用时类似系统 &lt;code&gt;android:pivotX="200%"&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;enum&lt;/code&gt; 枚举类型. 使用时只能取一个惟一值. &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;declare-styleable name="MyDirection"&amp;gt; 
    &amp;lt;attr name="orientation"&amp;gt; 
        &amp;lt;enum name="horizontal" value="0" /&amp;gt; 
        &amp;lt;enum name="vertical" value="1" /&amp;gt; 
    &amp;lt;/attr&amp;gt;
&amp;lt;/declare-styleable&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;flag&lt;/code&gt; 标志位, 使用时通过 &lt;code&gt;|&lt;/code&gt; 竖线来设置单个或多个值, 如 &lt;code&gt;stateOne | stateTwo&lt;/code&gt; 这样&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;declare-styleable name="MyState"&amp;gt; 
    &amp;lt;attr name="windowSoftInputMode"&amp;gt; 
        &amp;lt;flag name="stateOne" value="0x01" /&amp;gt; 
        &amp;lt;flag name="stateTwo" value="0x10" /&amp;gt; 
    &amp;lt;/attr&amp;gt;
&amp;lt;/declare-styleable&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;混合类型, 比如支持 &lt;code&gt;string|reference&lt;/code&gt; 这种, 使用 &lt;code&gt;|&lt;/code&gt; 竖线分隔开&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;2. 其他资源文件&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/resources/more-resources.html#Bool"&gt;Bool&lt;/a&gt; 布尔型, 只有(true/false)两个值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 &lt;code&gt;R.bool.[name]&lt;/code&gt;, &lt;code&gt;@bool/[name]&lt;/code&gt; 来引用. 一般存放在 &lt;code&gt;values/bools.xml&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;resources&amp;gt;
    &amp;lt;bool name="screen_small"&amp;gt;true&amp;lt;/bool&amp;gt;
&amp;lt;/resources&amp;gt;&lt;/code&gt;&lt;/pre&gt;
2. &lt;a href="https://developer.android.com/guide/topics/resources/more-resources.html#Color"&gt;Color&lt;/a&gt; 颜色, 一个 16 进制的值(#&lt;em&gt;RGB&lt;/em&gt;, #&lt;em&gt;ARGB&lt;/em&gt;, #&lt;em&gt;RRGGBB&lt;/em&gt;, #&lt;em&gt;AARRGGBB&lt;/em&gt;). 跟 &lt;code&gt;res/colors&lt;/code&gt; 下的区别是, 这里的值一般只存储单一的颜色值. 使用 &lt;code&gt;R.color.[name]&lt;/code&gt;, &lt;code&gt;@color/[name]&lt;/code&gt; 来引用, 存放在 &lt;code&gt;values/colors.xml&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;resources&amp;gt;
   &amp;lt;color name="opaque_red"&amp;gt;#f00&amp;lt;/color&amp;gt;
   &amp;lt;color name="translucent_red"&amp;gt;#80ff0000&amp;lt;/color&amp;gt;
&amp;lt;/resources&amp;gt;&lt;/code&gt;&lt;/pre&gt;
3. &lt;a href="https://developer.android.com/guide/topics/resources/more-resources.html#Dimension"&gt;Dimension&lt;/a&gt; 长度尺寸, 有 dp, sp, pt, px, mm, in 单位. 最主要用到的是 &lt;code&gt;dp&lt;/code&gt; 和 &lt;code&gt;sp&lt;/code&gt;. &lt;code&gt;dp&lt;/code&gt; 是一种与设备 DPI 无关的单位, 换算公式为 &lt;code&gt;px = dp * (dpi / 160)&lt;/code&gt;. 一共有 &lt;code&gt;ldpi(120)&lt;/code&gt;, &lt;code&gt;mdpi(160)&lt;/code&gt;, &lt;code&gt;hdpi(240)&lt;/code&gt;, &lt;code&gt;xhdpi(320)&lt;/code&gt;, &lt;code&gt;xxhdpi(480)&lt;/code&gt;, &lt;code&gt;xxxhdpi(640)&lt;/code&gt;, &lt;code&gt;nodpi&lt;/code&gt;, &lt;code&gt;tvdpi&lt;/code&gt;. 通过 &lt;code&gt;DisplayMetrics#densityDpi&lt;/code&gt; 来获取该设备的 dpi, &lt;code&gt;DisplayMetrics.density&lt;/code&gt; 来获取比值, 即 *&lt;em&gt;设备dpi / 基准dpi *&lt;/em&gt;(&lt;code&gt;DisplayMetrics.densityDpi / 160&lt;/code&gt;). 使用 &lt;code&gt;R.dimen.[name]&lt;/code&gt;, &lt;code&gt;@dimen/[name]&lt;/code&gt; 来引用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意: Android 只有以上几种 dpi 比值, 当设备 dpi 和上设定的不完全相等时, 会取近似值. 比如 165 取得 160&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;resources&amp;gt;
    &amp;lt;dimen name="textview_height"&amp;gt;25dp&amp;lt;/dimen&amp;gt;
    &amp;lt;dimen name="font_size"&amp;gt;16sp&amp;lt;/dimen&amp;gt;
&amp;lt;/resources&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/resources/more-resources.html#Id"&gt;ID&lt;/a&gt; 独一无二的 ID 值. 一般我们会在 layout 文件中直接用 &lt;code&gt;@+id/id_name&lt;/code&gt; 来建立, 不过, 当我们有许多地方需要用到这个 id 时, 单独建立文件 &lt;code&gt;values/ids.xml&lt;/code&gt; 来设置这个 id, 然后在需要的地方引用就可. 特别是 &lt;code&gt;ConstraintLayout&lt;/code&gt; 这个需要前后引用 id 来设定 view 的位置时, 就减少了工作量, 不必总使用 &lt;code&gt;@+id/id_name&lt;/code&gt; 来保证 id 一定存在了.  通过 &lt;code&gt;R.id.[name]&lt;/code&gt;, &lt;code&gt;@id/[name]&lt;/code&gt;  来引用. 存放在 &lt;code&gt;values/ids.xml&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;resources&amp;gt;
    &amp;lt;item type="id" name="button_ok" /&amp;gt;
&amp;lt;/resources&amp;gt;

&amp;lt;!-- layout 中引用 --&amp;gt;
&amp;lt;Button android:id="@id/button_ok"/&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/resources/more-resources.html#Integer"&gt;Integer&lt;/a&gt; 整数值, 通过 &lt;code&gt;R.integer.[name]&lt;/code&gt;, &lt;code&gt;@integer/[name]&lt;/code&gt; 来引用. 存放在 &lt;code&gt;values/integers.xml&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;resources&amp;gt;
    &amp;lt;integer name="max_speed"&amp;gt;75&amp;lt;/integer&amp;gt;
&amp;lt;/resources&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/resources/more-resources.html#IntegerArray"&gt;Integer Array&lt;/a&gt; 整型数值, 通赤 &lt;code&gt;R.array.[name]&lt;/code&gt; 来引用. 使用 java 来解析. &lt;code&gt;getResources().getInArray(R.array.bits)&lt;/code&gt;. 存放在 &lt;code&gt;values/integers.xml&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;resources&amp;gt;
    &amp;lt;integer-array name="bits"&amp;gt;
        &amp;lt;item&amp;gt;4&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;8&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;16&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;32&amp;lt;/item&amp;gt;
    &amp;lt;/integer-array&amp;gt;
&amp;lt;/resources&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/topics/resources/more-resources.html#TypedArray"&gt;Typed Array&lt;/a&gt; 混合型数组, 可以引用其他的资源, 数组里可以是引用同一类型的值, 也可以是不同的类型, 当引用不同类型时, 在解析的时候就有注意判断类型值. 使用 &lt;code&gt;R.array.[name]&lt;/code&gt; 引用, 然后有 Java 代码中使用 &lt;code&gt;obtainTypedArray()&lt;/code&gt; 来解析具体的值. 存放在 &lt;code&gt;values/arrays.xml&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;resources&amp;gt;
    &amp;lt;array name="icons"&amp;gt;
        &amp;lt;item&amp;gt;@drawable/home&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;@drawable/settings&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;@drawable/logout&amp;lt;/item&amp;gt;
    &amp;lt;/array&amp;gt;
&amp;lt;/resources&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;java 解析代码示例&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;TypedArray icons = getResources().obtainTypedArray(R.array.icons);
Drawable drawable = icons.getDrawable(0);&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.android.com/guide/topics/resources/string-resource.html"&gt;String&lt;/a&gt; 字符串. 使用 &lt;code&gt;R.string.[name]&lt;/code&gt;, &lt;code&gt;@string/[name]&lt;/code&gt; 引用. 存放在 &lt;code&gt;values/strings.xml&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.android.com/guide/topics/resources/string-resource.html"&gt;String Array&lt;/a&gt; 字符串数组. 使用 &lt;code&gt;R.array.[name]&lt;/code&gt;, &lt;code&gt;@string/name&lt;/code&gt; 引用. 放在 &lt;code&gt;values/strings.xml&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-Xml"&gt;&amp;lt;resources&amp;gt;
    &amp;lt;string-array name="planets_array"&amp;gt;
        &amp;lt;item&amp;gt;Mercury&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;Venus&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;Earth&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;Mars&amp;lt;/item&amp;gt;
    &amp;lt;/string-array&amp;gt;
&amp;lt;/resources&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.android.com/guide/topics/resources/string-resource.html"&gt;String Plurals&lt;/a&gt; 英文中的单复数形式&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;resources&amp;gt;
    &amp;lt;plurals name="numberOfSongsAvailable"&amp;gt;
        &amp;lt;item quantity="one"&amp;gt;Znaleziono %d piosenkę.&amp;lt;/item&amp;gt;
        &amp;lt;item quantity="few"&amp;gt;Znaleziono %d piosenki.&amp;lt;/item&amp;gt;
        &amp;lt;item quantity="other"&amp;gt;Znaleziono %d piosenek.&amp;lt;/item&amp;gt;
    &amp;lt;/plurals&amp;gt;
&amp;lt;/resources&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content><category term="resources"></category><category term="android资源文件"></category><category term="attrs"></category><category term="style"></category><category term="styleable"></category></entry><entry><title>Android View类的构造方法及View的主题属性优先级相关</title><link href="https://ivicel.info/2018/04/android-viewlei-de-gou-zao-fang-fa-ji-viewde-zhu-ti-shu-xing-you-xian-ji-xiang-guan.html" rel="alternate"></link><published>2018-04-22T00:00:00+08:00</published><updated>2018-04-22T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-04-22:/2018/04/android-viewlei-de-gou-zao-fang-fa-ji-viewde-zhu-ti-shu-xing-you-xian-ji-xiang-guan.html</id><summary type="html">&lt;h3&gt;1. layout 里 view 的属性赋值&lt;/h3&gt;
&lt;p&gt;一个 layout 文件里的 view 的属性可以在 5 个地方赋值, 优先级从高到低如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;layout 中对属性直接赋值  &lt;/li&gt;
&lt;li&gt;layout 中覆盖 view 的 style &lt;/li&gt;
&lt;li&gt;构造方法里的 defStyleAttr &lt;/li&gt;
&lt;li&gt;构造方法里的 defStyleRes, 这个当仅当 defStyleAttr 值为 0 , 或者其指定的 attr 值找不到(比如没设定)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义/使用的主题里的值 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;strong&gt;layout&lt;/strong&gt; 布局文件里对 view 直接赋值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;TextView
 android:textColor="#332211"/&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;自定义一个 &lt;code&gt;style&lt;/code&gt;, 然后在 &lt;code&gt;layout&lt;/code&gt; 里的 &lt;code&gt;view&lt;/code&gt; 使用 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;h3&gt;1. layout 里 view 的属性赋值&lt;/h3&gt;
&lt;p&gt;一个 layout 文件里的 view 的属性可以在 5 个地方赋值, 优先级从高到低如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;layout 中对属性直接赋值  &lt;/li&gt;
&lt;li&gt;layout 中覆盖 view 的 style &lt;/li&gt;
&lt;li&gt;构造方法里的 defStyleAttr &lt;/li&gt;
&lt;li&gt;构造方法里的 defStyleRes, 这个当仅当 defStyleAttr 值为 0 , 或者其指定的 attr 值找不到(比如没设定)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义/使用的主题里的值 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;strong&gt;layout&lt;/strong&gt; 布局文件里对 view 直接赋值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;TextView
 android:textColor="#332211"/&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;自定义一个 &lt;code&gt;style&lt;/code&gt;, 然后在 &lt;code&gt;layout&lt;/code&gt; 里的 &lt;code&gt;view&lt;/code&gt; 使用 &lt;code&gt;style&lt;/code&gt; 属性来覆盖. &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;影响该 &lt;code&gt;view&lt;/code&gt; 以及其子 &lt;code&gt;view&lt;/code&gt;. 只有 &lt;code&gt;view&lt;/code&gt; 有对应属性时才进行替换&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;style name="MyTextStyle"&amp;gt;
    &amp;lt;item name="android:textColor"&amp;gt;
&amp;lt;/style&amp;gt;
&amp;lt;!-- 直接对 view 使用 --&amp;gt;
&amp;lt;TextView
 style="@style/MyTextStyle"/&amp;gt;
&amp;lt;!-- 对 ViewGroup 使用, 影响子 view --&amp;gt;
&amp;lt;LinearLayout
 style="@style/MyTextStyle"&amp;gt;

 &amp;lt;TextView
     android:text="inherit from ViewGroup textColor"/&amp;gt;  

    &amp;lt;!-- 没有 textColor 属性, 无影响 --&amp;gt;
    &amp;lt;ImageView
     android:src="@drawable/welcome.png"/&amp;gt;
&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Default Style Attribute (defStyleAttr)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 &lt;code&gt;TextView&lt;/code&gt; 的源代码里有一个构造方法是这样的&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public TextView(Context context, @Nullable AttributeSet attrs) {
    this(context, attrs, com.android.internal.R.attr.textViewStyle);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;com.android.internal.R.attr.textViewStyle&lt;/code&gt; 是一个 frameworks 层定义的 &lt;a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/res/res/values/attrs.xml"&gt;attr&lt;/a&gt;. &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;resources&amp;gt;
    &amp;lt;!-- These are the standard attributes that make up a complete theme. --&amp;gt;
    &amp;lt;declare-styleable name="Theme"&amp;gt;
        &amp;lt;!-- ... --&amp;gt;
        &amp;lt;!-- Default TextView style. --&amp;gt;
        &amp;lt;attr name="textViewStyle" format="reference" /&amp;gt;
        &amp;lt;!-- .... --&amp;gt;
 &amp;lt;declare-styleable&amp;gt;
&amp;lt;/resources&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到这个 attr 类型是一个引用, 所以当我们这样定义一个 style item 时&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&amp;gt;
    &amp;lt;item name="android:textColor"&amp;gt;@android:color/holo_green_dark&amp;lt;/item&amp;gt;
    &amp;lt;!-- 由于 defStyleAttr 的优先级比主题的高, 
     所以 textColor 被覆盖为 holo_blue_light, 即使上面定义了 textColor
 --&amp;gt;
    &amp;lt;item name="android:textViewStyle"&amp;gt;@style/BlueTextStyle&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;

&amp;lt;style name="BlueTextStyle"&amp;gt;
    &amp;lt;item name="android:textColor"&amp;gt;@android:color/holo_blue_light&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Default Style Resource (defStyleRes)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;构造方法 &lt;code&gt;public View(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)&lt;/code&gt; 是在 SDK 21 之后才有的, 但 defStyleRes 的值是早之前就有使用的. 这个是一个 &lt;code&gt;R.style.[name]&lt;/code&gt; 值, 只有当 defStyleAttr 为 0 或者查找不到时才有效&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是, &lt;code&gt;defStyleAttr&lt;/code&gt; 里要求的是一个 format="reference" 的 attr, 但其实质上是一个整型值, 并且代码中没有用 @AttrRes 来注释, 所以随便传一个整型值时, 便可能是相当于 defStyleAttr 不存在. 同理 &lt;code&gt;defStyleRes&lt;/code&gt; 要求的是一个 style id&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;在主题文件里赋值, 比如我们在 &lt;code&gt;styles.xml&lt;/code&gt; 里自定义了一个主题 &lt;code&gt;AppTheme&lt;/code&gt;. &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个主题可以在 &lt;code&gt;activity&lt;/code&gt; 里覆盖, 也可以设置为程序的默认主题&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;!--比如我们在 styles.xml 里自定义一个主题, 覆盖 andorid:textColor 后, 
 使用该主题的 view 中有 android:textColor 这个属性的会使用我们设定的值
 因为我们定义的是一个应用的主题, 而不是单独某个 view 下的某些个属性
 所以这个主题需要继承系统的主题, 然后再覆盖, 下面继承的是 support 包里的兼容主题
 --&amp;gt;
&amp;lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&amp;gt;
    &amp;lt;item name="android:textColor"&amp;gt;@color/myTextColor&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;

&amp;lt;!-- 设置好一个程序的主题文件后, 我们可以在 AndroidManifest.xml 中引用 --&amp;gt;
&amp;lt;!-- 应用全局主题 --&amp;gt;
&amp;lt;application
 android:theme="@style/AppTheme"/&amp;gt;

&amp;lt;!-- 在 activity 配置里引用, 这会覆盖掉全局 application 里的设置 --&amp;gt;
&amp;lt;activity
 android:theme="@style/AppTheme"/&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2. 构造方法介绍&lt;/h3&gt;
&lt;p&gt;以 SDK 27 中的 &lt;code&gt;ImageView&lt;/code&gt; 为例, 一共有 4 个构造方法, 如下&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public ImageView(Context context) {
        super(context);
        initImageView();
}

public ImageView(Context context, @Nullable AttributeSet attrs) {
    this(context, attrs, 0);
}

public ImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
    this(context, attrs, defStyleAttr, 0);
}

public ImageView(Context context, @Nullable AttributeSet attrs, int defStyleAttr,
        int defStyleRes) {
    super(context, attrs, defStyleAttr, defStyleRes);
    /* .... */
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构造方法最多有 4 个参数, 简单意思如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;context&lt;/code&gt; 每个构造方法都有, 用来 inflate, 获取各种参数值等. 如果我们从 Java 代码中直接创建一个新的 view, 一般都是使用只有 context 的参数的构造方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;attrs&lt;/code&gt; 这个是对布局文件 layout.xml 里的解析后生成的对象, 可以获取到 xml 里的配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;defStyleAttr&lt;/code&gt; 属性引用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;defStyleRes&lt;/code&gt; SDK 21 后增加的. 如果 minSdkVersion &amp;gt; 21 时才使用这个参数. 不然使用 &lt;code&gt;Theme#obtainStyledAttributes()&lt;/code&gt; 也可以解析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 View inflate 后, 其所以设置属性都解析到了参数 attrs 中. 可以通过 &lt;code&gt;AttributeSet#getAttributeName()&lt;/code&gt;, &lt;code&gt;AttributeSet#getAttributeValue()&lt;/code&gt; 来获得名称和值. 但这个获得的只能是直接的值, 如果像 &lt;code&gt;android:text=@string/name"&lt;/code&gt; 这样引用, android 内部都是通过 id 来查找, 所以也是获得一个 id 值, 所以我们总是用 &lt;code&gt;Theme&lt;/code&gt; 类里的方法来一步解析, 这样可以直接找到对应的 string 值而不是 id&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Context&lt;/code&gt; 中也有对应的方法, 其实质是调用了 context.getTeme.obtainStyledAttributes 而已&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 从解析好的 AttributeSet 查找
TypedArray obtainStyledAttributes(AttributeSet set, int[] attrs, int defStyleAttr, 
        int defStyleRes)
// 从主题中查找
TypedArray obtainStyledAttributes(int[] attrs)
// 从指定的资源文件查找
TypedArray obtainStyledAttributes(int resId, int[] attrs)&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Reference:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0806/4575.html"&gt;http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0806/4575.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/nbalichaoq/article/details/50550103"&gt;https://blog.csdn.net/nbalichaoq/article/details/50550103&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="view"></category><category term="构造方法"></category><category term="attrs"></category><category term="declare-styleable"></category><category term="style"></category></entry><entry><title>AsyncTask机制分析</title><link href="https://ivicel.info/2018/04/asynctaskji-zhi-fen-xi.html" rel="alternate"></link><published>2018-04-10T00:00:00+08:00</published><updated>2018-04-10T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-04-10:/2018/04/asynctaskji-zhi-fen-xi.html</id><summary type="html">&lt;h3&gt;1. AsyncTask 的使用&lt;/h3&gt;
&lt;p&gt;AsyncTask 为抽象类, 继承该类至少要重写 &lt;code&gt;doInBackground(Params...params)&lt;/code&gt; 方法. 除了该方法是在&lt;strong&gt;非主程&lt;/strong&gt;中执行外, 其他的如 &lt;code&gt;onPreExecute()&lt;/code&gt; &lt;code&gt;onProgressUpdate(Progress...progresses)&lt;/code&gt; &lt;code&gt;onPostExecute(Result result)&lt;/code&gt; &lt;code&gt;onCancel()&lt;/code&gt; 都是在主线程中执行. &lt;/p&gt;
&lt;p&gt;AsyncTask 另外可以设置三个类型参数, &lt;code&gt;AsyncTask&amp;lt;Params, Progress, Result&amp;gt;&lt;/code&gt; . 分别指传入  &lt;code&gt;doInBackground(Param…params)&lt;/code&gt;  的参数数组, &lt;code&gt;onProgressUpdate(Progress…progress)&lt;/code&gt; 进度更新参数,  从 &lt;code&gt;doInBackground()&lt;/code&gt; 返回结果, 可在 &lt;code&gt;onPostExecute(Result result)&lt;/code&gt; 中接收到该结果.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public static DownloadTask extends …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;h3&gt;1. AsyncTask 的使用&lt;/h3&gt;
&lt;p&gt;AsyncTask 为抽象类, 继承该类至少要重写 &lt;code&gt;doInBackground(Params...params)&lt;/code&gt; 方法. 除了该方法是在&lt;strong&gt;非主程&lt;/strong&gt;中执行外, 其他的如 &lt;code&gt;onPreExecute()&lt;/code&gt; &lt;code&gt;onProgressUpdate(Progress...progresses)&lt;/code&gt; &lt;code&gt;onPostExecute(Result result)&lt;/code&gt; &lt;code&gt;onCancel()&lt;/code&gt; 都是在主线程中执行. &lt;/p&gt;
&lt;p&gt;AsyncTask 另外可以设置三个类型参数, &lt;code&gt;AsyncTask&amp;lt;Params, Progress, Result&amp;gt;&lt;/code&gt; . 分别指传入  &lt;code&gt;doInBackground(Param…params)&lt;/code&gt;  的参数数组, &lt;code&gt;onProgressUpdate(Progress…progress)&lt;/code&gt; 进度更新参数,  从 &lt;code&gt;doInBackground()&lt;/code&gt; 返回结果, 可在 &lt;code&gt;onPostExecute(Result result)&lt;/code&gt; 中接收到该结果.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public static DownloadTask extends AsyncTask&amp;lt;String, Integer, Long&amp;gt; {
    @Override
    protected Long doInBackground(String...urls) {
        int i = 0;
        for (String url : urls) {
            Log.d(TAG, "get url: " + url);
            i++;
            publishProgress(i);
        }
        return i;
    }

    @Override
    protected void onProgressUpdate(Integer...progress) {
        for (Integer p : progress) {
            Log.d(TAG, "get progress: " + p);
        }
    }

    @Override
    protected void onPostExecute(Long result) {
        Log.d(TAG, "get result: " + result);    
    }
}

DownloadTask&amp;lt;String, Integer, Long&amp;gt; task = new DownloadTask&amp;lt;&amp;gt;();
task.execute(urls);&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在 &lt;strong&gt;SDK 17(JellyBean_MR1)&lt;/strong&gt; 之后新建对象和 &lt;code&gt;execute()&lt;/code&gt; 方法不必在主线程中调用了, 因为 sHandler 这个静态变量已经在内部使用 Looper.getMainLooper 来初始化了. &lt;a href="https://android.googlesource.com/platform/frameworks/base/+/jb-mr1-release/core/java/android/os/AsyncTask.java"&gt;查看源码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;不要在重写时直接调用 &lt;code&gt;onXXXX&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;一个 AsyncTask 对象只能执行一次 &lt;code&gt;execute/executeOnExecutor&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AsyncTask#execute()&lt;/code&gt; 默认是串行执行, 可以使用 &lt;code&gt;AsyncTask#executOnExecutor()&lt;/code&gt; 来并行执行任务.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. 源码分析(基于 SDK 27)&lt;/h3&gt;
&lt;p&gt;当我们创建一个新的 AsyncTask 对象时, 都会走到 &lt;code&gt;AsyncTask(Looper callbackLooper)&lt;/code&gt; 这个构造方法. 如果没传入 null 或者 main looper 时, 就会默认使用主线程的 looper&lt;/p&gt;
&lt;h4&gt;2.1 构造方法&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public AsyncTask(Looper callbackLooper) {
    // 使用自定义 handler 或者使用默认的 handler, 默认 handler 在主线程中执行
    mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper()
            ? getMainHandler()
            : new Handler(callbackLooper);
    // 初始化执行参数和返回结果
    /* .... */
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2.2 执行方法&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;AsyncTask#execute&lt;/code&gt; 其实也是调用了 &lt;code&gt;AsyncTask#executeOnExecutor&lt;/code&gt;, 其传入了一个内部实现的串行 &lt;code&gt;Executor&lt;/code&gt;. &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// AsyncTask#executeOnExecutor
public final AsyncTask&amp;lt;Params, Progress, Result&amp;gt; executeOnExecutor(Executor exec,
            Params... params) {
        // 判断当前状态, 运行中或已完成的将抛出错误. 这也证明了前面说的每个对象只能调用一次执行
        if (mStatus != Status.PENDING) {
            switch (mStatus) {
                case RUNNING:
                    throw new IllegalStateException("Cannot execute task:"
                            + " the task is already running.");
                case FINISHED:
                    throw new IllegalStateException("Cannot execute task:"
                            + " the task has already been executed "
                            + "(a task can be executed only once)");
            }
        }
        // 设置运行状态, 调用执行任务前的准备方法, 传入参数, 使用线程池执行任务
        mStatus = Status.RUNNING;
        onPreExecute();
        mWorker.mParams = params;
        // 这会调用 Runnable 里的 run() 方法
        exec.execute(mFuture);

        return this;
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一分为二. 在调用 &lt;code&gt;Executor#execute(Runnable)&lt;/code&gt; 之后, 将根据之前不同的默认的 &lt;code&gt;Executor&lt;/code&gt; 来执行任务. 一个是串行, 一个是并行. &lt;/p&gt;
&lt;p&gt;串行的内部实现&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public static final Executor SERIAL_EXECUTOR = new SerialExecutor();
private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;

// AsyncTask#SerialExecutor
private static class SerialExecutor implements Executor {
        // 非线程安全的数组实现的双端队列
        final ArrayDeque&amp;lt;Runnable&amp;gt; mTasks = new ArrayDeque&amp;lt;Runnable&amp;gt;();
        Runnable mActive;
        // 执行任务时, 把任务添加到队列中, 从队列里依次取出来执行
        public synchronized void execute(final Runnable r) {
            mTasks.offer(new Runnable() {
                public void run() {
                    try {
                        r.run();
                    } finally {
                        scheduleNext();
                    }
                }
            });
            if (mActive == null) {
                scheduleNext();
            }
        }

        protected synchronized void scheduleNext() {
            if ((mActive = mTasks.poll()) != null) {
                // 在这是里使用的是已经创建好的线程池来执行任务, 避免过多创建新线程
                // 减小不必要的消耗. 由于 mTask 取出来的 Runnable 执行方法里, 
                // 我们又递归的调用了 scheduleNext, 所以会按顺序执行下去
                THREAD_POOL_EXECUTOR.execute(mActive);
            }
        }
    }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并行的内部实现. &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public static final Executor THREAD_POOL_EXECUTOR;
static {
    // 核心线程 2-4, 最大线程数为 CPU 核心数 + 1, 30s 的超时时间(设置了核心线程也会超时)
    // 有界的等待队列, 最大值为 128, 创建线程的工厂方法重写了以 AsyncTask + number 的线程名
    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
            CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,
            sPoolWorkQueue, sThreadFactory);
    threadPoolExecutor.allowCoreThreadTimeOut(true);
    THREAD_POOL_EXECUTOR = threadPoolExecutor;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于 &lt;code&gt;Executor&lt;/code&gt; 具体执行的是在构造方法里初始化的 &lt;code&gt;FutureTask#run()&lt;/code&gt;方法, 其中我们传入了一个 &lt;code&gt;Runnable&lt;/code&gt; 作为参数, 该参数的 run 方法会在这里会被调用. 回过来看构造方法里的&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public final AsyncTask&amp;lt;Params, Progress, Result&amp;gt; executeOnExecutor(Executor exec,
            Params... params) {
    /* ... */

    mWorker = new WorkerRunnable&amp;lt;Params, Result&amp;gt;() {
            public Result call() throws Exception {
                // 原子状态, 调用中
                mTaskInvoked.set(true);
                Result result = null;
                try {
                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                    // 调用定义的方法, 返回结果
                    result = doInBackground(mParams);
                    Binder.flushPendingCommands();
                } catch (Throwable tr) {
                    // 取消
                    mCancelled.set(true);
                    throw tr;
                } finally {
                    // 这会调用之前定义好的 handler 通 message 传送到 onPostExecute 中
                    // result 会被再包一层 AsyncTaskResult 类中, 类中包含 AsyncTask 对象和
                    // result 对象
                    // AsyncTaskResult 可以接收一个结果数组, 但默认 handler 实现只取一个结果
                    postResult(result);
                }
                return result;
            }
        };
        // FutureTask#run 执行时会调用 Callable 里的 call 方法
        // call 方法的返回值会作为 FutureTask 的调用结果, 通过 Future#get 方法获得
        mFuture = new FutureTask&amp;lt;Result&amp;gt;(mWorker) {
            // 在设置 Future#set 返回值后, 会调用该方法
            @Override
            protected void done() {
                try {
                    // 再次检测运行的结果是否给返回回调
                    postResultIfNotInvoked(get());
                } catch (InterruptedException e) {
                    android.util.Log.w(LOG_TAG, e);
                } catch (ExecutionException e) {
                    throw new RuntimeException("An error occurred while " +
                        " executing doInBackground()", e.getCause());
                } catch (CancellationException e) {
                    postResultIfNotInvoked(null);
                }
            }
        };
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于 AsyncTask 不能执行时间太长(几分钟)的任务, 原因官方并没有解释说明. 在 StackOverflow 上的一个&lt;a href="https://stackoverflow.com/questions/12797550/android-asynctask-for-long-running-operations?noredirect=1&amp;amp;lq=1"&gt;回答&lt;/a&gt;,  最高票的答案说明了两点原因:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有和 Activity 的生命周期同步&lt;/li&gt;
&lt;li&gt;易产生内存泄漏&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一点, &lt;code&gt;doInBackground&lt;/code&gt; 是在非主线程中执行, 之后会在主线程中调用  &lt;code&gt;onPostExecute&lt;/code&gt; 更新 UI. 但可能原先的 Activity 可能已经被 destroy, 或者重建, AsyncTask 中原 Activity 引用已经不是原来的指向, 这可能引发 Exception. 第二点, 我们很容易在 Activity 中创建一个 AsyncTask 的 inner class, 这使 AsyncTask 中有一个指向 Activity 的引用, 当手机转向等引起的 Activity 重建, 由于 AsyncTask 持有 outer class 的引用, 导致 Activity 不能释放内存&lt;/p&gt;
&lt;h3&gt;Reference:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&amp;lt;&lt;Android开发艺术探索&gt;&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://android.googlesource.com/platform/frameworks/base/+/oreo-release/core/java/android/os/AsyncTask.java"&gt;AsyncTask 源代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/12797550/android-asynctask-for-long-running-operations?noredirect=1&amp;amp;lq=1"&gt;https://stackoverflow.com/questions/12797550/android-asynctask-for-long-running-operations?noredirect=1&amp;amp;lq=1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/Gaugamela/article/details/55188752"&gt;https://blog.csdn.net/Gaugamela/article/details/55188752&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="线程"></category><category term="线程池"></category><category term="AsyncTask"></category></entry><entry><title>Java 线程及线程池</title><link href="https://ivicel.info/2018/04/java-xian-cheng-ji-xian-cheng-chi.html" rel="alternate"></link><published>2018-04-10T00:00:00+08:00</published><updated>2018-04-10T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-04-10:/2018/04/java-xian-cheng-ji-xian-cheng-chi.html</id><summary type="html">&lt;h3&gt;1. Java 线程池&lt;/h3&gt;
&lt;h4&gt;1.1 java 线程池框架的主要类和接口&lt;/h4&gt;
&lt;p&gt;&lt;img alt="java线程池框架" src="../../assets/images/java线程池框架.jpg" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Executor 接口定义了执行器 Runnable 执行方式&lt;/li&gt;
&lt;li&gt;ExecutorService 定义了线程具体接口&lt;/li&gt;
&lt;li&gt;ScheduledExecutorService 定义了定时执行线程的接口&lt;/li&gt;
&lt;li&gt;AbstractExecutorService 线程池的实现的抽象类&lt;/li&gt;
&lt;li&gt;ThreadPoolExecutor 线程池的具体实现类&lt;/li&gt;
&lt;li&gt;ScheduledThreadPoolExecutor 定时线程池的实现类&lt;/li&gt;
&lt;li&gt;Executors 线程池的辅助工具类&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.2 Executors 辅助类主要几种线程池模型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;newCachedThreadPool&lt;/code&gt; 可缓存的无界线程池, 当一个新请求到来时, 如果没有缓存线程则新建一条线程来处理. 如果有则用缓存线程. 处理完成后, 空闲线程会被缓存, 如果超时前没有被用来处理请求, 则该线程会被回收. 这个模型的线程池是 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 可以看作是无限大小的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newFixedThreadPool&lt;/code&gt; 固定大小的线程池, 对于没有线程处理的请求会在 &lt;code&gt;LinkedBlockingQueue&lt;/code&gt; 中等待处理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newSingleThreadExecutor&lt;/code&gt; 单一线程的线程池, 请求会被按队列顺序处理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newScheduledThreadPool&lt;/code&gt; 固定大小 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h3&gt;1. Java 线程池&lt;/h3&gt;
&lt;h4&gt;1.1 java 线程池框架的主要类和接口&lt;/h4&gt;
&lt;p&gt;&lt;img alt="java线程池框架" src="../../assets/images/java线程池框架.jpg" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Executor 接口定义了执行器 Runnable 执行方式&lt;/li&gt;
&lt;li&gt;ExecutorService 定义了线程具体接口&lt;/li&gt;
&lt;li&gt;ScheduledExecutorService 定义了定时执行线程的接口&lt;/li&gt;
&lt;li&gt;AbstractExecutorService 线程池的实现的抽象类&lt;/li&gt;
&lt;li&gt;ThreadPoolExecutor 线程池的具体实现类&lt;/li&gt;
&lt;li&gt;ScheduledThreadPoolExecutor 定时线程池的实现类&lt;/li&gt;
&lt;li&gt;Executors 线程池的辅助工具类&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.2 Executors 辅助类主要几种线程池模型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;newCachedThreadPool&lt;/code&gt; 可缓存的无界线程池, 当一个新请求到来时, 如果没有缓存线程则新建一条线程来处理. 如果有则用缓存线程. 处理完成后, 空闲线程会被缓存, 如果超时前没有被用来处理请求, 则该线程会被回收. 这个模型的线程池是 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 可以看作是无限大小的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newFixedThreadPool&lt;/code&gt; 固定大小的线程池, 对于没有线程处理的请求会在 &lt;code&gt;LinkedBlockingQueue&lt;/code&gt; 中等待处理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newSingleThreadExecutor&lt;/code&gt; 单一线程的线程池, 请求会被按队列顺序处理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newScheduledThreadPool&lt;/code&gt; 固定大小, 可定时或周期执行的任务的线程池&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;工厂方法&lt;/th&gt;
&lt;th&gt;corePoolSize&lt;/th&gt;
&lt;th&gt;maximumPoolSize&lt;/th&gt;
&lt;th&gt;keepAliveTime&lt;/th&gt;
&lt;th&gt;workQueue&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;newCachedThreadPool&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;Integer.MAX_VALUE&lt;/td&gt;
&lt;td&gt;60s&lt;/td&gt;
&lt;td&gt;SynchronousQueue&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;newFixedThreadPool&lt;/td&gt;
&lt;td&gt;nThreads&lt;/td&gt;
&lt;td&gt;nThreads&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;LinkedBlockingQueue&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;newSingleThreadExecutor&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;LinkedBlockingQueue&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;newScheduledThreadPool&lt;/td&gt;
&lt;td&gt;corePoolSze&lt;/td&gt;
&lt;td&gt;Integer.MAX_VALUE&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;DelayedWorkQueue&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;1.3 ThreadPoolExecutor 类&lt;/h4&gt;
&lt;p&gt;构造方法&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,
        long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
        ThreadFactory threadFactory, RejectedExecutionHandle rejectedHandler);&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;corePoolSize: 线程池的基本大小, &lt;strong&gt;必须 &amp;gt;= 0&lt;/strong&gt;. 当有请求到来时, 若当前线程池中的线程数小于该值, 即使有空闲线程存在也会创建新的线程来处理该请求. 当线程数大于等于这个数值时, 才会根据是否存在空闲线程来决定是否创建新线程.&lt;/li&gt;
&lt;li&gt;maximumPoolSize: 线程池的最大大小, &lt;strong&gt;必须 &amp;gt;= 1&lt;/strong&gt;. 当线程池中的线程数等于该值时, 请求会被加入到请求队列, 等待有空闲线程来处理该请求&lt;/li&gt;
&lt;li&gt;keepAliveTime: 空闲线程存活时间, &lt;strong&gt;必须 &amp;gt;= 0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;unit: 存活时间的时间单位&lt;/li&gt;
&lt;li&gt;workQueue: 任务队列, 不能为空.&lt;ul&gt;
&lt;li&gt;ArrayBlockingQueue: 基于数组的有界阻塞队列.&lt;/li&gt;
&lt;li&gt;LinkedBlockingQueue: 基于链表的无界阻塞队列.&lt;/li&gt;
&lt;li&gt;SynchronousQueue: 同步阻塞队列. 每插入一个元素必须等待另一个对应的删除操作完成&lt;/li&gt;
&lt;li&gt;PriorityBlockingQueue: 基于优先级的无界阻塞队列.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;threadFactory: 线程工厂, 有默认的工厂方法 &lt;code&gt;DefaultThreadFactory&lt;/code&gt; 类. 用来新创建线程&lt;/li&gt;
&lt;li&gt;rejectedHandler: 线程饱和策略, 默认为 &lt;code&gt;ThreadPoolExecutor.AbortPolicy&lt;/code&gt;. 当请求无法加入到请求队列时, 请求被拒绝时的处理方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.4 线程池执行策略&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;当新的请求到来时, 判断是否大于 coreSize, 大于则加入请求队列, 小于则直接新创建线程来处理&lt;/li&gt;
&lt;li&gt;判断空闲线程. 当线程池中的数量 &amp;lt; maximum 时, 创建新的线程来处理队列中的任务&lt;/li&gt;
&lt;li&gt;判断能否加入到队列中, 不能则直接使用拒绝请求设置的策略, 能则等待空闲线程&lt;/li&gt;
&lt;li&gt;当无法创建新线程时, 不能加入到队列中的任务将被拒绝执行&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Reference:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://gityuan.com/2016/01/16/thread-pool/"&gt;http://gityuan.com/2016/01/16/thread-pool&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="线程"></category><category term="线程池"></category><category term="AsyncTask"></category><category term="Handler Thread"></category></entry><entry><title>Android 硬盘缓存 DiskLrucCache</title><link href="https://ivicel.info/2018/04/android-ying-pan-huan-cun-disklruccache.html" rel="alternate"></link><published>2018-04-04T00:00:00+08:00</published><updated>2018-04-04T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-04-04:/2018/04/android-ying-pan-huan-cun-disklruccache.html</id><summary type="html">&lt;h3&gt;1. DiskLruCache 的使用&lt;/h3&gt;
&lt;p&gt;DiskLruCache 并不属于 Android 源码, 只是官方推荐的一种实现方式, 可以在 &lt;a href="https://android.googlesource.com/platform/libcore/+/jb-mr2-release/luni/src/main/java/libcore/io/StrictLineReader.java"&gt;这里&lt;/a&gt; 找到源码, 这个源码使用了其他几个自定义类里的方法, 比如读行, 出错打印. Android Developer Sample 里关于 bitmap 的加载使用到了这个类来做缓存, 可直接使用, 可以在 &lt;a href="https://developer.android.com/samples/DisplayingBitmaps/src/com.example.android.displayingbitmaps/util/DiskLruCache.html"&gt;这里&lt;/a&gt; 找到源码. 另外一个 &lt;a href="https://gist.github.com/ivicel/f98f9ba4420c9d2c5274f151b625f677"&gt;GitHub 备份地址&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Android Developer Sample 里的源码没有有效的初始化 redundantOpCount, 而是为 0. 这导致如果不断退出重进应用, 很难达到封顶的 2000 行, 即使 journal 已经超出 2000 行. &lt;/p&gt;
&lt;p&gt;GitHub 上已经添加&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般来说我们都会把磁盘放到 sdcard 上, 也就是 &lt;code&gt;/sdcard …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;h3&gt;1. DiskLruCache 的使用&lt;/h3&gt;
&lt;p&gt;DiskLruCache 并不属于 Android 源码, 只是官方推荐的一种实现方式, 可以在 &lt;a href="https://android.googlesource.com/platform/libcore/+/jb-mr2-release/luni/src/main/java/libcore/io/StrictLineReader.java"&gt;这里&lt;/a&gt; 找到源码, 这个源码使用了其他几个自定义类里的方法, 比如读行, 出错打印. Android Developer Sample 里关于 bitmap 的加载使用到了这个类来做缓存, 可直接使用, 可以在 &lt;a href="https://developer.android.com/samples/DisplayingBitmaps/src/com.example.android.displayingbitmaps/util/DiskLruCache.html"&gt;这里&lt;/a&gt; 找到源码. 另外一个 &lt;a href="https://gist.github.com/ivicel/f98f9ba4420c9d2c5274f151b625f677"&gt;GitHub 备份地址&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Android Developer Sample 里的源码没有有效的初始化 redundantOpCount, 而是为 0. 这导致如果不断退出重进应用, 很难达到封顶的 2000 行, 即使 journal 已经超出 2000 行. &lt;/p&gt;
&lt;p&gt;GitHub 上已经添加&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般来说我们都会把磁盘放到 sdcard 上, 也就是 &lt;code&gt;/sdcard/Android/data/app_package_name/cache&lt;/code&gt; 里, 在 &lt;strong&gt;SDK 19&lt;/strong&gt; 之前, 外部存储需要声明权限 &lt;code&gt;WRITE_EXTERNAL_STORAGE&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;在使用外部存储之前, 还有一样需要注意的是&lt;strong&gt;判断是否存在外部存储&lt;/strong&gt;. &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;private File getCacheDirectoryFile(Context context, String dirName) {
    File cacheFile;
    if (!Environment.isExternalStorageRemovable ||
        Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
        // 外部 cache
        cacheFile = context.getExternalCacheDir();
    } else {
        // 内部 cache
        cacheFile = context.getCacheDir();
    }
    return new File(cacheFile, dirName);
}&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;DiskLruCache 的缓存目录里不要跟别的缓存相互混合, 以免导致缓存出错&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;DiskLruCache 构造方法是 &lt;code&gt;private&lt;/code&gt;, 提供了一个 &lt;code&gt;DiskLruCache#open()&lt;/code&gt; 方法来获得一个新的对象.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// @param directory 缓存目录
// @param appVersion 版本号, 当版本号发生改变时, 缓存会被清空重建
// @param valueCount 每个节点对应该对应的数据个数, 一般传 1, 一个节点一个数据
// @param maxSize 缓存大小
public static open(File directory, int appVersion, int valueCount, long maxSize);

// 80M 缓存
DiskLruCache lruCache = DiskLruCache.open(getCacheDirectoryFile(context, "images",
        1, 1, 80 * 1024 * 1024);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;向缓存中写入数据, 由 &lt;code&gt;DiskLruCache.Editor&lt;/code&gt; 类负责. 使用 &lt;code&gt;DiskLruCache#edit()&lt;/code&gt; 方法获得一个 &lt;code&gt;DiskLruCache.Editor&lt;/code&gt; 对象, 便可以打开文件输入和输出流来进行读写. 这里的 &lt;code&gt;newInputStream()&lt;/code&gt; 只能读到最后一次 &lt;code&gt;commit&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 由 key 值获得 Editor 对象, key 值一般也使用 url 的 MD5 值
DiskLruCache.Editor editor = lruCache.edit(key);
// 获得输出流, 参数是数据的数组下标, 指的是在 open 时传入的 valueCount 的值
// 这个值为一个 node 节点以数组的形式来存储多少个数据, 只存一个数据, 其下标为 0
OutputStream out = editor.newOutputStream(0);
// 将 bitmap 压缩成 png 写入到流中, 然后将写入结果记到日志中
if (bitmap.compress(Bitmap.CompressFormat.PNG, 50, out)) {
    editor.commit();
} else {
    editor.abort();
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 &lt;code&gt;DiskLruCache#get()&lt;/code&gt; 方法可以得到一个 &lt;code&gt;DiskLruCache.Snapshot&lt;/code&gt; 对象, 通过这个对象可以得到缓存文件的输入流&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 根据 key 找到对应的缓存文件
DiskLruCache.Snapshot snapShot = lruCache.get(key);
InputStream in = snapShot.getInputStream(0);
// InputStream 是一种有序的流, 第一次读完后指针便指向流末尾. 用文件描述符即可, 或者重置指针位置
FileDescriptor fd = in.getFD();
// 根据需要的宽高进行压缩
bitmap = loadSpecifyImage(fd, destWidth, destHeight);&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2. DiskLruCache 源码解析&lt;/h3&gt;
&lt;h4&gt;2.1 头部&lt;/h4&gt;
&lt;p&gt;DiskLruCache 的缓存记录最主要是对其日志文件 journal 进行操作, 一但 journal 文件遭到破坏, 缓存被会被重建. 其格式说明如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code&gt;libcore.io.DiskLruCache
1
1
2

DIRTY 335c4c6028171cfddfbaae1a9c313c52
CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342
REMOVE 335c4c6028171cfddfbaae1a9c313c52
DIRTY 1ab96a171faeeee38496d8b330771a7a
CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234
READ 1ab96a171faeeee38496d8b330771a7a&lt;/code&gt;&lt;/pre&gt;

&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;头部, 每一次打开(&lt;code&gt;DiskLruCache#open&lt;/code&gt;)时都会验证头部是否相符, 如果存在 &lt;strong&gt;journal&lt;/strong&gt; 但不相符的, 缓存被清空然后重建. 不存在 &lt;strong&gt;journal&lt;/strong&gt; 的, 重建缓存:&lt;/li&gt;
&lt;li&gt;第一行是文件标识 &lt;code&gt;MAGIC&lt;/code&gt;, 默认为 &lt;code&gt;libcore.io.DiskLruCache&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第二行是 DiskLruCache 类的版本号(&lt;code&gt;CACHE_VERSION&lt;/code&gt;), 默认是 &lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第三行是传入的 App 版本号(&lt;code&gt;APP_VERSION&lt;/code&gt;), 当应用版本号变动时缓存被清空. 要想在应用变更时不清空缓存传入一个&lt;strong&gt;固定值&lt;/strong&gt;便可&lt;/li&gt;
&lt;li&gt;第四行是 &lt;code&gt;valueCount&lt;/code&gt;, 代表的是一个 &lt;code&gt;Node&lt;/code&gt; 结点对应的是几个数据节点. 上面的是 &lt;strong&gt;两&lt;/strong&gt; 个&lt;/li&gt;
&lt;li&gt;第五行是一个空行分隔行&lt;/li&gt;
&lt;li&gt;主体记录, 格式为 &lt;code&gt;status key value[0].length….value[N - 1].length&lt;/code&gt;, 每列值以&lt;strong&gt;空格&lt;/strong&gt;分隔&lt;/li&gt;
&lt;li&gt;&lt;code&gt;status&lt;/code&gt; 的值有:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DIRTRY&lt;/code&gt; 脏数据, 代表对这条数据进行操作, 每一行 &lt;code&gt;DIRTY&lt;/code&gt; 后都应该跟着一条 &lt;code&gt;CLEAN&lt;/code&gt; 或者 &lt;code&gt;REMOVE&lt;/code&gt;, 代表对数据的操作结束. 如果没有则这条数据为无效数据, 将被删除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CLEAN&lt;/code&gt; 代表这条数据已经写入到磁盘中, 可以进行读写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;REMOVE&lt;/code&gt; 代表这条数据已经被删除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;READ&lt;/code&gt; 代表读取一条数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;status&lt;/code&gt; 后面跟着 &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;CLEAN&lt;/code&gt; 操作后面跟着节点内每条数据的大小, 单位为 &lt;code&gt;byte&lt;/code&gt;, 上面例子每个节点有两条. 这些&lt;strong&gt;数据的合&lt;/strong&gt;代表当前缓存使用的大小&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;2.2 缓存文件的内部摘要类 Entry&lt;/h4&gt;
&lt;p&gt;与 LruCache 类似, DiskLruCache 也是一个最近访问最多算法, 其类内部也一样持一个 &lt;code&gt;LinkedHashMap&lt;/code&gt; 对象 &lt;code&gt;lruEntries&lt;/code&gt; 来记录其数据被访问记录, 结构为 &lt;code&gt;&amp;lt;String, DiskLruCache#Entry&amp;gt;&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt; 是我们传入的, &lt;code&gt;Entry&lt;/code&gt; 对象为内部私有类, 记录在磁盘上名为 &lt;code&gt;key&lt;/code&gt; 的文件的一些信息. 比如可读, 可写, 对应 &lt;code&gt;key&lt;/code&gt; 等&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// DiskLruCache#Entry
private final class Entry {
    // 对应的 key
    private final String key;
    // 节点数据的字节数
    private final long[] lengths;
    // 当一条数据有 CLEAN, 即被写到磁盘里时, 为 true
    private boolean readable;
    // The ongoing edit or null if this entry is not being edited.
    private Editor currentEditor;
    // The sequence number of the most recently committed edit to this entry.
    private long sequenceNumber;

    /* ... */

    // 一个 node 对应多个数据时, 是以 key.i 的格式为名字来保存文件
    public File getCleanFile(int i) {
        return new File(directory, key + "." + i);
    }

    public File getDirtyFile(int i) {
        return new File(directory, key + "." + i + ".tmp");
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2.3 打开缓存&lt;/h4&gt;
&lt;p&gt;DiskLruCache 的构造方法是 &lt;code&gt;private&lt;/code&gt; 的, 通过静态方法 &lt;code&gt;DiskLruCache#open()&lt;/code&gt; 来创建一个缓存对象. 构造方法只是简单的保存了一些属性值. 而 &lt;code&gt;open()&lt;/code&gt; 方法里对 journal 文件进行了判断和验证&lt;/p&gt;
&lt;p&gt;创建缓存方法&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// DiskLruCache#open()
public static DiskLruCache open(File directory, int appVersion, int valueCount, 
        long maxSize) throws IOException {
    /* ... */   
    // prefer to pick up where we left off
    DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, 
            maxSize);
    // 如果已经存在了 journal 文件, 读取头部进行对比
    // 对比失败会删除该缓存目录, 然后再重建一个缓存目录
    if (cache.journalFile.exists()) {
        try {
            // 验证头部, 读取日志中的每一行
            // 跳过 REMOVE 记录, 只保存 READ, DIRTY, CLEAN. 到 LinkedHashMap 中
            // CLEAN 设置 readable = true, 节点每个数据的大小到 lenghts 数组
            // DIRTY 设置 currentEditor = new Editor(entry)
            // READ 不作改变
            cache.readJournal();
            // 
            cache.processJournal();
            cache.journalWriter = new BufferedWriter(
                    new FileWriter(cache.journalFile, true), IO_BUFFER_SIZE);
            return cache;
        } catch (IOException journalIsCorrupt) {
            cache.delete();
        }
    }

    // create a new empty cache
    directory.mkdirs();
    cache = new DiskLruCache(directory, appVersion, valueCount, maxSize);
    cache.rebuildJournal();
    return cache;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;open()&lt;/code&gt; 里即使传入的目录不存在, DiskLruCache 也是会帮我们重建一个缓存目录的. &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// DiskLruCache#rebuildJournal()
private synchronized void rebuildJournal() throws IOException {
    if (journalWriter != null) {
        journalWriter.close();
    }

    // 使用临时 journal 文件来重建缓存, 重建完成后再更名为正式的 journal 文件名
    // 按格式写入头部
    /* ... */

    // 将内存中已经读取的缓存记录写到文件里
    for (Entry entry : lruEntries.values()) {
        if (entry.currentEditor != null) {
            writer.write(DIRTY + ' ' + entry.key + '\n');
        } else {
            writer.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n');
        }
    }
    // 关闭文件, 重命名, 将 journalWriter 指向新文件
    writer.close();
    journalFileTmp.renameTo(journalFile);
    journalWriter = new BufferedWriter(new FileWriter(journalFile, true), IO_BUFFER_SIZE);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;readJournal()&lt;/code&gt;, &lt;code&gt;readJournalLine()&lt;/code&gt;, &lt;code&gt;processJournal()&lt;/code&gt; 这三个方法是重要的操作 journal 文件的方法. &lt;code&gt;readJournal()&lt;/code&gt; 处理好正确的头部匹配, 然后调用  &lt;code&gt;readJournalLine()&lt;/code&gt; 来读取每一行主体内容. 处理的步骤为: 
1. 每读到一个 REMOVE 就删除 &lt;code&gt;lruEntries&lt;/code&gt; 里对应 key 的 entry
2. 如果这一行不为 REMOVE, 并且其不在 &lt;code&gt;lruEntries&lt;/code&gt; 里, 就将为其创建一个 entry 加入到链表中
3. 如果这一行为 CLEAN, 那表示这条数据已确保写到磁盘了, 设置为 &lt;code&gt;readable = true&lt;/code&gt;, &lt;code&gt;currentEditor = null&lt;/code&gt;, 并将该节点的数据大小进行保存
4. 如果这一行为 DIRTY, 表示这条数据有过编辑(&lt;code&gt;DiskLruCache#.edit()&lt;/code&gt;), 为其创建一个编辑器
5. 如果这一行为 READ, 已经在 2 里处理过了&lt;/p&gt;
&lt;p&gt;这样就处理了所有的标记符. 在 &lt;code&gt;processJournal()&lt;/code&gt; 方法里, 删除掉 DIRTY 记录. 因为一条 DIRTY 只对应一条 CLEAN 或 REMOVE, REMOVE 对应的 DIRTY 我们已经在第一次读到时已经删除过. 另外在每次读到 CLEAN 时, 我们都会把其对应的 DIRTY 的 &lt;code&gt;currentEditor&lt;/code&gt; 设置为 &lt;code&gt;null&lt;/code&gt;, 所以只要查找 &lt;code&gt;currentEditor = null&lt;/code&gt; 记录便可&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// DiskLruCache#readJournal()
// 这个方法主要是验证头部正确后, 把日志时的每条记录都读到 lruEntries 中
private void readJournal() throws IOException {
    InputStream in = new BufferedInputStream(new FileInputStream(journalFile), IO_BUFFER_SIZE);
    try {
        // 验证头部, 每次读一行, 分别与传入的值对比
        /* ... */

        // 如果头部无误, 将除 REMOVE 之外的记录读到 lruEntries 中
        int lineCount = 0;
        while (true) {
            try {
                readJournalLine(readAsciiLine(in));
                lineCount++;
            } catch (EOFException endOfJournal) {
                break;
            }
        }
        redundantOpCount = lineCount - lruEnties.size();
    } finally {
        closeQuietly(in);
    }
}


// DiskLruCache#readJournalLine()
private void readJournalLine(String line) throws IOException {
    String[] parts = line.split(" ");
    if (parts.length &amp;lt; 2) {
        throw new IOException("unexpected journal line: " + line);
    }
    // 当读到 REMOVE 表示我们要删除该条对应的 DIRTY 记录
    String key = parts[1];
    if (parts[0].equals(REMOVE) &amp;amp;&amp;amp; parts.length == 2) {
        lruEntries.remove(key);
        return;
    }
    // 过滤掉 REMOVE 匹配的一次 DIRTY 记录后, 剩下的记录都会读到 lruEntries
    Entry entry = lruEntries.get(key);
    if (entry == null) {
        entry = new Entry(key);
        lruEntries.put(key, entry);
    }

    if (parts[0].equals(CLEAN) &amp;amp;&amp;amp; parts.length == 2 + valueCount) {
        // CLEAN 表示保存了文件, 是可读的
        entry.readable = true;
        entry.currentEditor = null;
        // 设置其节点有多少份数据, copyOfRange 同 Arrays.copyOfRange
        entry.setLengths(copyOfRange(parts, 2, parts.length));
    } else if (parts[0].equals(DIRTY) &amp;amp;&amp;amp; parts.length == 2) {
        // 为 DIRTY 记录设置一个可写对象
        entry.currentEditor = new Editor(entry);
    } else if (parts[0].equals(READ) &amp;amp;&amp;amp; parts.length == 2) {
        // this work was already done by calling lruEntries.get()
    } else {
        throw new IOException("unexpected journal line: " + line);
    }
}


// DiskLruCache#processJournal()
// 再把日志的数据都读到 lruEntries 后, 删除其中的 DIRTY 数据
// 因为每一条 DIRTY 至少匹配 REMOVE
private void processJournal() throws IOException {
    deleteIfExists(journalFileTmp);
    for (Iterator&amp;lt;Entry&amp;gt; i = lruEntries.values().iterator(); i.hasNext(); ) {
        Entry entry = i.next();
        if (entry.currentEditor == null) {
            // 删除到记录不正确的 DIRTY 后, 才计算现在使用了多少容量
            for (int t = 0; t &amp;lt; valueCount; t++) {
                size += entry.lengths[t];
            }
        } else {
            // 删除 DIRTY 记录
            entry.currentEditor = null;
            for (int t = 0; t &amp;lt; valueCount; t++) {
                deleteIfExists(entry.getCleanFile(t));
                deleteIfExists(entry.getDirtyFile(t));
            }
            i.remove();
        }
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2.4 写入缓存&lt;/h4&gt;
&lt;p&gt;在将日志记录读到 &lt;code&gt;lruEntries&lt;/code&gt; 后, 便可以进行读写操作. 写操作是获得一个 &lt;code&gt;DiskLruCache#Editor&lt;/code&gt; 对象.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
    // 检测文件没有关闭和 key 的有效性, 不能包含空格和换行: ' ', '\r', '\n'
    checkNotClosed();
    validateKey(key);
    // lruEntries 中取出该记录, 如果不为 null, 说明不是新记录; 并且如果其
    // 保存了 currentEditor 的话说明有其他线程在编辑, 因为我们会把完成的 DIRTY 记录
    // 从 lruEntries 中删除掉
    Entry entry = lruEntries.get(key);
    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER
            &amp;amp;&amp;amp; (entry == null || entry.sequenceNumber != expectedSequenceNumber)) {
        return null; // snapshot is stale
    }
    // 这里要注意如果我们获取了一次 Editor 对象, 再次获取前没有 commit/abort 操作则返回 null
    if (entry == null) {
        entry = new Entry(key);
        lruEntries.put(key, entry);
    } else if (entry.currentEditor != null) {
        return null; // another edit is in progress
    }
    // 获取一个新的编辑状态
    Editor editor = new Editor(entry);
    entry.currentEditor = editor;

    // 写入 DIRTY 状态
    journalWriter.write(DIRTY + ' ' + key + '\n');
    journalWriter.flush();
    return editor;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在拿到 &lt;code&gt;Editor&lt;/code&gt; 对象之后, 便可以获得输出流, 将图片之类写到磁盘作缓存. &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public final class Editor {
    private final Entry entry;
    private boolean hasErrors;

    // 返回的是一个 FilterOutputStream, 如果出错就把标志位 hasErrors 设为 true
    // 在写完后 commit 时检查标志位, 有错误会放弃该缓存
    public OutputStream newOutputStream(int index) throws IOException {
        synchronized (DiskLruCache.this) {
            if (entry.currentEditor != this) {
                throw new IllegalStateException();
            }
            // FileOutputStream 会帮我们自动创建文件
            return new FaultHidingOutputStream(
                    new FileOutputStream(entry.getDirtyFile(index)));
        }
    }

    /* ... */
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用 &lt;code&gt;DiskLruCache.Editor#commit()&lt;/code&gt; 时会调用 &lt;code&gt;DiskLruCache#completeEdit()&lt;/code&gt; 完成最终编辑&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;private synchronized void completeEdit(Editor editor, boolean success) 
        throws IOException {
        // 检查 DIRTY 文件是否创建了
        if (success &amp;amp;&amp;amp; !entry.readable) {
            for (int i = 0; i &amp;lt; valueCount; i++) {
                if (!entry.getDirtyFile(i).exists()) {
                    editor.abort();
                    throw new IllegalStateException("edit didn't create file " + i);
                }
            }
        }
        // 重命名文件, 减去老的缓存大小
        for (int i = 0; i &amp;lt; valueCount; i++) {
            File dirty = entry.getDirtyFile(i);
            if (success) {
                if (dirty.exists()) {
                    File clean = entry.getCleanFile(i);
                    dirty.renameTo(clean);
                    long oldLength = entry.lengths[i];
                    long newLength = clean.length();
                    entry.lengths[i] = newLength;
                    size = size - oldLength + newLength;
                }
            } else {
                deleteIfExists(dirty);
            }
        }
        // 操作行数增加 1
        redundantOpCount++;
        // 操作完成时重置为 null
        entry.currentEditor = null;
        if (entry.readable | success) {
            entry.readable = true;
            journalWriter.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n');
            if (success) {
                // sequenceNumber 用来记录该 entry 是否过期, 在获取 Shapshot 时会与
                // entry.sequenceNumber 对比, 如果不相等则是过期的
                entry.sequenceNumber = nextSequenceNumber++;
            }
        } else {
            lruEntries.remove(entry.key);
            journalWriter.write(REMOVE + ' ' + entry.key + '\n');
        }
        // 判断是否超出设定的缓存容量, 是否操作行数记录大于 2000, 
        // 或者 redundantOpCount &amp;gt; lruEntries.size()
        // 以便来决定是否在释放一些缓存
        if (size &amp;gt; maxSize || journalRebuildRequired()) {
            executorService.submit(cleanupCallable);
        }
    }&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2.5 读取缓存&lt;/h4&gt;
&lt;p&gt;通过 &lt;code&gt;DiskLruCache#get()&lt;/code&gt; 获得一个 &lt;code&gt;Snapshot&lt;/code&gt; 缓存对象. 该对象主要是 &lt;code&gt;InputStream&lt;/code&gt; 的再封装&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// DiskLruCache#get
public synchronized Snapshot  (String key) throws IOException {
    // 检查文件是否打开, key 是否正确
    /* ... */

    // 一次性打开所有的数据以保证一个 key 即使对应多个数据也只有一个 snapshot
    InputStream[] ins = new InputStream[valueCount];
    try {
        for (int i = 0; i &amp;lt; valueCount; i++) {
            ins[i] = new FileInputStream(entry.getCleanFile(i));
        }
    } catch (FileNotFoundException e) {
        // a file must have been deleted manually!
        return null;
    }
    // 记录操作数, 写入操作记录, 之后要再检查操作记录是否超出设定
    redundantOpCount++;
    journalWriter.append(READ + ' ' + key + '\n');
    if (journalRebuildRequired()) {
        executorService.submit(cleanupCallable);
    }

    return new Snapshot(key, entry.sequenceNumber, ins);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2.6 删除缓存&lt;/h4&gt;
&lt;p&gt;每次读, 写, 删除缓存后, 都要再次判断操作记录或者缓存大小已经超出设置的值. 删除操作主要是由一个&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 调用 remove
// DiskLruCache#remove
public synchronized boolean remove(String key) throws IOException {
    checkNotClosed();
    validateKey(key);
    Entry entry = lruEntries.get(key);
    if (entry == null || entry.currentEditor != null) {
        return false;
    }
    // 删除对应 key 的所有文件
    for (int i = 0; i &amp;lt; valueCount; i++) {
        File file = entry.getCleanFile(i);
        if (!file.delete()) {
            throw new IOException("failed to delete " + file);
        }
        size -= entry.lengths[i];
        entry.lengths[i] = 0;
    }
    // 是否要重建 journal 文件
    redundantOpCount++;
    journalWriter.append(REMOVE + ' ' + key + '\n');
    lruEntries.remove(key);

    if (journalRebuildRequired()) {
        executorService.submit(cleanupCallable);
    }

    return true;
}

private final ExecutorService executorService = new ThreadPoolExecutor(0, 1, 60L,
        TimeUnit.SECONDS, new LinkBlockingQueue&amp;lt;Runnable&amp;gt;());
private final Callable&amp;lt;Void&amp;gt; cleanupCallable = new Callable&amp;lt;&amp;gt;() {
    @Override
    public Void call() throw Exception {
        synchronized (DiskLruCache.this) {
            if (journalWriter == null) {
                return null;
            }
            trimeToSize();
            if (journalRebuildRequired()) {
                rebuildJournal();
                redundantOpCount = 0;
            }
            return null;
        }
    }
};

private void trimToSize() throws IOException {
    // 循环迭代删除超出的空间
    while (size &amp;gt; maxSize) {
        final Map.Entry&amp;lt;String, Entry&amp;gt; toEvict = 
            lruEntries.entrySet().iterator.next();
        remove(toEvict.getKey());
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Reference&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&amp;lt;&lt;Android开发艺术探索&gt;&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/shakespeare001/article/details/51695358"&gt;https://blog.csdn.net/shakespeare001/article/details/51695358&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.jianshu.com/p/b282140acc20"&gt;https://www.jianshu.com/p/b282140acc20&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nirvanawoody.com/2016/05/05/Android-DiskLruCache"&gt;http://nirvanawoody.com/2016/05/05/Android-DiskLruCache&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="缓存"></category><category term="磁盘缓存"></category><category term="lru"></category><category term="cache"></category><category term="disk cache"></category></entry><entry><title>Android内存缓存LruCache</title><link href="https://ivicel.info/2018/04/androidnei-cun-huan-cun-lrucache.html" rel="alternate"></link><published>2018-04-04T00:00:00+08:00</published><updated>2018-04-04T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-04-04:/2018/04/androidnei-cun-huan-cun-lrucache.html</id><summary type="html">&lt;h3&gt;1. LruCahe 的使用&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;LruCache&lt;/code&gt; 类的构造方法为 &lt;code&gt;public LruCache(int maxSize)&lt;/code&gt;, 其需要传入一个缓存大小, 单位为 &lt;strong&gt;byte&lt;/strong&gt;, 一般我们会通过计算应用可以使用的最大内存是多少, 然后取其中的一部分作为值来传入. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;传入的内存最大值的&lt;strong&gt;单位&lt;/strong&gt;要和 &lt;code&gt;sizeOf()&lt;/code&gt; 返回的单位一致即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另然最重要的需要重写这个类的 &lt;code&gt;sizeOf()&lt;/code&gt; 方法, 该方法返回值表示了每个元素的大小, 以便确定缓存是否需要删除旧的元素. 这个方法的默认实现是返回 1.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 获得应用可使用的最大内存, 取 1/8 作为缓存
final int maxSize = Runtime.getRuntime().maxMemory() / 8;
LruCache&amp;lt;String, Bitmap&amp;gt; bitmapCache = new LruCache&amp;lt;&amp;gt;(maxSize) {
    @Override
    protected int sizeOf(String …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;h3&gt;1. LruCahe 的使用&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;LruCache&lt;/code&gt; 类的构造方法为 &lt;code&gt;public LruCache(int maxSize)&lt;/code&gt;, 其需要传入一个缓存大小, 单位为 &lt;strong&gt;byte&lt;/strong&gt;, 一般我们会通过计算应用可以使用的最大内存是多少, 然后取其中的一部分作为值来传入. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;传入的内存最大值的&lt;strong&gt;单位&lt;/strong&gt;要和 &lt;code&gt;sizeOf()&lt;/code&gt; 返回的单位一致即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另然最重要的需要重写这个类的 &lt;code&gt;sizeOf()&lt;/code&gt; 方法, 该方法返回值表示了每个元素的大小, 以便确定缓存是否需要删除旧的元素. 这个方法的默认实现是返回 1.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 获得应用可使用的最大内存, 取 1/8 作为缓存
final int maxSize = Runtime.getRuntime().maxMemory() / 8;
LruCache&amp;lt;String, Bitmap&amp;gt; bitmapCache = new LruCache&amp;lt;&amp;gt;(maxSize) {
    @Override
    protected int sizeOf(String key, Bitmap value) {
        // 图片缓存, 返回每个 bitmap 的大小
        // sdk 19 之后不再使用 Bitmap#getByteCount
        // Bitmap#getAllocationByteCount 可能会比 getByteCount 返回的值大
        return value.getAllocationByteCount();
    }
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在获得 &lt;code&gt;LruCache&lt;/code&gt; 对象之后, 便可以对其进行读, 写, 删除&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;Bitmap bitmap = bitmapCache.get(key);
// 如果缓存中已经存在, 那么旧的会被返回, 不存在则返回 null
Bitmap prevBitmap = bitmapCache.put(key, bitmap);
// 删除缓存
Btimap bitmap = bitmap.remove(key);

// 一般图片都是从网络上下载下来, 所以使用图片的 url 来作为 key 值是最好了
// 但 url 会有特殊的字符不能作为 key, 常用的方法是将 url 转为其 md5 值
public String urlToMD5(String url) {
    String key;
    try {
        final MessageDigest md = MessageDigest.getInstance("MD5");
        md.update(url.getBytes());
        key = bytesToHexString(md.digest());
    } catch (NoSuchAlgorithmException e) {
        key = String.valueOf(url.hashCode());
    }
    return key;
}

public String bytesToHexString(byte[] input) {
    // 将 byte 数组转为 16 进制字符
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i &amp;lt; input.length; i++) {
        String hex = Integer.toHexString(0xFF &amp;amp;&amp;amp; input[i]);
        if (hex.lenght() == 1) {
            // 只有一位时在前面补 0
            sb.append("0");
        }
        sb.append(hex);
    }

    return sb.toString();
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外还可以重写 &lt;code&gt;entryRemove()&lt;/code&gt; 方法, 这个方法会在&lt;strong&gt;元素被删除&lt;/strong&gt;(内存不足时, remove 操作时), &lt;strong&gt;元素被替换&lt;/strong&gt;(put 操作时)被调用, 默认的实现是一个空实现, 并且这个调用不是 &lt;code&gt;synchronization&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// @param evicted. 空间不足引起的删除时为 true. put, remove 操作引起的为 false
// @param key 元素的 key
// @param oldValue 元素的旧值
// @param newValue 元素是被替换时的新值, 被删除时该值为 null
protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue);&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2. 源码解析&lt;/h3&gt;
&lt;p&gt;由于需要不断重新排序, &lt;code&gt;LruCache&lt;/code&gt; 内部使用了一个 &lt;code&gt;LinkHashMap&lt;/code&gt; 数据结构来存储实际内容. 这是一个&lt;strong&gt;双向链表&lt;/strong&gt; 实现的 &lt;strong&gt;HashMap&lt;/strong&gt;. &lt;code&gt;LinkHashMap&lt;/code&gt;可以设置成&lt;strong&gt;基于插入顺序优先&lt;/strong&gt;, 或者&lt;strong&gt;基于访问顺序优先&lt;/strong&gt;, 把优先的元素放在链表&lt;strong&gt;末端&lt;/strong&gt;, 这样链表头结点总是表示&lt;strong&gt;最后插入&lt;/strong&gt;/&lt;strong&gt;最少访问&lt;/strong&gt;的元素, 可以把头结点从链接中删除&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-Java"&gt;public class LruCache&amp;lt;K, V&amp;gt; {
    public LruCache(int maxSize) {
        if (maxSize) {
            throw new IllegalArgumentException("maxSize &amp;lt;= 0");   
        }
        this.maxSize = maxSize;
        // 第一个参数为初始容量, 第二个为 map 的负载因子, 第三个为是否基于访问顺序
        this.map = new LinkHashMap&amp;lt;K, V&amp;gt;(0, 0.75f, true);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在每次 &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt; 之后, 都要使用 &lt;code&gt;trimToSize()&lt;/code&gt; 来确保使用的内存容量是在规定的范围内&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 传的参数是最大内存容量, 如果大于这个数, 就把头结点从链表中删除
public void trimToSize(int maxSize) {
    // 不断循环的删除头结点, 直到使用的内存小于 maxSize
    while (true) {
        K key;
        V value;
        synchronized (this) {
            // size 为当前使用的缓存容量
            if (size &amp;lt; 0 || (map.isEmpty() &amp;amp;&amp;amp; size != 0)) {
                throw new IllegalStateException(getClass().getName() + 
                    ".sizeOf() is reporting inconsistent results!");
            }

            // 当现使用的容量 &amp;lt;= 最大容量时退出循环
            if (size &amp;lt;= maxSize) {
                break;
            }

            // LinkHashMap#eldest() 方法是 Android 实现 LinkHashMap 时添加的方法
            // 其简单的返回了链表头结点
            Map.Entry&amp;lt;K, V&amp;gt; toEvict = map.eldest();
            if (toEvict == null) {
                break;
            }

            // 删除头结点, 并把现使用的内存容量减小
            key = toEvict.getKey();
            value = toEvict.getValue();
            map.remove(key);
            // safeSizeOf 只是对 sizeOf 的再次封装, 其只是返回 sizeOf 并确保该值不能 &amp;lt; 0
            size -= safeSizeOf(key, value);
            // 记录收回的元素数量
            evictionCount++;
        }

        // 调用
        entryRemoved(true, key, value, null);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;LruCache#put()&lt;/code&gt;, &lt;code&gt;LruCache#get()&lt;/code&gt;方法的实现&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// LruCache#put()
public final V put(K key, V value) {
    if (key == null || value == null) {
        throw new NullPointerException("key == null || value == null");
    }

    // 如果添加进去的新的元素已经在内存中的话, 更新之后, 再减去旧的元素的大小
    V previous;
    synchronized (this) {
        putCount++;
        size += safeSizeOf(key, value);
        previous = map.put(key, value);
        if (previous != null) {
            size -= safeSizeOf(key, previous);
        }
    }

    if (previous != null) {
        entryRemoved(false, key, previous, value);
    }
    // 保证内存大小不超过设定
    trimToSize(maxSize);

    return previous;
}

// LruCache#get()
public final V get(K key) {
    if (key == null) {
        throw new NullPointerException("key == null");
    }

    V mapValue;
    synchronized (this) {
        // 查找链表中的元素, 如果找到了就返回该值
        mapValue = map.get(key);
        if (mapValue != null) {
            hitCount++;
            return mapValue;
        }
        missCount++;
    }

    // 如果对应值不存在的话, 调用 create() 方法尝试新建一个
    // create() 方法非线程安全, 可能会在调用的时候, 其他的线程又对该 key 进行操作
    /*
     * Attemp to create a value. This may take a long time, and the map
     * may be different when create() returns. If a conflicting value was
     * added to the map while create() was working, we leave that value in
     * the map and release the created value
     */
    V createdValue = create();
    if (createValue == null) {
        return null;
    }

    // 如果重写了 create() 并返回非 null
    // 之后我们要重新查看下缓存之中是不是有了该 key
    synchronized (this) {
        createCount++;
        mapValue = map.put(key, createdValue);;
        // 如果有了该 key 的值, 不要对其做更改
        if (mapValue != null) {
            // There was a conflict so undo that last put
            map.put(mapValue);
        } else {
            size += safeSizeOf(key, createdValue);
        }
    }

    if (mapValue != null) {
        entryRemoved(false, key, createdValue, mapValue);
        return mapValue;
    } else {
        trimeToSize(maxSize);
        return createdValue;
    }
}

// LruCache#create(), 默认返回 null
protected V create(K key) {
    return null;
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Reference:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&amp;lt;&lt;Android开发艺术探索&gt;&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/shakespeare001/article/details/51695358"&gt;https://blog.csdn.net/shakespeare001/article/details/51695358&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="缓存"></category><category term="lrucache"></category></entry><entry><title>AIDL生成的接口及Binder的分析</title><link href="https://ivicel.info/2018/04/aidlsheng-cheng-de-jie-kou-ji-binderde-fen-xi.html" rel="alternate"></link><published>2018-04-01T00:00:00+08:00</published><updated>2018-04-01T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-04-01:/2018/04/aidlsheng-cheng-de-jie-kou-ji-binderde-fen-xi.html</id><summary type="html">&lt;h3&gt;1. Android 上的 Binder&lt;/h3&gt;
&lt;p&gt;在原 Linux 上已经有各种 IPC , 管道, 信号, 信号量,  Socket, 共享内存, 互斥锁. 但 Binder 能在 Android 这个特定的平台上会比其他更&lt;strong&gt;高效&lt;/strong&gt;, 也更&lt;strong&gt;安全&lt;/strong&gt;, 其他&lt;code&gt;IPC&lt;/code&gt;没有严格权限验证机制&lt;/p&gt;
&lt;h4&gt;1.1 Binder 的构架&lt;/h4&gt;
&lt;p&gt;​        Binder 通信是基于 &lt;strong&gt;C/S 构架&lt;/strong&gt;. 多个 C 端可以同步连接 S 端, 所以 S 端需要&lt;strong&gt;同步&lt;/strong&gt;设置&lt;/p&gt;
&lt;p&gt;&lt;img alt="binder架构" src="../../assets/images/binder架构.jpg" /&gt;&lt;/p&gt;
&lt;h4&gt;1-2 Binder 的机制&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;服务端向内核注册服务, 内核生成&lt;code&gt;binder_proc …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h3&gt;1. Android 上的 Binder&lt;/h3&gt;
&lt;p&gt;在原 Linux 上已经有各种 IPC , 管道, 信号, 信号量,  Socket, 共享内存, 互斥锁. 但 Binder 能在 Android 这个特定的平台上会比其他更&lt;strong&gt;高效&lt;/strong&gt;, 也更&lt;strong&gt;安全&lt;/strong&gt;, 其他&lt;code&gt;IPC&lt;/code&gt;没有严格权限验证机制&lt;/p&gt;
&lt;h4&gt;1.1 Binder 的构架&lt;/h4&gt;
&lt;p&gt;​        Binder 通信是基于 &lt;strong&gt;C/S 构架&lt;/strong&gt;. 多个 C 端可以同步连接 S 端, 所以 S 端需要&lt;strong&gt;同步&lt;/strong&gt;设置&lt;/p&gt;
&lt;p&gt;&lt;img alt="binder架构" src="../../assets/images/binder架构.jpg" /&gt;&lt;/p&gt;
&lt;h4&gt;1-2 Binder 的机制&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;服务端向内核注册服务, 内核生成&lt;code&gt;binder_proc&lt;/code&gt;的数据结构信息&lt;/li&gt;
&lt;li&gt;注册之后客户端便可以获取到服务代理, 进而跟服务端通信&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;WindowManager wm = (WindowManager)getSystemService(Context.WINDOW_SERVICE)&lt;/code&gt;
* 这些都是在 native 和内核层帮助我们转换完成&lt;/p&gt;
&lt;p&gt;&lt;img alt="binder机制" src="../../assets/images/binder机制.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;层的&lt;code&gt;Binder&lt;/code&gt;主要与几个类(&lt;code&gt;Binder&lt;/code&gt;, &lt;code&gt;BinderProxy&lt;/code&gt;, &lt;code&gt;Stub&lt;/code&gt;)和接口(&lt;code&gt;IBinder&lt;/code&gt;, &lt;code&gt;IInterface)&lt;/code&gt;有关&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;IBinder&lt;/code&gt;接口代表了&lt;strong&gt;一种跨进程传输的能力&lt;/strong&gt;, 只能类实现了这个接口, 表示能将该类对象进行跨进程传递. 这是由&lt;code&gt;Android&lt;/code&gt;底层来实现支持的. 系统会对传输的数据(即&lt;code&gt;IBinder&lt;/code&gt;对象)进行本地和代理间的转换.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IInterface&lt;/code&gt;代表的是传输的&lt;code&gt;IBinder&lt;/code&gt;对象具有什么能力. &lt;code&gt;AIDL&lt;/code&gt;中自定义接口就是继承该接口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Binder&lt;/code&gt;类是内部对&lt;code&gt;IBinder&lt;/code&gt;的实现, 代表&lt;strong&gt;本地的对象&lt;/strong&gt;.&lt;code&gt;BinderProxy&lt;/code&gt;是&lt;code&gt;Binder&lt;/code&gt;的内部类, 代表着&lt;strong&gt;远程进程&lt;/strong&gt;的&lt;code&gt;Binder&lt;/code&gt;对象的本地代理&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;AIDL&lt;/code&gt;中, 系统会给生成一个静态的内部类&lt;code&gt;Stub&lt;/code&gt;. 继承了&lt;code&gt;Binder&lt;/code&gt;同时实现了&lt;code&gt;IInterface&lt;/code&gt;接口. 这说明这是一个本地的&lt;code&gt;Binder&lt;/code&gt;, 并且可以作为远程&lt;code&gt;Server&lt;/code&gt;来给&lt;code&gt;Client&lt;/code&gt;传递数据的能力. 其内部真正使用&lt;strong&gt;策略模式&lt;/strong&gt;来交给&lt;code&gt;Stub.Proxy&lt;/code&gt;处理数据的交换&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2. AIDL 文件实现分析&lt;/h3&gt;
&lt;p&gt;在系统自动生成的&lt;code&gt;BookManager.java&lt;/code&gt;中, 主要结构:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BookManager&lt;/code&gt;扩展&lt;code&gt;andorid.os.IInterface&lt;/code&gt;接口&lt;/li&gt;
&lt;li&gt;两个内部静态类&lt;code&gt;Stub&lt;/code&gt;, &lt;code&gt;Proxy&lt;/code&gt;内部类分别实现&lt;code&gt;BookManager&lt;/code&gt;接口. 但&lt;code&gt;Stub&lt;/code&gt;是一个抽象类. 其具体实现由&lt;code&gt;server&lt;/code&gt;端来实现. 在&lt;code&gt;client&lt;/code&gt;中请求&lt;code&gt;server&lt;/code&gt;返回的实例里, 由&lt;code&gt;Stub#Proxy&lt;/code&gt;代理去向&lt;code&gt;server&lt;/code&gt;做出请求连接&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;BookManager.Stub.asInterface()&lt;/code&gt;方法返回&lt;code&gt;BookManager&lt;/code&gt;实例, 实际就是内部&lt;code&gt;Proxy&lt;/code&gt;代理类的实现&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BookManager.Stub.asBinder()&lt;/code&gt;方法, 返回当前的&lt;code&gt;binder&lt;/code&gt;对象&lt;/li&gt;
&lt;li&gt;当在&lt;code&gt;client&lt;/code&gt;请求&lt;code&gt;BookManger&lt;/code&gt;的方法时, 调用&lt;code&gt;Proxy&lt;/code&gt;内对应实现的方法. 方法内部调用了&lt;code&gt;Binder#transact()&lt;/code&gt;. &lt;code&gt;transact()&lt;/code&gt;在内部调用了&lt;code&gt;IBinder#onTransact()&lt;/code&gt;. 由于&lt;code&gt;mRemote&lt;/code&gt;是&lt;code&gt;Stub&lt;/code&gt;的实例, 这便是调用了&lt;code&gt;Stub#onTransact()&lt;/code&gt;方法. 在&lt;code&gt;Stub#onTransact()&lt;/code&gt;中对在&lt;code&gt;AIDL&lt;/code&gt;里定义的&lt;code&gt;tag&lt;/code&gt;(&lt;code&gt;in&lt;/code&gt;,&lt;code&gt;out&lt;/code&gt;, &lt;code&gt;inout&lt;/code&gt;)作出判断, 然后操作数据的流向&lt;/li&gt;
&lt;li&gt;从&lt;code&gt;onTransact()&lt;/code&gt;返回后, 依据&lt;code&gt;aidl&lt;/code&gt;定义向&lt;code&gt;client&lt;/code&gt;, &lt;code&gt;server&lt;/code&gt;两方读或写入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;client&lt;/code&gt;在调用&lt;code&gt;server service&lt;/code&gt;时进行休闲, 直到&lt;code&gt;server&lt;/code&gt;端调用结束返回唤醒&lt;code&gt;client&lt;/code&gt;. 所以如果&lt;code&gt;server&lt;/code&gt;的调用耗时很久, 不要在&lt;code&gt;client&lt;/code&gt;的&lt;code&gt;UI&lt;/code&gt;线程调用, 以免导致 &lt;strong&gt;ANR&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public interface BookManager extends IInterface {
    public static abstract class Stub extends Binder implements BookManager {
        // 描述符, 用于在 binder 连接池中查找对应的 binder
        private static final java.lang.String DESCRIPTOR = "info.ivicel.github.aidldemo.BookManager";

        // 根据 aidl 中定义的方法生成其对应的 id, 默认1, 2, 3, 4....
        static final int TRANSACTION_getBooks = (FIRST_CALL_TRANSACTION + 0);
        static final int TRANSACTION_getBook = (FIRST_CALL_TRANSACTION + 1);
        // ...


        // 该方法内部有判断 server 和 client 是否在同一进程,
        // 不是的话才会远程调用 transact() 方法
        public static BookManager asInterface(IBinder obj) {
            // ....

            // 从返回值中可以看出实际是返回一个内部的代理实现, 由其向 server 提交请求
            return new BookManager.Stub.Proxy(obj);
        }

        //
        public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
            switch (code) {
                // ....
                // 对应的 inout 模式
                case TRANSACTION_addBookInout: {
                    // **************** in 模式的流程 *********
                    // 检查描述符标志
                    data.enforceInterface(DESCRIPTOR);
                    info.ivicel.github.aidldemo.Book _arg0;
                    // 读
                    if ((0 != data.readInt())) {
                        _arg0 = Book.CREATOR.createFromParcel(data);
                    } else {
                        _arg0 = null;
                    }
                    // *****************
                    // ***************** 方法有返回值时, 先把返回值写入
                    Book _result = this.addBookInout(_arg0);
                    reply.writeNoException();
                    if ((_result != null)) {
                        reply.writeInt(1);
                        _result.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                    } else {
                        reply.writeInt(0);
                    }
                    // ****** out 模式时流程
                    if ((_arg0 != null)) {
                        reply.writeInt(1);
                        _arg0.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
                    } else {
                        reply.writeInt(0);
                    }
                    return true;
                }
            }
            // ....
        }

        private static class Proxy implements BookManager {
            // 实现 aidl 中自定义的方法, 实际上是一个代理, 会内部调用 server 真正的业务实现
            public int getBookCount() throws RemoteException;
            // ....
            @Override
            public Book addBookInout(Book book) throws RemoteException {
                // 用来保存 client -&amp;gt; server 的数据存储空间
                android.os.Parcel _data = android.os.Parcel.obtain();
                // 用来保存 server -&amp;gt; client 的数据存储空间
                android.os.Parcel _reply = android.os.Parcel.obtain();
                // 方法的返回的结果
                info.ivicel.github.aidldemo.Book _result;
                try {
                    // 写入标志位, 在 onTransact 用来核对数据来源正确
                    // 如果 out 模式, 就不用向 _data 写入数据了
                    // 反之如果是 in 模式, 也不用从 _reply 读回数据了
                    // 这两种模式, 对应的 onTransact 方法也没有进行操作
                    // 另外, 读写的顺序要规定好
                    _data.writeInterfaceToken(DESCRIPTOR);
                    if ((book != null)) {
                        // client 传入的 book 不为空时, 将数据写入 _data 中
                        // 先写入一个标志位, 1 表示有数据
                        _data.writeInt(1);
                        book.writeToParcel(_data, 0);
                    } else {
                        // 空数据时, 标志位为 0
                        _data.writeInt(0);
                    }
                    // 这将调用系统中对应的 binder 的 onTransact 方法
                    // 这个查找 binder 过程是由底层的 C++ 方法实现的
                    // 这个方法返回后, 便可以在 _reply 中查找 server 对数据的变更
                    mRemote.transact(Stub.TRANSACTION_addBookIn, _data, _reply, 0);
                    // 检查结果是否有错误
                    _reply.readException();
                    // 检查标志位, 约定都是: 非 0 无错误
                    if ((0 != _reply.readInt())) {
                        // 把结果读到 _result 里
                        _result = Book.CREATOR.createFromParcel(_reply);
                    } else {
                        _result = null;
                    }
                    // 因为是 inout 模式, 还要对传入的参数作出变更
                    // 每读一个数据前, 都有一个标志位表示是否成功
                    if ((0 != _reply.readInt())) {
                        book.readFromParcel(_reply);
                    }
                } finally {
                    // 释放资源
                    _reply.recycle();
                    _data.recycle();
                }
                return _result;
            }
        }
    }

    // aidl 中自定义的方法.....
    public int getBookCount() throws RemoteException;
    // ......
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;AIDL&lt;/code&gt; 的工作机制&lt;/p&gt;
&lt;p&gt;&lt;img alt="AIDL里的Binder工作流程" src="../../assets/images/aidl_binder工作机制.jpeg" /&gt;&lt;/p&gt;
&lt;p&gt;代码地址: &lt;a href="https://github.com/ivicel/dev-android-samples/tree/master/AIDL-Demo"&gt;GitHub&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Reference:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/freekiteyu/article/details/70082302"&gt;https://blog.csdn.net/freekiteyu/article/details/70082302&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/luoyanglizi/article/details/51958091"&gt;https://blog.csdn.net/luoyanglizi/article/details/51958091&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="aidl"></category><category term="源代码阅读"></category><category term="android"></category></entry><entry><title>Android Activity生命周期和启动模式</title><link href="https://ivicel.info/2018/04/android-activitysheng-ming-zhou-qi-he-qi-dong-mo-shi.html" rel="alternate"></link><published>2018-04-01T00:00:00+08:00</published><updated>2018-04-01T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-04-01:/2018/04/android-activitysheng-ming-zhou-qi-he-qi-dong-mo-shi.html</id><summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3&gt;1. Activity 的生命周期&lt;/h3&gt;
&lt;p&gt;一般 &lt;code&gt;Activity&lt;/code&gt; 生命周期为 &lt;code&gt;onCreate()&lt;/code&gt; -&amp;gt; &lt;code&gt;onStart()&lt;/code&gt; -&amp;gt; &lt;code&gt;onResume()&lt;/code&gt; -&amp;gt; &lt;code&gt;onPause()&lt;/code&gt; -&amp;gt; &lt;code&gt;onStop()&lt;/code&gt; -&amp;gt; &lt;code&gt;onDestroy()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;官方的生命周期图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Activity Life Cycle" src="../../assets/images/activity_lifecycle.png" /&gt;&lt;/p&gt;
&lt;p&gt;需要注意的几个点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当一个 &lt;code&gt;Activity&lt;/code&gt; &lt;strong&gt;A&lt;/strong&gt; 启动加一个 &lt;code&gt;Activity&lt;/code&gt; &lt;strong&gt;B&lt;/strong&gt; 时, 只有 &lt;strong&gt;A&lt;/strong&gt; 的 &lt;code&gt;onPause&lt;/code&gt; 执行完返回时, &lt;strong&gt;B&lt;/strong&gt; 才开始执行&lt;code&gt;onCreate&lt;/code&gt; &lt;code&gt;onStart&lt;/code&gt;, 直到 &lt;code&gt;onResume&lt;/code&gt;显示在前台, &lt;strong&gt;A&lt;/strong&gt; 会执行 &lt;code&gt;onStop&lt;/code&gt; &lt;code&gt;onDestroy&lt;/code&gt;, 所以在 &lt;code&gt;onPause&lt;/code&gt;不能执行太&lt;strong&gt;耗时&lt;/strong&gt;的操作, 以便让另一个 &lt;code&gt;Activity&lt;/code&gt; 快点显示到前台&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Activity&lt;/code&gt; 会在应用发生变更时(常见的屏幕旋转, 输入框显示 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3&gt;1. Activity 的生命周期&lt;/h3&gt;
&lt;p&gt;一般 &lt;code&gt;Activity&lt;/code&gt; 生命周期为 &lt;code&gt;onCreate()&lt;/code&gt; -&amp;gt; &lt;code&gt;onStart()&lt;/code&gt; -&amp;gt; &lt;code&gt;onResume()&lt;/code&gt; -&amp;gt; &lt;code&gt;onPause()&lt;/code&gt; -&amp;gt; &lt;code&gt;onStop()&lt;/code&gt; -&amp;gt; &lt;code&gt;onDestroy()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;官方的生命周期图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Activity Life Cycle" src="../../assets/images/activity_lifecycle.png" /&gt;&lt;/p&gt;
&lt;p&gt;需要注意的几个点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当一个 &lt;code&gt;Activity&lt;/code&gt; &lt;strong&gt;A&lt;/strong&gt; 启动加一个 &lt;code&gt;Activity&lt;/code&gt; &lt;strong&gt;B&lt;/strong&gt; 时, 只有 &lt;strong&gt;A&lt;/strong&gt; 的 &lt;code&gt;onPause&lt;/code&gt; 执行完返回时, &lt;strong&gt;B&lt;/strong&gt; 才开始执行&lt;code&gt;onCreate&lt;/code&gt; &lt;code&gt;onStart&lt;/code&gt;, 直到 &lt;code&gt;onResume&lt;/code&gt;显示在前台, &lt;strong&gt;A&lt;/strong&gt; 会执行 &lt;code&gt;onStop&lt;/code&gt; &lt;code&gt;onDestroy&lt;/code&gt;, 所以在 &lt;code&gt;onPause&lt;/code&gt;不能执行太&lt;strong&gt;耗时&lt;/strong&gt;的操作, 以便让另一个 &lt;code&gt;Activity&lt;/code&gt; 快点显示到前台&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Activity&lt;/code&gt; 会在应用发生变更时(常见的屏幕旋转, 输入框显示/隐藏, 屏幕大小变化[&lt;strong&gt;SDK13之后&lt;/strong&gt;]),  还有在 &lt;code&gt;onPause()&lt;/code&gt; &lt;code&gt;onStop()&lt;/code&gt; 中被系统收回内存, 如上图左边. 此时也会重建 &lt;code&gt;onCreate()&lt;/code&gt;. 
   可以在 &lt;code&gt;Manifest.xml&lt;/code&gt;中设置&lt;code&gt;androi:configChanges="&lt;/code&gt;来表示发生行为变更时不重建. 
   常见的设置有:
   &lt;code&gt;orientation&lt;/code&gt;表示屏幕旋转
   &lt;code&gt;keyboardHidden&lt;/code&gt;表示键盘显示/隐藏
   &lt;code&gt;screenSize&lt;/code&gt;表示屏幕大小发生变化(&lt;strong&gt;SDK13&lt;/strong&gt;以上的要加上这个才有效)
   &lt;code&gt;locale&lt;/code&gt;表示本地位置发生了改变&lt;/li&gt;
&lt;li&gt;如果使用 &lt;code&gt;onSaveInstanceState(Bundle)&lt;/code&gt; 保存了一些数据, 便可以在 &lt;code&gt;onCreate(Bundle)&lt;/code&gt; 和 &lt;code&gt;onRestoreInstanceState(Bundle)&lt;/code&gt;中获得到这些数据, 惟一的区别是, 如果没有调用 &lt;code&gt;onSaveInstanceState(Bundle)&lt;/code&gt; 的话, &lt;code&gt;onCreate(Bundle)&lt;/code&gt; 中为 &lt;code&gt;null&lt;/code&gt;, 并且 &lt;code&gt;onRestoreInstanceState(Bundle)&lt;/code&gt; 不会被调用; 一但&lt;code&gt;onRestoreInstanceState(Bundle)&lt;/code&gt; 被调用,  其参数一定不为 &lt;code&gt;null&lt;/code&gt;, 并且&lt;code&gt;onSaveInstanceState()&lt;/code&gt;调用的时机只能确定一定在&lt;code&gt;onDestory()&lt;/code&gt;前被调用, 但是不确定是在&lt;code&gt;onStop()&lt;/code&gt;之前或之后; 官方推荐在 &lt;code&gt;onRestoreInstanceState(Bundle)&lt;/code&gt;中操作数据. 
   如果设置了发生行为变更时不重建&lt;code&gt;Activity&lt;/code&gt;, 则只会调用&lt;code&gt;onConfigurationChanged()&lt;/code&gt;方法, 而不会调用&lt;code&gt;onSaveInstanceState()&lt;/code&gt;和&lt;code&gt;onRestoreInstanceState()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上图只是一般的&lt;code&gt;Activity&lt;/code&gt;生命周期, 而一但加入&lt;code&gt;Fragment&lt;/code&gt;, 情况会变得更加的复杂&lt;/p&gt;
&lt;p&gt;完整的&lt;code&gt;Fragment&lt;/code&gt;和&lt;code&gt;Activity&lt;/code&gt;生命周期图&lt;/p&gt;
&lt;p&gt;&lt;img alt="Activity with Fragment life cycler" src="../../assets/images/complete_android_fragment_lifecycle.png" /&gt;&lt;/p&gt;
&lt;h3&gt;2. Activity 的启动模式&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Activity&lt;/code&gt;一共有四种启动模式. 应用程序都会有一个默认的&lt;strong&gt;任务栈&lt;/strong&gt;, 其名字默认为&lt;strong&gt;包名&lt;/strong&gt;, 任务栈采取&lt;strong&gt;后进先出LIFO&lt;/strong&gt;, 可能通过设置&lt;code&gt;Manifest.xml&lt;/code&gt;中&lt;code&gt;Activity&lt;/code&gt;的&lt;code&gt;android:taskAffinity="包名.task_name"&lt;/code&gt;来指定任务栈. &lt;code&gt;Activity&lt;/code&gt;启动模式可以在&lt;code&gt;xml&lt;/code&gt;中配置, 也可以在&lt;code&gt;java&lt;/code&gt;代码中启动时设置(&lt;strong&gt;除&lt;code&gt;singleInstance&lt;/code&gt;外&lt;/strong&gt;), 运行时在&lt;code&gt;java&lt;/code&gt;中指定优先级高于配置文件中的.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;standard&lt;/code&gt;默认的标准模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;默认的&lt;code&gt;Activity&lt;/code&gt;启动时的模式, 无论是否有这个实例, 都会新生成一个实例压入栈中. 在这个模式中,假如使用 &lt;strong&gt;B&lt;/strong&gt; 启动了 &lt;strong&gt;A&lt;/strong&gt;(为&lt;code&gt;standard&lt;/code&gt;模式), &lt;strong&gt;A&lt;/strong&gt; 是进入到 &lt;strong&gt;B&lt;/strong&gt; 的&lt;strong&gt;任务栈&lt;/strong&gt;吕. 所以当我们使用&lt;code&gt;ApplicationContext&lt;/code&gt;启动一个&lt;code&gt;Activity&lt;/code&gt;时会发生&lt;code&gt;RuntimeException&lt;/code&gt;:&lt;strong&gt;Calling startActivity from outside of an activity context require the &lt;code&gt;FLAG_ACTIVITY_NEW_TASK&lt;/code&gt; flag&lt;/strong&gt;, 表明&lt;code&gt;ApplicationContext&lt;/code&gt;是没有任务栈的, 要想从&lt;code&gt;ApplicationContext&lt;/code&gt;启动一个&lt;code&gt;Activity&lt;/code&gt;需要为其设置一个新的任务栈标志&lt;code&gt;FLAG_ACTIVITY_NEW_TASK&lt;/code&gt;. 但这是一个很不好的编程行为, 不推荐&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;singleTop&lt;/code&gt; 栈顶复用模式
   该模式主要是指&lt;code&gt;Activity&lt;/code&gt;如果已经处于&lt;strong&gt;栈顶&lt;/strong&gt;, 便不会再次新创建新的&lt;code&gt;Activity&lt;/code&gt;入栈. 此时不会调用&lt;code&gt;onCreate()&lt;/code&gt;方法而是调用&lt;code&gt;onNewIntent()&lt;/code&gt;方法. 需要注意的是, 新的&lt;code&gt;Activity&lt;/code&gt;的任务栈名称. 比如在任务栈 A 中是栈顶, 而在 B 不是, 此时要入的栈是 B, 那么还是要新创建再入栈. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;singelTask&lt;/code&gt; 栈内复用模式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;指的是如果要入栈的里头已经有了该 &lt;code&gt;Activity&lt;/code&gt; 的实例, 则不会新创建实例. 而是把 &lt;code&gt;Activty&lt;/code&gt; "上头"的其他 &lt;code&gt;Activity&lt;/code&gt; 出栈, 使其位于栈顶. 所以这个模式自带一个 &lt;strong&gt;&lt;code&gt;clearTop&lt;/code&gt;&lt;/strong&gt; 光环(标志位 &lt;code&gt;FLAG_ACTIVITY_CLEAR_TOP&lt;/code&gt;), 清除"头顶"的 &lt;code&gt;Activity&lt;/code&gt;.当不创建新的实例时, 也是调用其&lt;code&gt;onNewIntent()&lt;/code&gt;方法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是, &lt;code&gt;singleTask&lt;/code&gt;也&lt;strong&gt;受到其配置的任务栈名称限制&lt;/strong&gt;, 并不是创建了新的实例时就一定会创建新的任务栈. 要看配置以及任务是否已经存在. 这是一个容易搞混的地方.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;singleInstance&lt;/code&gt; 单实例模式
   一种加强版的&lt;code&gt;singleTask&lt;/code&gt;模式. 也自带&lt;code&gt;clearTop&lt;/code&gt;. 在配置文件中设置, 自己在一个任务栈中, 调用时时只用生成一次实例, 之后会复用这个实例. &lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;当&lt;code&gt;taskInffinity&lt;/code&gt;和&lt;code&gt;allowTaskReparentint&lt;/code&gt;结合使用时, &lt;code&gt;Activity&lt;/code&gt;会任务栈中跳转走.&lt;/p&gt;
&lt;p&gt;比如, 应用 &lt;code&gt;A&lt;/code&gt;调用应用&lt;code&gt;B&lt;/code&gt;的&lt;code&gt;Activity C&lt;/code&gt;, 此时返回桌面, 点&lt;code&gt;B&lt;/code&gt;启动时, 会进入&lt;code&gt;C&lt;/code&gt;而不是默认的主界面, 相当&lt;code&gt;A&lt;/code&gt;中任务栈里的&lt;code&gt;C&lt;/code&gt;并"拿到"了&lt;code&gt;B&lt;/code&gt;里面&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;3. Intent 的过滤规则&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;intent-filter&lt;/code&gt;需要匹配&lt;code&gt;action&lt;/code&gt;, &lt;code&gt;category&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt;三个项目. 可以混搭写, 同时匹配多个不同的. 还可以同时有多个&lt;code&gt;intent-filter&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;intent-filter&amp;gt;
    &amp;lt;action android:name="android.intent.action.SEND"/&amp;gt;
    &amp;lt;action android:name="android.intent.action.SEND_MULTIPLE"/&amp;gt;
    &amp;lt;category android:name="android.intent.category.DEFAULT"/&amp;gt;
    &amp;lt;data android:mimeType="application/vnd.google.panorama360+jpg"/&amp;gt;
    &amp;lt;data android:mimeType="image/*"/&amp;gt;
&amp;lt;/intent-filter&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;action&lt;/code&gt;的匹配区分大小写, 可以有多个&lt;code&gt;action&lt;/code&gt;, 匹配&lt;code&gt;Intent&lt;/code&gt;时只要有一个能匹配即可&lt;/li&gt;
&lt;li&gt;&lt;code&gt;category&lt;/code&gt;的匹配规则时, 如果写的&lt;code&gt;Intent&lt;/code&gt;中出现的&lt;code&gt;category&lt;/code&gt;, 那么每一个&lt;code&gt;category&lt;/code&gt;都要在过滤规则&lt;code&gt;intent-filter&lt;/code&gt;中有相应的匹配. &lt;code&gt;Intent&lt;/code&gt;中也可以没有&lt;code&gt;category&lt;/code&gt;这样系统会为其添加一个&lt;code&gt;android.intent.category.DEFAULT&lt;/code&gt;的&lt;code&gt;category&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt;的匹配规则: 只要有一条能匹配上即可&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;data&lt;/code&gt;的语法:&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;data
      android:scheme="string"
      android:host="string"
      andorid:port="string"
      android:path="string"
      android:pathPattern="string"
      android:pathPrefix="string"
      andorid:mimeType="string"/&amp;gt;

&amp;lt;scheme&amp;gt;://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/[&amp;lt;path&amp;gt;|&amp;lt;pathPrefix&amp;gt;|&amp;lt;pathPattern&amp;gt;]
context://info.ivicel.github.hello_android/table1&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;要在&lt;code&gt;java&lt;/code&gt;代码中设置&lt;code&gt;Intent&lt;/code&gt;的&lt;code&gt;Data&lt;/code&gt;时要使用&lt;code&gt;setDataAndType()&lt;/code&gt;, 不能使用&lt;code&gt;setData()&lt;/code&gt;再&lt;code&gt;setType()&lt;/code&gt;, 因为这两个方法会彼此清除对方的值&lt;/p&gt;
&lt;p&gt;&lt;scheme&gt;的值只能是&lt;code&gt;file://&lt;/code&gt;或者&lt;code&gt;content://&lt;/code&gt;开头&lt;/p&gt;
&lt;p&gt;启动器的过滤器为:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;action android:name="android.intent.action.MAIN"/&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;category android:name="android.intent.category.LAUNCHER"/&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Reference:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Android 开发艺术探索&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/reference/android/app/Activity.html"&gt;https://developer.android.com/reference/android/app/Activity.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="activity"></category><category term="android"></category></entry><entry><title>Android 对象序列化方式</title><link href="https://ivicel.info/2018/04/android-dui-xiang-xu-lie-hua-fang-shi.html" rel="alternate"></link><published>2018-04-01T00:00:00+08:00</published><updated>2018-04-01T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-04-01:/2018/04/android-dui-xiang-xu-lie-hua-fang-shi.html</id><summary type="html">&lt;p&gt;&lt;code&gt;Android&lt;/code&gt;内序列化对象主要有两种方式, 一是原&lt;code&gt;Java&lt;/code&gt;自带的&lt;code&gt;Serializable&lt;/code&gt;接口, 二是&lt;code&gt;Android&lt;/code&gt;内自有的&lt;code&gt;Parcelable&lt;/code&gt;接口&lt;/p&gt;
&lt;h3&gt;1. &lt;code&gt;Serializable&lt;/code&gt;接口&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;自带的序列接口使用非常简单, 只要实现&lt;code&gt;Serializable&lt;/code&gt;接口即可. &lt;code&gt;Serializable&lt;/code&gt;接口只是一个标志类, 系统会将实现了这个接口的类自动进行序列化. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果想自定义序列化/反序列化过程, 可以自主实现&lt;code&gt;writeObject()&lt;/code&gt;和&lt;code&gt;readObject()&lt;/code&gt;. 一般我们都不会这么做的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还可以定义一个&lt;code&gt;long serialVersionUID&lt;/code&gt;来检测反序列时的数据. 如果值不一样, 反序列时出抛出错误. 这个值可以使用&lt;code&gt;Android Studio&lt;/code&gt;自动生成, 也可以手工指定一个. 数值不论如何, 其本质是一样的.&lt;/p&gt;
&lt;p&gt;实现&lt;code&gt;Serializable&lt;/code&gt;的类成员也一定是可以&lt;code&gt;Serializable&lt;/code&gt;的, 比如基本类型&lt;code&gt;int …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;code&gt;Android&lt;/code&gt;内序列化对象主要有两种方式, 一是原&lt;code&gt;Java&lt;/code&gt;自带的&lt;code&gt;Serializable&lt;/code&gt;接口, 二是&lt;code&gt;Android&lt;/code&gt;内自有的&lt;code&gt;Parcelable&lt;/code&gt;接口&lt;/p&gt;
&lt;h3&gt;1. &lt;code&gt;Serializable&lt;/code&gt;接口&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;自带的序列接口使用非常简单, 只要实现&lt;code&gt;Serializable&lt;/code&gt;接口即可. &lt;code&gt;Serializable&lt;/code&gt;接口只是一个标志类, 系统会将实现了这个接口的类自动进行序列化. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果想自定义序列化/反序列化过程, 可以自主实现&lt;code&gt;writeObject()&lt;/code&gt;和&lt;code&gt;readObject()&lt;/code&gt;. 一般我们都不会这么做的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还可以定义一个&lt;code&gt;long serialVersionUID&lt;/code&gt;来检测反序列时的数据. 如果值不一样, 反序列时出抛出错误. 这个值可以使用&lt;code&gt;Android Studio&lt;/code&gt;自动生成, 也可以手工指定一个. 数值不论如何, 其本质是一样的.&lt;/p&gt;
&lt;p&gt;实现&lt;code&gt;Serializable&lt;/code&gt;的类成员也一定是可以&lt;code&gt;Serializable&lt;/code&gt;的, 比如基本类型&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, 字符类型&lt;code&gt;String&lt;/code&gt;, 或者实现了&lt;code&gt;Serializable&lt;/code&gt;接口的自定义类. &lt;/p&gt;
&lt;p&gt;可以使用关键字&lt;code&gt;transient&lt;/code&gt;来标明不参与序列化过程的变量&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public class User implements Serializable {
    // 定义一个数值以便验证反序列化时的数据正确性
    private static final long serialVersionUID = 8711368828010083044L;

    // 使用关键字 transient 表示变量不参与序列化过程
    private int age;

    // 要序列化的变量
    private String name;
    private boolean isMale;

    // getter and setter
    // .....
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2. &lt;code&gt;Parcelable&lt;/code&gt;接口&lt;/h3&gt;
&lt;p&gt;由&lt;code&gt;Parcelable&lt;/code&gt;序列化的类可以自由在&lt;code&gt;Binder&lt;/code&gt;中进行传输. 但实现的过程会比&lt;code&gt;Serializable&lt;/code&gt;麻烦些. 但是&lt;code&gt;Serializable&lt;/code&gt;在序列化和反序列化时需要大量的&lt;code&gt;I/O&lt;/code&gt;操作, 效率会比较低. 在&lt;code&gt;Android&lt;/code&gt;中推荐使用&lt;code&gt;Parcelable&lt;/code&gt;, 其在内存中序列化后可以立马发送到网络中, 或者保存到设备上. 如果数据较小也可以使用&lt;code&gt;Serializable&lt;/code&gt;来实现, 其优点是方便简单&lt;/p&gt;
&lt;p&gt;可&lt;code&gt;Parcelable&lt;/code&gt;类里内的变量需要是基本类型或者是可序列化的对象. &lt;code&gt;Intent&lt;/code&gt;, &lt;code&gt;Bundle&lt;/code&gt;, &lt;code&gt;Bitmap&lt;/code&gt;都实现了&lt;code&gt;Parcelable&lt;/code&gt;接口. &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;如果其内的每个元素是可序列化的话, 那么这两个也是可序列化的.&lt;/p&gt;
&lt;p&gt;实现&lt;code&gt;Parcelable&lt;/code&gt;要实现几个方法和变量:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;writeToParcel(Parcel out, int flag)&lt;/code&gt;方法的实现表示类是如何创建序列化对象和数组的. &lt;strong&gt;注意这个实现是的顺序, 当反序列化时也需要按这个顺序来写&lt;/strong&gt;
   &lt;code&gt;flags&lt;/code&gt;的值一般为&lt;code&gt;0&lt;/code&gt;或&lt;code&gt;1&lt;/code&gt;(即&lt;code&gt;PARCELABLE_WRITE_RETURN_VALUE&lt;/code&gt;), 当为&lt;code&gt;1&lt;/code&gt;时表示当前对象需要作为返回值返回, 不能立即释放资源. &lt;strong&gt;通常一般这个值都为&lt;code&gt;0&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;describeContents()&lt;/code&gt;方法的返回值一般为&lt;code&gt;0&lt;/code&gt;, 当序列化内容含有&lt;strong&gt;文件描述符&lt;/strong&gt;时, 返回&lt;code&gt;1&lt;/code&gt;(即&lt;code&gt;CONTENTS_FILE_DESCRIPTOR&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;定义一个&lt;code&gt;static final&lt;/code&gt;的常量&lt;code&gt;CREATOR&lt;/code&gt;来实现反序列化操作. 这个常量实现了&lt;code&gt;Parcelable.Creator&lt;/code&gt;接口.
   &lt;code&gt;T createFromParcel(Parcel in)&lt;/code&gt;方法表明如何反序列化一个类. &lt;strong&gt;反序列化的顺序要和序列化时一样&lt;/strong&gt;
   &lt;code&gt;T[] newArray(int size)&lt;/code&gt;方法表明如何反序列化出一个类的对象数组&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public class User implements Parcelable {
    private int id;
    private String name;
    // 要注意自定义的类也得是可序列化的
    private Book book;

    public User(int id, String name, Book book) {
        this.id = id;
        this.name = name;
        this.book = book;
    }

    // getter and setter
    // .....

    public int describeContents() {
        // 一般返回 0, 除非有文件描述符存在才返回 1
        reutrn 0;   
    }

    public void writeToParcel(Parcel out, int flags) {
        // 序列化的过程, 注意其序列, 在反序列化时要一致
        // flags 一般传入值为0, 只有在当有需要不能立即释放资源时才会传入 1
        out.wirteInt(id);
        out.writeString(name);
        out.writeParcelable(book, 0);
    }

    public static final Parcelable.Creator&amp;lt;User&amp;gt; CREATOR = 
            new Parceable.Creator&amp;lt;User&amp;gt;() {
        public User createFromParcel(Parcel in) {
            // 反序列化过程
            return new User(in);
        }

        // 反序列化数组时的过程
        public User[] newArray(int size) {
            return new User[size];
        }

        // 反序列化的过程需要注意和序列化时的顺序一致
        private User(Parcel in) {
            int id = in.readInt();
            int name = in.readString();
            // 需要一个 classLoader 来加载类
            // 可以从当前线程加载类中查找, 或者指一个类加载
            // Book book = in.readParcel(Book.class.getClassLoader())
            Book book = in.readParcel(
                Thread.currentThread().getContextClassLoader());
        }
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;Reference:&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;&amp;lt;&lt;Android 开发艺术探索&gt;&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/reference/android/os/Parcelable.html"&gt;https://developer.android.com/reference/android/os/Parcelable.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="android"></category><category term="序列化"></category><category term="serializable"></category><category term="parceable"></category></entry><entry><title>Android IPC机制</title><link href="https://ivicel.info/2018/04/android-ipcji-zhi.html" rel="alternate"></link><published>2018-04-01T00:00:00+08:00</published><updated>2018-04-01T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-04-01:/2018/04/android-ipcji-zhi.html</id><summary type="html">&lt;h4&gt;1. 开启多进程的方法&lt;/h4&gt;
&lt;p&gt;Android 应用启动时会自动创建一个新的进程, 其进程名默认为&lt;strong&gt;包名&lt;/strong&gt;, 为四大组件(&lt;strong&gt;Activity&lt;/strong&gt; , &lt;strong&gt;Service&lt;/strong&gt;, &lt;strong&gt;ContentProvider&lt;/strong&gt;, &lt;strong&gt;BroadcastReceiver&lt;/strong&gt;)启动一个新的进程, 最简单的是在&lt;code&gt;Manifest.xml&lt;/code&gt;中为其配置&lt;code&gt;android:process&lt;/code&gt;进程名称. 有两种写法. &lt;/p&gt;
&lt;p&gt;一是指定进程的全称:&lt;code&gt;android:process="info.ivicel.github.android_ipc.another_process"&lt;/code&gt;, 此时进程为一个全局进程, 其他应用可以通过&lt;code&gt;ShareUID&lt;/code&gt;方式和它跑在同一进程中&lt;/p&gt;
&lt;p&gt;二是简写: &lt;code&gt;android:process=":remote"&lt;/code&gt;. 这种写法其完整的进程名为&lt;code&gt;包名:remote&lt;/code&gt;, 并且此时进程为一个私有进程, 其他应用的组件不可以同时跑在该进程中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于 Android 中为不同进程单独分配一个虚拟机来运行, 所以 Android 中不能通过&lt;strong&gt;共享内存&lt;/strong&gt;来进行通信. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 …&lt;/p&gt;</summary><content type="html">&lt;h4&gt;1. 开启多进程的方法&lt;/h4&gt;
&lt;p&gt;Android 应用启动时会自动创建一个新的进程, 其进程名默认为&lt;strong&gt;包名&lt;/strong&gt;, 为四大组件(&lt;strong&gt;Activity&lt;/strong&gt; , &lt;strong&gt;Service&lt;/strong&gt;, &lt;strong&gt;ContentProvider&lt;/strong&gt;, &lt;strong&gt;BroadcastReceiver&lt;/strong&gt;)启动一个新的进程, 最简单的是在&lt;code&gt;Manifest.xml&lt;/code&gt;中为其配置&lt;code&gt;android:process&lt;/code&gt;进程名称. 有两种写法. &lt;/p&gt;
&lt;p&gt;一是指定进程的全称:&lt;code&gt;android:process="info.ivicel.github.android_ipc.another_process"&lt;/code&gt;, 此时进程为一个全局进程, 其他应用可以通过&lt;code&gt;ShareUID&lt;/code&gt;方式和它跑在同一进程中&lt;/p&gt;
&lt;p&gt;二是简写: &lt;code&gt;android:process=":remote"&lt;/code&gt;. 这种写法其完整的进程名为&lt;code&gt;包名:remote&lt;/code&gt;, 并且此时进程为一个私有进程, 其他应用的组件不可以同时跑在该进程中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于 Android 中为不同进程单独分配一个虚拟机来运行, 所以 Android 中不能通过&lt;strong&gt;共享内存&lt;/strong&gt;来进行通信. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Android 中使用&lt;strong&gt;共享内存&lt;/strong&gt;, 便会造成:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态成员和单例模式完全失效&lt;/li&gt;
&lt;li&gt;线程的同步机制完全失效, 通过共享内存来&lt;code&gt;synchronized&lt;/code&gt;, 锁对象/锁全局类都不是同一个了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SharedPreferences&lt;/code&gt;的可靠性下降. 这是因为&lt;code&gt;SharedPreferences&lt;/code&gt;底层是通过&lt;code&gt;xml&lt;/code&gt;文件的来实现的, 需要对文件的读写进行同步&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Application&lt;/code&gt;会多次创建. 多进程会为每一个进程启动一&lt;code&gt;Application&lt;/code&gt;, 相当多次启动应用. 可以在&lt;code&gt;Application&lt;/code&gt;的&lt;code&gt;onCreate()&lt;/code&gt;里打印出进程&lt;code&gt;id&lt;/code&gt;证实启动了多次应用&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;2. Android 中 IPC 的几种方式&lt;/h4&gt;
&lt;p&gt;在 Android 中的 IPC 大致有以下几种: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过&lt;code&gt;Intent&lt;/code&gt;的附加&lt;code&gt;extras&lt;/code&gt;来传递, 其本质是通过&lt;code&gt;Bundle&lt;/code&gt;来实现的&lt;/li&gt;
&lt;li&gt;通过共享文件&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;Binder&lt;/code&gt;, 其底层是通过&lt;code&gt;AIDL&lt;/code&gt;来实现&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;ContentProvider&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通过网络&lt;code&gt;Socket&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;直接使用&lt;code&gt;AIDL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;code&gt;Messenger&lt;/code&gt;, 注意这不是消息载体&lt;code&gt;Message&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5&gt;使用 Bundle&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Bundle&lt;/code&gt;的使用很是简单, 其实现了&lt;code&gt;Pacelable&lt;/code&gt;接口, 可以直接传递各种可序列化的数据. &lt;/p&gt;
&lt;p&gt;这种方式虽然简单易用, 但如果需要传输的数据不支持&lt;code&gt;Bundle&lt;/code&gt;, 那只能通过其他绕路方式. 比如需要在 A 进程中计算出某个结果, 然后启动进程 B, 同时把结果传给 B. 但计算结果不支持传输. 可以启动一个 B 进程里的后台 Service, 在其中计算出结果, 再传到前台 B 进程了. Service 和 B 是同一个进程.&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h5&gt;使用共享文件&lt;/h5&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以在进程&lt;code&gt;A&lt;/code&gt;中写入文件, 在进程&lt;code&gt;B&lt;/code&gt;中读出文件内容, 要注意的是读出的对象和写入时的对象其内容数据虽然一样, 但本质上是两个对象. 并且使用共享文件进行通信时, 如果要求的并发量过高, 其同步就越困难, 有可能出并发读/写时数据不一致的情况. 其适合使用在对数据同步要求不高的进程之间的通信.
   &lt;code&gt;SharedPreferences&lt;/code&gt;其底层的实现也是一个&lt;code&gt;.xml&lt;/code&gt;文件, 但是系统对其读/写时, 会维护一个在内存里的缓存, 这使得多进程模式下对&lt;code&gt;SharedPreferences&lt;/code&gt;的读写非常不可靠. 所以不要使用其行 IPC&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h5&gt;使用 AIDL 通信&lt;/h5&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;见 &lt;a href="./zai-androidzhong-shi-yong-aidljin-xing-ipc.html"&gt;在Android中使用AIDL进行IPC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h5&gt;使用 Messenger&lt;/h5&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;Messenger&lt;/code&gt; 是对 AIDL 的封装, 使用起来更加的方便. 服务端每一次只处理一个请求, 使用的 &lt;code&gt;MessageQueue&lt;/code&gt; 队列, 这样在服务端可以不用考虑并发的问题.&lt;/p&gt;
&lt;p&gt;###### 4.1 服务端&lt;/p&gt;
&lt;p&gt;由于是对 AIDL 的封装, 所以服务端也是创建一个 Service, 创建一个 Messenger 对象和一个 Handler 对象,&lt;/p&gt;
&lt;p&gt;Handler 处理客户端发送过来的数据. Service 的 Binder 对象可由 Messenger 对象返回.&lt;/p&gt;
&lt;p&gt;###### 4.2 客户端&lt;/p&gt;
&lt;p&gt;客户端通过 &lt;code&gt;bindService()&lt;/code&gt; 拿到服务端的代理. 通信的数据由 &lt;code&gt;Message&lt;/code&gt; 类来封装. 这个代理对象传送数据的方向为 client -&amp;gt; server, 只能单向传输.&lt;/p&gt;
&lt;p&gt;如果客户端需要服务器传回数据, 只能在客户端创建一个 &lt;code&gt;Messenger&lt;/code&gt; 对象和 &lt;code&gt;Handler&lt;/code&gt; 对象, 并通过&lt;code&gt;Message.replyTo&lt;/code&gt; 将这个对象传给服务器. 这样 server -&amp;gt; client 就可以传送数据了.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Messenger&lt;/code&gt; 类是 &lt;code&gt;final&lt;/code&gt; 的, 不可能通过继承 &lt;code&gt;Messenger&lt;/code&gt; 来重写传送数据方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Messenger机制" src="../../assets/images/Messenger机制.jpeg" /&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// server 
public MessengerService extends Service {
    private static final String TAG = "MessengerService";

    static class MessengerHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case Constants.MSG_HELLO_FROM_CLIENT:
                    Log.d(TAG, "Hello from client: " + 
                          msg.getData().getString("msg"));
                    break;

                default:
                    super.handleMessage(msg);
            }
        }
    }

    private Messenger mMessenger = new Messenger(new MessengerHandler());   


    @Override
    public IBinder onBind(Intent intent) {
        return mMessenger.getBinder();   
    }
}


// client
public MessengerActivity extends AppCompatActivity {
    private staitc final String TAG = "MessengerActivity";

    private Messenger mMessenger;

    private SerivceConnection connection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            mMessenger = new Messenger(service);
            sendHelloToServer();
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {}
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Intent intent = new Intent(this, MessengerService.class);
        bindService(intent, connection, Context.BIND_AUTO_CREATE);
    }

    private void sendHelloToServer() {
        Message msg = Message.obtain(null, Constants.MSG_HELLO_FROM_CLIENT);
        Bundle data = new Bundle();
        data.putString("msg", "this is hello from client.");
        msg.setData(data);
        try {
            mMessenger.send(msg);
        } catch (RemoteException e) {
            e.printStackTrace();   
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        unbindService(connection);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &amp;lt;&lt;Android开发艺术探索&gt;&amp;gt; 中提到:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Message中的另一个字段object在同一个进程中是很实用的，但是在进程间通信的时候，在Android 2.2以前object字段不支持跨进程传输，即便是2.2以后，也仅仅是&lt;strong&gt;系统&lt;/strong&gt;提供的实现了Parcelable接口的对象才能通过它来传输。这就意味着我们自定义的Parcelable对象是无法通过object字段来传输的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试例子: &lt;a href="https://github.com/ivicel/dev-android-samples/tree/master/ipc-with-messenger"&gt;GitHub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;测试环境: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Android Studio 3.1&lt;/li&gt;
&lt;li&gt;Gradle 4.4&lt;/li&gt;
&lt;li&gt;android gradle tool 3.1&lt;/li&gt;
&lt;li&gt;target sdk 27&lt;/li&gt;
&lt;li&gt;Build tool 27.0.2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;MessengerService&lt;/code&gt; 使用设置 &lt;code&gt;android:process=":remote"&lt;/code&gt; 单独一个进程后, 会发生 &lt;code&gt;java.lang.ClassNotFoundException&lt;/code&gt;, 猜测是因为找到不 &lt;code&gt;ClassLoader&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;Reference:&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&amp;lt;&lt;Android开发艺术探索&gt;&amp;gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="IPC"></category><category term="Android"></category><category term="进程间通信"></category></entry><entry><title>在Android中使用AIDL进行IPC</title><link href="https://ivicel.info/2018/04/zai-androidzhong-shi-yong-aidljin-xing-ipc.html" rel="alternate"></link><published>2018-04-01T00:00:00+08:00</published><updated>2018-04-01T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-04-01:/2018/04/zai-androidzhong-shi-yong-aidljin-xing-ipc.html</id><summary type="html">&lt;h5&gt;&lt;code&gt;AIDL&lt;/code&gt;基本介绍&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;AIDL&lt;/code&gt;全称&lt;code&gt;Android Interface Define Language&lt;/code&gt;, 后缀名是&lt;code&gt;.aidl&lt;/code&gt;. 其支持以下几个数据类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本数据类型&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String&lt;/code&gt;类型和&lt;code&gt;CharSequence&lt;/code&gt;类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List&lt;/code&gt;类型,  并其内&lt;strong&gt;元素&lt;/strong&gt;可以是&lt;strong&gt;泛型&lt;/strong&gt;. 但元素一定是可&lt;code&gt;Parcelable&lt;/code&gt;类型或是其他&lt;code&gt;AIDL&lt;/code&gt;支持的类型. 可选择将 &lt;code&gt;List&lt;/code&gt; 用作 “通用” 类（例如，&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;）。另一端实际接收的具体类始终是 &lt;code&gt;ArrayList&lt;/code&gt;，但生成的方法使用的是 &lt;code&gt;List&lt;/code&gt; 接口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Map&lt;/code&gt;类型 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h5&gt;&lt;code&gt;AIDL&lt;/code&gt;基本介绍&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;AIDL&lt;/code&gt;全称&lt;code&gt;Android Interface Define Language&lt;/code&gt;, 后缀名是&lt;code&gt;.aidl&lt;/code&gt;. 其支持以下几个数据类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本数据类型&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String&lt;/code&gt;类型和&lt;code&gt;CharSequence&lt;/code&gt;类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List&lt;/code&gt;类型,  并其内&lt;strong&gt;元素&lt;/strong&gt;可以是&lt;strong&gt;泛型&lt;/strong&gt;. 但元素一定是可&lt;code&gt;Parcelable&lt;/code&gt;类型或是其他&lt;code&gt;AIDL&lt;/code&gt;支持的类型. 可选择将 &lt;code&gt;List&lt;/code&gt; 用作 “通用” 类（例如，&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;）。另一端实际接收的具体类始终是 &lt;code&gt;ArrayList&lt;/code&gt;，但生成的方法使用的是 &lt;code&gt;List&lt;/code&gt; 接口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Map&lt;/code&gt;类型. 并其内元素不能是泛型, 元素一定&lt;code&gt;AIDL&lt;/code&gt;支持的类型, 或者可&lt;code&gt;Parcelable&lt;/code&gt;或者其他&lt;code&gt;AIDL&lt;/code&gt;接口. 不支持通用 &lt;code&gt;Map&lt;/code&gt;（如&lt;code&gt;Map&amp;lt;String,Integer&amp;gt;&lt;/code&gt; 形式的 Map）。 另一端实际接收的具体类始终是 &lt;code&gt;HashMap&lt;/code&gt;，但生成的方法使用的是 &lt;code&gt;Map&lt;/code&gt; 接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般有两种&lt;code&gt;.aidl&lt;/code&gt;文件. 一种是定义可&lt;code&gt;Parcelable&lt;/code&gt;的数据结构. 一种是定义方法接口.数据结构需要由我们自己来实现, 一般也会写在包内. 而接口方法由系统生成固定的接口, 然后在需要的地方再实现具体的业务逻辑, 实现该接口即可&lt;/p&gt;
&lt;p&gt;一般我们会把&lt;code&gt;AIDL&lt;/code&gt;文件全部都定义在一个&lt;code&gt;package&lt;/code&gt;内. 这样才发送给客户端时, 只需把整个包发给他就 OK了. 但即使在同一个包内的&lt;code&gt;aidl&lt;/code&gt;文件在使用其他包内的数据时也是要&lt;code&gt;import&lt;/code&gt;才行.&lt;/p&gt;
&lt;p&gt;在接口方法中定义的参数都必须带有&lt;code&gt;tag&lt;/code&gt;标志们, &lt;code&gt;Primitives&lt;/code&gt;基本类型和&lt;code&gt;String&lt;/code&gt;和&lt;code&gt;CharSequence&lt;/code&gt;默认是&lt;code&gt;in&lt;/code&gt;而且只能是&lt;code&gt;in&lt;/code&gt;. 其他可以为&lt;code&gt;in&lt;/code&gt;, &lt;code&gt;out&lt;/code&gt;, &lt;code&gt;inout&lt;/code&gt;. 后面详解这三个&lt;code&gt;tag&lt;/code&gt;&lt;/p&gt;
&lt;h5&gt;&lt;code&gt;AIDL&lt;/code&gt;简单使用示例&lt;/h5&gt;
&lt;p&gt;首先定义两个&lt;code&gt;AIDL&lt;/code&gt;文件&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-aidl"&gt;// Book.aidl
package info.ivicel.github.aidldemo;

// 注意是小写
parcelable Book;&lt;/code&gt;&lt;/pre&gt;

&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-aidl"&gt;package info.ivicel.github.aidldemo;

// 非基本数据类型需要导入
import info.ivicel.github.aidldemo.Book;

interface BookManager {
    // 测试不同的 tag 标志的影响
    // 返回值不需要 tag
    Book addBookIn(in Book book);
    Book addBookOut(out Book book);
    Book addBookInout(inout Book book);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再定义&lt;code&gt;Book.aidl&lt;/code&gt;的实现&lt;code&gt;Book.java&lt;/code&gt;. 需要注意的两点: 
一是如果把&lt;code&gt;Book.java&lt;/code&gt;定义在&lt;code&gt;aidl&lt;/code&gt;包中, 一定要向&lt;code&gt;build.gradle&lt;/code&gt;添加查找&lt;code&gt;java&lt;/code&gt;文件的路径.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-gradle"&gt;android {
    // .....
    sourceSets {
        main {
            java.srcDirs = ['src/main/java', 'src/main/aidl']
        }
    }
    // .....
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二是默认的&lt;code&gt;Parcelable&lt;/code&gt;接口并不要求实现&lt;code&gt;readFromParcel&lt;/code&gt;方法, 但在&lt;code&gt;AIDL&lt;/code&gt;中, &lt;code&gt;tag&lt;/code&gt;标签的&lt;code&gt;out&lt;/code&gt;,&lt;code&gt;inout&lt;/code&gt;需要其来实现写入流, 如果不实现这个方法, 则只能为&lt;code&gt;in&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;package info.ivicel.github.aidldemo;


import android.os.Parcel;
import android.os.Parcelable;

// 如果 java 的实现类是放在和 aidl 同一个包内
// 一定不能忘了把 java 源码的路径加入到 build.gradle 中, 否则会找不到文件

public class Book implements Parcelable {
    private String name;
    private int price;

    // 需要显示的定义一个无参的 constructor
    public Book() {}

    // getter and setter...

    protected Book(Parcel in) {
        readFromParcel(in);
    }

    public static final Creator&amp;lt;Book&amp;gt; CREATOR = new Creator&amp;lt;Book&amp;gt;() {
        @Override
        public Book createFromParcel(Parcel in) {
            return new Book(in);
        }

        @Override
        public Book[] newArray(int size) {
            return new Book[size];
        }
    };

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeInt(price);
        dest.writeString(name);
    }

    // 默认的 Parcelable 是没有规定要实现 readFromParcel 方法
    // 但如果不实现这个方法, Book 的 tag 只能为 in
    public void readFromParcel(Parcel dest) {
        price = dest.readInt();
        name = dest.readString();
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上三个文件&lt;code&gt;Book.aidl&lt;/code&gt;, &lt;code&gt;Book.java&lt;/code&gt;, &lt;code&gt;BookManager.aidl&lt;/code&gt;在&lt;code&gt;client&lt;/code&gt;和&lt;code&gt;server&lt;/code&gt;端都必须有一份.&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;rebuild&lt;/code&gt;,或是&lt;code&gt;clean&lt;/code&gt;之后, 会在应用目录&lt;code&gt;build/source/aidl&lt;/code&gt;下生成同名接口的&lt;code&gt;java&lt;/code&gt;文件. 我们只要在&lt;code&gt;server&lt;/code&gt;端根据具体的业务逻辑实现该接口中的方法即可. 然后使用&lt;code&gt;Service&lt;/code&gt;来监听来自&lt;code&gt;client&lt;/code&gt;的请求. 在&lt;code&gt;client&lt;/code&gt;端来调用接口中的方法与&lt;code&gt;server&lt;/code&gt;端进行通信&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Server&lt;/code&gt;端实现一个&lt;code&gt;Service&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// AIDLService.java
public class AIDLService extends Service {
    private static final String TAG = "AIDLService";

    private List&amp;lt;Book&amp;gt; books = new ArrayList&amp;lt;&amp;gt;();

    // 由 AIDL 文件生成的 BookManager 接口的实现
    // 一般会有多个 client 连接到 server, 所以需要对 server 中的数据处理同步问题
    private final BookManager.Stub bookManager = new BookManager.Stub() {
        @Override
        public List&amp;lt;Book&amp;gt; getBooks() throws RemoteException {
            synchronized (this) {
                if (books != null) {
                    return books;
                }
            }
            return new ArrayList&amp;lt;&amp;gt;();
        }

        @Override
        public Book getBook() throws RemoteException {
            synchronized (this) {
                if (books == null) {
                    return null;
                }

                Random r = new Random(System.currentTimeMillis());
                int n = r.nextInt(books.size());
                return books.get(n);
            }
        }

        @Override
        public int getBookCount() throws RemoteException {
            synchronized (this) {
                if (books != null) {
                    return books.size();
                }
            }

            return 0;
        }

        // ... 
    };

    @Override
    public void onCreate() {
        super.onCreate();
        Log.d(TAG, "onCreate: ");
        Book book = new Book();
        book.setName("Android开发艺术探索");
        book.setPrice(28);
        books.add(book);

        book = new Book();
        book.setName("Android编程权威指南");
        book.setPrice(55);
        books.add(book);
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        Log.d(getClass().getSimpleName(), String.format("on bind, intent = %s", intent.toString()));
        return bookManager;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在&lt;code&gt;Manifest.xml&lt;/code&gt;中定义&lt;code&gt;Service&lt;/code&gt;, 如果&lt;code&gt;Client&lt;/code&gt;是另一个程序的话, 需要定义一个隐式的&lt;code&gt;Intent-filter&lt;/code&gt;来通知&lt;code&gt;Service&lt;/code&gt;接收什么连接&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;!-- exported=true 表示能让非同应用的进程访问 --&amp;gt;
&amp;lt;!-- 为了安全最好还是定义一个 permission, 让拥有权限的应用访问 --&amp;gt;
&amp;lt;service
         android:name=".AIDLService"
         android:exported="true"&amp;gt;
    &amp;lt;intent-filter&amp;gt;
        &amp;lt;!-- 定义一个 action, client 请求时使用, 需一致 --&amp;gt;
        &amp;lt;action android:name="info.ivicel.github.aidldemo.aidl"/&amp;gt;
        &amp;lt;!-- 定义一个 category, java 代码中系统会自动给添加上一个 DEFAULT --&amp;gt;
        &amp;lt;!-- 不定义会导致无法指收到请求. 或者定义其他的的 category --&amp;gt;
        &amp;lt;category android:category="android.intent.category.DEFAULT"/&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/service&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;Client&lt;/code&gt;端, 我们可以通过&lt;code&gt;bindService()&lt;/code&gt;来获得&lt;code&gt;BookManager&lt;/code&gt;的引用&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// client 
// MainActivity.java 
public class MainActivity extends AppCompatActivity {

    private BookManager bookManager;
    private boolean bound = false;
    private ServiceConnection connection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            // 在 bindService 之后我们就可以拿到 binder
            // 转为在 aidl 中定义好的接口, 就可以使用接口的方法
            bookManager = BookManager.Stub.asInterface(service);
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            bound = false;
            bookManager = null;
        }
    };

    @Override
    protected void onCreated(Bundle saveInstanceState) {
        super.onCreated(saveInstanceState);
        setContentView(R.layout.activity_main);

        if (!bound) {
            attempToBindService();
        }
    }

    private void attempToBindService() {
        Intent intent = new Intent();
        intent.setAction("info.ivicel.github.aidldemo.aidl");
        intent.setPackage("info.ivicel.github.aidldemo");
        bindService(intent, connection, Context.BIND_AUTO_CREATE);
    }

    @Override
    protected void onDestroy() {
        super.onDestory();
        if (bound) {
            unbindService(connection);
        }
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;&lt;code&gt;AIDL&lt;/code&gt;方法参数&lt;code&gt;in&lt;/code&gt;, &lt;code&gt;out&lt;/code&gt;, &lt;code&gt;inout&lt;/code&gt;意义&lt;/h5&gt;
&lt;p&gt;这三个参数表示的是数据的流向, 都是从&lt;code&gt;client&lt;/code&gt;来看&lt;code&gt;server&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;in&lt;/code&gt;表示数据从&lt;code&gt;client&lt;/code&gt;流向&lt;code&gt;server&lt;/code&gt;. &lt;code&gt;server&lt;/code&gt;会从&lt;code&gt;client&lt;/code&gt;接收到一个完整的对象, 但对该对象的修改不会使&lt;code&gt;client&lt;/code&gt;端产生变化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;out&lt;/code&gt;表示数据从&lt;code&gt;server&lt;/code&gt;流向&lt;code&gt;client&lt;/code&gt;. &lt;code&gt;server&lt;/code&gt;端会从&lt;code&gt;client&lt;/code&gt;端接收到一个空对象, 对该对象的操作将反应到&lt;code&gt;client&lt;/code&gt;传入的对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inout&lt;/code&gt;表示数据可双向流动, 以上两点的结合. 接收完整信息并反馈回&lt;code&gt;client&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依旧使用上一个例子来做一个实验&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;client&lt;/code&gt;中使用三个不同的&lt;code&gt;tag&lt;/code&gt;向&lt;code&gt;server&lt;/code&gt;添加新的对象, 并在&lt;code&gt;server&lt;/code&gt;中对其进行修改. 然后分别返回这个新的值. 这些过程都打对象打印出来作对比&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// client
private void addBookIn() {
    if (checkServerService()) {
        return;
    }

    Book book = new Book();
    book.setName("new_book_in");
    book.setPrice(20);
    try {
        Log.d("OnClient", "before addBookIn client book = " + book);
        Book b2 = bookManager.addBookIn(book);
        Log.d("OnClient", "addBookIn return from server: " + b2);
        Log.d("OnClient", "after addBookIn client book = " + book);
    } catch (RemoteException e) {
        e.printStackTrace();
    }
}

private void addBookOut() {
    if (checkServerService()) {
        return;
    }

    Book book = new Book();
    book.setName("new_book_out");
    book.setPrice(21);
    try {
        Log.d("OnClient", "before addBookOut client book = " + book);
        Book b2 = bookManager.addBookOut(book);
        Log.d("OnClient", "addBookOut return from server: " + b2);
        Log.d("OnClient", "after addBookOut client book = " + book);
    } catch (RemoteException e) {
        e.printStackTrace();
    }
}

private void addBookInout() {
    if (checkServerService()) {
        return;
    }

    Book book = new Book();
    book.setName("new_book_inout");
    book.setPrice(22);
    try {
        Log.d("OnClient", "before addBookInOut client book = " + book);
        Book b2 = bookManager.addBookInout(book);
        Log.d("OnClient", "addBookInOut return from server: " + b2);
        Log.d("OnClient", "after addBookInOut client book = " + book);
    } catch (RemoteException e) {
        e.printStackTrace();
    }
}

// server 
private static final BookManager.Stub bookManager = new BookManager.Stub {
    // ....
    // 在 server 中, 分别都对传入进来的 book 名称加上 "_by_server`, 价格加 10, 然后返回
    @Override
    public Book addBookIn(Book book) throws RemoteException {
        Log.d("OnServer", "addBookIn: " + book);
        book.setName(book.getName() + "_by_server");
        book.setPrice(book.getPrice() + 10);
        books.add(book);
        return book;
    }

    @Override
    public Book addBookOut(Book book) throws RemoteException {
        Log.d("OnServer", "addBookOut: " + book);
        book.setName(book.getName() + "_by_server");
        book.setPrice(book.getPrice() + 10);
        books.add(book);
        return book;
    }

    @Override
    public Book addBookInout(Book book) throws RemoteException {
        Log.d("OnServer", "addBookInOut: " + book);
        book.setName(book.getName() + "_by_server");
        book.setPrice(book.getPrice() + 10);
        books.add(book);
        return book;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;server&lt;/code&gt;端打印的结果:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OnServer: addBookIn: Book{name='new_book_in', price=20}
OnServer: addBookOut: Book{name='null', price=0}
OnServer: addBookInOut: Book{name='new_book_inout', price=22}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看出来, &lt;code&gt;tag&lt;/code&gt;为&lt;code&gt;in&lt;/code&gt;时, 传进来的是一个完整的对象数据值. 为&lt;code&gt;out&lt;/code&gt;时, 传进来的是一个默认初始化的对象. 为&lt;code&gt;inout&lt;/code&gt;传进来的也是一个完整对象&lt;/p&gt;
&lt;p&gt;&lt;code&gt;client&lt;/code&gt;端的打印结果:&lt;/p&gt;
&lt;p&gt;首先是&lt;code&gt;tag&lt;/code&gt;为&lt;code&gt;in&lt;/code&gt;时. 返回的值说明&lt;code&gt;server&lt;/code&gt;对对象有修改, 但&lt;code&gt;client&lt;/code&gt;本身的原对象未发生变化. 说明&lt;code&gt;server&lt;/code&gt;端是一个副本&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OnClient: before addBookIn client book = Book{name='new_book_in', price=20}
OnClient: addBookIn return from server: Book{name='new_book_in_by_server', price=30}
OnClient: after addBookIn client book = Book{name='new_book_in', price=20}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当&lt;code&gt;tag&lt;/code&gt;为&lt;code&gt;out&lt;/code&gt;时, &lt;code&gt;server&lt;/code&gt;接收到的是一个默认初始化的对象, 数据并不同于&lt;code&gt;client&lt;/code&gt;端, 但在&lt;code&gt;server&lt;/code&gt;修改后, &lt;code&gt;client&lt;/code&gt;会同步变化&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OnClient: before addBookOut client book = Book{name='new_book_out', price=21}
OnClient: addBookOut return from server: Book{name='null_by_server', price=10}
OnClient: after addBookOut client book = Book{name='null_by_server', price=10}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当&lt;code&gt;tag&lt;/code&gt;为&lt;code&gt;inout&lt;/code&gt;时, 是以上两种的结合&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OnClient: before addBookInOut client book = Book{name='new_book_inout', price=22}
OnClient: addBookInOut return from server: Book{name='new_book_inout_by_server', price=32}
OnClient: after addBookInOut client book = Book{name='new_book_inout_by_server', price=32}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码地址: &lt;a href="https://github.com/ivicel/dev-android-samples/tree/master/AIDL-Demo"&gt;GitHub&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;Reference:&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/luoyanglizi/article/details/51980630"&gt;https://blog.csdn.net/luoyanglizi/article/details/51980630&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/luoyanglizi/article/details/51958091"&gt;https://blog.csdn.net/luoyanglizi/article/details/51958091&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/luoyanglizi/article/details/52029091"&gt;https://blog.csdn.net/luoyanglizi/article/details/52029091&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;&lt;Android 开发艺术探索&gt;&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/guide/components/aidl.html?hl=zh-cn"&gt;https://developer.android.com/guide/components/aidl.html?hl=zh-cn&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="aidl"></category><category term="ipc"></category><category term="进程间通信"></category></entry><entry><title>Android Contnet Provider内容提供器</title><link href="https://ivicel.info/2018/02/android-contnet-providernei-rong-ti-gong-qi.html" rel="alternate"></link><published>2018-02-22T00:00:00+08:00</published><updated>2018-02-22T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-02-22:/2018/02/android-contnet-providernei-rong-ti-gong-qi.html</id><summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3&gt;1. Content Provider 的优势:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;可以用来提供进程间的通信&lt;/li&gt;
&lt;li&gt;提供一个统一的接口, 屏蔽了底层的具体实现. 底层可以使用数据库如&lt;code&gt;SQLite&lt;/code&gt;, 文件, 或者从网络中获取&lt;/li&gt;
&lt;li&gt;提供了一个&lt;code&gt;权限&lt;/code&gt;限制&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;2. Content URI 的写法:&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;content://&lt;/code&gt; + &lt;code&gt;AUTHORITY&lt;/code&gt; + &lt;code&gt;/表名&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;content://com.example.myapp.provider/table1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AUTHORITY&lt;/code&gt;一般默认写成&lt;code&gt;包名.provider&lt;/code&gt;, &lt;code&gt;包名.provider类名&lt;/code&gt;, 一般用包名在前修饰, 以免在需要共享给别的程度时产生冲突&lt;/p&gt;
&lt;p&gt;后面跟表名, 或者还可以跟修饰符&lt;code&gt;*&lt;/code&gt;, &lt;code&gt;#&lt;/code&gt;, &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;书写规则&lt;/p&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt;表示匹配任意长度任意字符&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;content://com.example.myapp.provider/*&lt;/code&gt; 查询所有表中所有数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;#&lt;/code&gt;表示匹配任意长度的数字&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;content://com.example …&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3&gt;1. Content Provider 的优势:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;可以用来提供进程间的通信&lt;/li&gt;
&lt;li&gt;提供一个统一的接口, 屏蔽了底层的具体实现. 底层可以使用数据库如&lt;code&gt;SQLite&lt;/code&gt;, 文件, 或者从网络中获取&lt;/li&gt;
&lt;li&gt;提供了一个&lt;code&gt;权限&lt;/code&gt;限制&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;2. Content URI 的写法:&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;content://&lt;/code&gt; + &lt;code&gt;AUTHORITY&lt;/code&gt; + &lt;code&gt;/表名&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;content://com.example.myapp.provider/table1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AUTHORITY&lt;/code&gt;一般默认写成&lt;code&gt;包名.provider&lt;/code&gt;, &lt;code&gt;包名.provider类名&lt;/code&gt;, 一般用包名在前修饰, 以免在需要共享给别的程度时产生冲突&lt;/p&gt;
&lt;p&gt;后面跟表名, 或者还可以跟修饰符&lt;code&gt;*&lt;/code&gt;, &lt;code&gt;#&lt;/code&gt;, &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;书写规则&lt;/p&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt;表示匹配任意长度任意字符&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;content://com.example.myapp.provider/*&lt;/code&gt; 查询所有表中所有数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;#&lt;/code&gt;表示匹配任意长度的数字&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;content://com.example.myapp.provider/table1/#&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;查询&lt;code&gt;table1&lt;/code&gt;中的某一行, 如果提供了这类&lt;code&gt;MIME_TYPE&lt;/code&gt;的话, 可以使用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;content://com.example.myapp.provider/table/3&lt;/code&gt;访问表&lt;code&gt;table&lt;/code&gt;的第&lt;code&gt;3&lt;/code&gt;行数据&lt;/p&gt;
&lt;p&gt;此时可以使用类&lt;code&gt;ContentUris&lt;/code&gt;添加一个&lt;code&gt;id&lt;/code&gt;, 类&lt;code&gt;Uri#withAppendedPath&lt;/code&gt;也是一样, 只不过接收的是一个&lt;code&gt;String&lt;/code&gt;类型&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Uri singleUri = ContentUris.withAppendedId(MyProvider.CONTENT_URI, id)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;code&gt;MIME&lt;/code&gt;的写法&lt;/h4&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;必须以&lt;code&gt;vnd&lt;/code&gt;开头&lt;/li&gt;
&lt;li&gt;如果以内容URI结尾的, 后面接&lt;code&gt;android.cursor.item/&lt;/code&gt;; 如果以目录URI结尾的, 后面接&lt;code&gt;android.cursor.dir/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最后接上&lt;code&gt;vnd.&amp;lt;authority&amp;gt;.&amp;lt;path&amp;gt;&lt;/code&gt; &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如: &lt;code&gt;vnd.android.cursor.dir/vnd.com.example.myapp.provider/table1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ContentResolver&lt;/code&gt;类中有两个预定义的&lt;code&gt;vendor&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ContentResolver.CURSOR_ITEM_BASE_TYPE = "vnd.android.cursor.item"&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ContentResolver.CURSOR_DIR_BASE_TYPE = "vnd.android.cursor.dir"&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;在&lt;code&gt;AndroidManifest.xml&lt;/code&gt;中写法&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;当非同一个程序中需要使用&lt;code&gt;Content Provider&lt;/code&gt;时, 必须要在&lt;code&gt;AndroidManifest.xml&lt;/code&gt;声明使用权限. 比如读写用户字典:&lt;code&gt;&amp;lt;use-permission name="android.permission.READ_USER_DICTIONARY&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然而如果在同一程序中, 无论是否声明自定义权限, 原程序都有其读写的权限&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;provider
          android:authorities="list" // 要和类中定义的认证名完全一样
          android:directBootAware=["true" | "false"] // unlock deivce之前进行启动privoder
          andorid:enabled=["true" | "false"] // 启用
          android:exported=["true" | "false"] // 外部是否可访问到
          android:grantUriPermissions=["true" | "false"] // 可授予特定的uri临时权限. 如果true, 则可以授予权限给任意uri. false则只能授予权限给特定uri. 默认false
// 特定的uri权限在&amp;lt;grant-uri-permission&amp;gt;中声明
          android:icon="drawable resource" // 设置一个调用时的图标, 默认是application icon
          android:initOrder="integer" // 同一进程中的content provider初始顺序, 默认是从大的数字先初始
          android:label="string resource" // 默认使用application label
          android:multiprocess=["true" | "false"] // 在程序使用多进程情况下, true表示各进程生成各自的content provider object. false表示共用. 默认false
          android:name="string" // provider的名称. 一般取作 package.UserDictionaryProvider, 后面是provider的用处
          android:permission="string" // 设置一个读写权限名
          android:readPermission="string" // 读权限, 覆盖掉 android:permission 如果有
          android:wirtePermission="string" // 写权限, 覆盖掉 android:permission 如果有
          andorid:process="string" // 进程的名称. 用来表示需要哪个进程来运行这个content provider                           // 一般情况下所有的 application components 都运行在同一进程下                         // components 都有自己的 process 属性来表示需要运行在不同的进程当中                    // 如果以一个分号(:)开头的进程名, 表示运行在一个程序私有新进程中                         // 如果直接以名字, 则表示运行在一个全局共享可访问的进程中
          android:syncable=["true" | "false"]&amp;gt; // 表示 content provider 底层数据是否是 synchronized

  // 在&amp;lt;provider&amp;gt;标签中还能包含&amp;lt;meta-data&amp;gt;, &amp;lt;grant-uri-permission&amp;gt;, &amp;lt;path-permission&amp;gt;标签
  // path-level permission中定义的权限会覆盖掉 application-level 中&amp;lt;permission&amp;gt;定义和provider-level 中的权限
  // 而 grant-uri-permission是对临时uri的权限, 不受这三个level的影响
  // 总体下说, 下层的权限覆盖总是对上层权限更加的精确把控, 需要精确分层时使用

&amp;lt;/provider&amp;gt;

&amp;lt;provider android:name=".MyProvider"
          android:authorities="com.example.myapp.MyProvider"
          android:enable="true"
          android:exported="false"/&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;创建一个自定义的&lt;code&gt;Content Provider&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;--------------------------------------;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自定义一个类继承&lt;code&gt;ContentProvider&lt;/code&gt;, 实现&lt;code&gt;onCreate&lt;/code&gt;, &lt;code&gt;query&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;getType&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;UriMatcher&lt;/code&gt;类快速生成或者匹配&lt;code&gt;uri&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;
public class MyProvider extends ContentProvider {

    public static final String AUTHORITY = "com.example.myapp.MyProvider";
    private static UriMatcher sUriMatcher;

    private static final int SEARCH_WORDS = 0;
    private static final int GET_WORD_DEFINITION = 1;
    private static final int SEARCH_SUGGEST = 2;

    public static final String WORD_MIME_TYPE = 
        ContentResolver.CURSOR_DIR_BASE_TYPE + 
        "/vnd.com.example.myapp.dictionary";
    public static final String DEFINITION_MIME_TYPE = 
        ContentResolver.CURSOR_ITEM_BASE_TYPE +
        "/vnd.com.example.myapp.dictionary";
    public static final String SEARCH_SUGGEST_MIME_TYPE = 
        ContentResolver.CURSOR_DIR_BASE_TYPE +
        "vnd.com.example.myapp.search_suggest";

    // 生成匹配的对应 uri 的 mime type
    static {
        sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
        // search words
        sUriMatcher.addURI(AUTHORITY, "dictionary", SEARCH_WORDS);
        sUriMatcher.addURI(AUTHORITY, "dictionary/#", GET_WORD_DEFINITION);
        sUriMatcher.addURI(AUTHORITY, "search_suggest", SEARCH_SUGGEST);
    }

    @Override
    public boolean onCreate() {
        // 在第一次调用ContentResolver访问时会调用该方法
        // 返回true表示创建成功
        return true;
    }

    @Nullable
    @Override
    public Cursor query(@NonNull Uri uri, @Nullable String[] projection,
            @Nullable String selection,
            @Nullable String[] selectionArgs, @Nullable String sortOrder) {
        return null;
    }

    @Nullable
    @Override
    public String getType(@NonNull Uri uri) {
        switch (sUriMatcher.match(uri)) {
            case SEARCH_WORDS:   
                return WORD_MIME_TYPE;
            case GET_WORD:
                return DEFINITION_MIME_TYPE;
            case SEARCH_SUGGEST:
                return SEARCH_SUGGEST_MIME_TYPE;
            default:
                throw new IllegalArgumentException("Unknown URL: " + uri);
        }
    }

    @Nullable
    @Override
    public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {
        // insert to database/file
        // return new rows uri
        return null;
    }

    @Override
    public int delete(@NonNull Uri uri, @Nullable String selection,
            @Nullable String[] selectionArgs) {
        // delete datas
        // return how many rows were deleted
        return 0;
    }

    @Override
    public int update(@NonNull Uri uri, @Nullable ContentValues values,
            @Nullable String selection,
            @Nullable String[] selectionArgs) {
        // update something
        // return how many 
        return 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;除了使用&lt;code&gt;ContentResolver&lt;/code&gt;外, 其他几种访问&lt;code&gt;Content Provider&lt;/code&gt;方法&lt;/h4&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Batch access&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;提供了一种批量处理方法, 首先生成一个&lt;code&gt;ArrayList&amp;lt;ContentProviderOperation&amp;gt;&lt;/code&gt;数组, 向数组中添加所需操作, 然后使用&lt;code&gt;ContentResolver.applyBatch(ArrayList)&lt;/code&gt;来调用这个批处理事件. 这会使&lt;code&gt;ContentResolver&lt;/code&gt;调用&lt;code&gt;ContentProvider#applyBatch&lt;/code&gt;方法, 可以在自定义&lt;code&gt;ContentProvider&lt;/code&gt;时覆写这个方法, 其原始方法只是调用了&lt;code&gt;ContentProviderOperation#apply()&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;Google Sample&lt;/strong&gt;中 [Contact Manager][!&lt;a href="https://android.googlesource.com/platform/development/+/master/samples/ContactManager/"&gt;https://android.googlesource.com/platform/development/+/master/samples/ContactManager/&lt;/a&gt;] 示例中文件 [&lt;code&gt;ContacAdder.java&lt;/code&gt;][!&lt;a href="https://android.googlesource.com/platform/development/+/master/samples/ContactManager/src/com/example/android/contactmanager/ContactAdder.java"&gt;https://android.googlesource.com/platform/development/+/master/samples/ContactManager/src/com/example/android/contactmanager/ContactAdder.java&lt;/a&gt;] 演示批处理的用法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Loader&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为 &lt;code&gt;SimpleCursorAdapter&lt;/code&gt;的弃用, 现在使用&lt;code&gt;Loader&lt;/code&gt;来异步加载数据, 其能根据 &lt;code&gt;Activity&lt;/code&gt; &lt;code&gt;Fragment&lt;/code&gt; 的生命周期来控制数据获取周期, 以免造成&lt;strong&gt;ANR&lt;/strong&gt;, 或者是重复加载数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Data access via intents&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用&lt;code&gt;Intent&lt;/code&gt;可以间接的访问到你没有获得权限的&lt;code&gt;Content Provier&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要在&lt;code&gt;AndroidManifest.xml&lt;/code&gt;中的&lt;code&gt;&amp;lt;provider&amp;gt;&lt;/code&gt;提供&lt;code&gt;android:grantUriPermission="true"&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;code&gt;&amp;lt;grant-uri-permission&amp;gt;&lt;/code&gt;中提供的可授权许可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如在&lt;code&gt;MyApp&lt;/code&gt;中提供调用相机程序的拍照功能 , 在&lt;code&gt;MyApp&lt;/code&gt;中自定义一个&lt;code&gt;FileProvider&lt;/code&gt;来提供路径地址来存储获得的照片(&lt;code&gt;Internal Storage&lt;/code&gt;或&lt;code&gt;External Storage&lt;/code&gt;), 然而由于访问程序私有路径是非法的, 需要获得相应的授权. &lt;/p&gt;
&lt;p&gt;此时我们就可以在调用相应的&lt;code&gt;Intent&lt;/code&gt;时, 使用&lt;code&gt;Context#grantUriPermission()&lt;/code&gt;加上&lt;code&gt;Content.FLAG_GRANT_READ_URI_PERMISSION&lt;/code&gt;或是&lt;code&gt;Content.FLAG_GRANT_WRITE_URI_PERMISSION&lt;/code&gt;授予该&lt;code&gt;uri&lt;/code&gt;(仅仅是针对该&lt;strong&gt;URI&lt;/strong&gt;, 并不是整个&lt;code&gt;Content Provider&lt;/code&gt;)临时权限, 在调用的&lt;code&gt;Intent&lt;/code&gt;返回结束, 为保证安全, 调用 &lt;code&gt;Context#revokeUriPermission()&lt;/code&gt;来取消掉这个权限.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tips: &lt;code&gt;FileProvider&lt;/code&gt;在4.4以上会自动授权&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;又例如, 即使没有声明&lt;code&gt;Manifest.permission.READ_CONTACTS&lt;/code&gt;, 也可以使用一个&lt;code&gt;Intent.ACTION_PICK&lt;/code&gt;来挑选个联系人加上&lt;code&gt;ContactsContrac.RawContacts.CONTENT_ITEM_TYPE&lt;/code&gt;这个&lt;code&gt;uri&lt;/code&gt;来获取一个联系人信息. 由于这些操作是在前台&lt;code&gt;UI&lt;/code&gt;上执行的, 用户可以看到并且选择联系人是自己操作的, 相当用户同意授予了其读取联系人的权限&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;Contract Classses&lt;/code&gt;&lt;/h4&gt;
&lt;hr /&gt;
&lt;p&gt;所谓&lt;code&gt;Contract Classes&lt;/code&gt;是一些定义了一些&lt;code&gt;constants&lt;/code&gt;, &lt;code&gt;content URIs&lt;/code&gt;, &lt;code&gt;column names&lt;/code&gt;, &lt;code&gt;intent actions&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;例如&lt;code&gt;UserDictionary.Words.CONTENT_URI&lt;/code&gt;, &lt;code&gt;UserDictionary.Words&lt;/code&gt;, &lt;code&gt;ContactsContract&lt;/code&gt;&lt;/p&gt;</content><category term="android"></category><category term="content provider"></category><category term="内容提供器"></category></entry><entry><title>Android 系统权限</title><link href="https://ivicel.info/2018/02/android-xi-tong-quan-xian.html" rel="alternate"></link><published>2018-02-22T00:00:00+08:00</published><updated>2018-02-22T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-02-22:/2018/02/android-xi-tong-quan-xian.html</id><summary type="html">&lt;h5&gt;危险权限&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;权限组&lt;/th&gt;
&lt;th&gt;权限&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;CALENDAR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;WRITE_CALENDAR&lt;/code&gt; &lt;code&gt;READ_CALENDAR&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;CAMERA&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;CAMERA&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;CONTACTS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;READ_CONTACTS&lt;/code&gt; &lt;code&gt;WRITE_CONTACTS&lt;/code&gt; &lt;code&gt;GET_ACCOUNTS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LOCATION&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ACCESS_FINE_LOCATION&lt;/code&gt; &lt;code&gt;ACCESS_COARES_LOCATION&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MICROPHONE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;RECORD_AUDIO&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;PHONE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;READ_PHONE_STATE&lt;/code&gt; &lt;code&gt;CALL_PHONE&lt;/code&gt; &lt;code&gt;READ_CALL_LOG&lt;/code&gt; &lt;code&gt;WRITE_CALL_LOG&lt;/code&gt; &lt;code&gt;ADD_VOICEMAIL&lt;/code&gt; &lt;code&gt;USE_SIP&lt;/code&gt; &lt;code&gt;PROCESS_OUTGOING_CALLS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SENSORS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;BODY_SENSORS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SMS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SEND_SMS&lt;/code&gt; &lt;code&gt;RECEIVE_SMS&lt;/code&gt; &lt;code&gt;READ_SMS&lt;/code&gt; &lt;code&gt;RECEIVE_WAP_PUSH&lt;/code&gt; &lt;code&gt;RECEIVE_MMS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;STORAGE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;READ_EXTERNAL_STORAGE&lt;/code&gt; &lt;code&gt;WRITE_EXTERNAL_STORAGE&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;strong&gt;Android 4.4(SDK 19)&lt;/strong&gt;及以上版本中, 系统会对&lt;code&gt;getExternalFilesDir(String)&lt;/code&gt; 和&lt;code&gt;getExternalCacheDir()&lt;/code&gt;这两个方法返回的目录自动授予 &lt;code&gt;READ_EXTERNAL_STORAGE …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h5&gt;危险权限&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;权限组&lt;/th&gt;
&lt;th&gt;权限&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;CALENDAR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;WRITE_CALENDAR&lt;/code&gt; &lt;code&gt;READ_CALENDAR&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;CAMERA&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;CAMERA&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;CONTACTS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;READ_CONTACTS&lt;/code&gt; &lt;code&gt;WRITE_CONTACTS&lt;/code&gt; &lt;code&gt;GET_ACCOUNTS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;LOCATION&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ACCESS_FINE_LOCATION&lt;/code&gt; &lt;code&gt;ACCESS_COARES_LOCATION&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MICROPHONE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;RECORD_AUDIO&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;PHONE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;READ_PHONE_STATE&lt;/code&gt; &lt;code&gt;CALL_PHONE&lt;/code&gt; &lt;code&gt;READ_CALL_LOG&lt;/code&gt; &lt;code&gt;WRITE_CALL_LOG&lt;/code&gt; &lt;code&gt;ADD_VOICEMAIL&lt;/code&gt; &lt;code&gt;USE_SIP&lt;/code&gt; &lt;code&gt;PROCESS_OUTGOING_CALLS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SENSORS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;BODY_SENSORS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SMS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SEND_SMS&lt;/code&gt; &lt;code&gt;RECEIVE_SMS&lt;/code&gt; &lt;code&gt;READ_SMS&lt;/code&gt; &lt;code&gt;RECEIVE_WAP_PUSH&lt;/code&gt; &lt;code&gt;RECEIVE_MMS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;STORAGE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;READ_EXTERNAL_STORAGE&lt;/code&gt; &lt;code&gt;WRITE_EXTERNAL_STORAGE&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;strong&gt;Android 4.4(SDK 19)&lt;/strong&gt;及以上版本中, 系统会对&lt;code&gt;getExternalFilesDir(String)&lt;/code&gt; 和&lt;code&gt;getExternalCacheDir()&lt;/code&gt;这两个方法返回的目录自动授予 &lt;code&gt;READ_EXTERNAL_STORAGE&lt;/code&gt; &lt;code&gt;WRITE_EXTERNAL_STORAGE&lt;/code&gt;权限. 在低于&lt;strong&gt;API 19&lt;/strong&gt;的版本中, 需要在&lt;code&gt;manifest&lt;/code&gt;中声明所需权限&lt;/li&gt;
&lt;li&gt;虽然同一权限组里只要有一个权限是被允许的, 其所在组里其他权限也会被授予允许, 但不应该依赖于这个, 而是在申请权限时申请到所有权限, 因为以后权限分组有可能会变&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;Reference:&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://developer.android.google.cn/guide/topics/security/permissions.html?hl=zh-cn"&gt;Android Permissions , android offical site&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.android.google.cn/reference/android/Manifest.permission.html?hl=zh-cn#READ_EXTERNAL_STORAGE"&gt;Android API reference&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="android"></category><category term="系统权限"></category></entry><entry><title>Android 中自定义ViewPager, 添加页面指示器</title><link href="https://ivicel.info/2018/02/android-zhong-zi-ding-yi-viewpager-tian-jia-ye-mian-zhi-shi-qi.html" rel="alternate"></link><published>2018-02-22T00:00:00+08:00</published><updated>2018-02-22T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-02-22:/2018/02/android-zhong-zi-ding-yi-viewpager-tian-jia-ye-mian-zhi-shi-qi.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在页面滑动时会回调&lt;code&gt;ViewPager.OnPageChangeListener&lt;/code&gt;接口里的方法. 用&lt;code&gt;ViewPage.addOnPageChangeListener&lt;/code&gt;添加和&lt;code&gt;ViewPage.removeOnPageChangeListener&lt;/code&gt;删除监听回调方法. 如果不想实现所有方法, &lt;code&gt;ViewPager&lt;/code&gt;内有个空的类&lt;code&gt;SimpleOnPageChangeListener&lt;/code&gt;实现了这个接口, 继承这个类便可. &lt;strong&gt;注意可以多次调用&lt;code&gt;addOnPageChangeListener&lt;/code&gt;方法添加多个回调, &lt;code&gt;ViewPager&lt;/code&gt;按添加顺序进行调用, 所以在不需要回调时, 及时的使用&lt;code&gt;removeOnPageChangeListener&lt;/code&gt;来删除回调方法&lt;/strong&gt;. 另外还需要&lt;strong&gt;注意的是&lt;code&gt;ViewPager.getCurrentItem&lt;/code&gt;返回值和&lt;code&gt;OnPageSelected&lt;/code&gt;参数是一样的, 即是成功滑动后的目标页面索引, 无论当前页面是否还在滑动中&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在滑动的时候会调用&lt;code&gt;OnPageScrolled(int position, float positionOffset, int positionOffsetPixels)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数&lt;code&gt;position&lt;/code&gt;指的是在滑动时&lt;strong&gt;当前显示页面&lt;/strong&gt;的&lt;strong&gt;左边页面的位置&lt;/strong&gt;, 具体来说是 …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在页面滑动时会回调&lt;code&gt;ViewPager.OnPageChangeListener&lt;/code&gt;接口里的方法. 用&lt;code&gt;ViewPage.addOnPageChangeListener&lt;/code&gt;添加和&lt;code&gt;ViewPage.removeOnPageChangeListener&lt;/code&gt;删除监听回调方法. 如果不想实现所有方法, &lt;code&gt;ViewPager&lt;/code&gt;内有个空的类&lt;code&gt;SimpleOnPageChangeListener&lt;/code&gt;实现了这个接口, 继承这个类便可. &lt;strong&gt;注意可以多次调用&lt;code&gt;addOnPageChangeListener&lt;/code&gt;方法添加多个回调, &lt;code&gt;ViewPager&lt;/code&gt;按添加顺序进行调用, 所以在不需要回调时, 及时的使用&lt;code&gt;removeOnPageChangeListener&lt;/code&gt;来删除回调方法&lt;/strong&gt;. 另外还需要&lt;strong&gt;注意的是&lt;code&gt;ViewPager.getCurrentItem&lt;/code&gt;返回值和&lt;code&gt;OnPageSelected&lt;/code&gt;参数是一样的, 即是成功滑动后的目标页面索引, 无论当前页面是否还在滑动中&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在滑动的时候会调用&lt;code&gt;OnPageScrolled(int position, float positionOffset, int positionOffsetPixels)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数&lt;code&gt;position&lt;/code&gt;指的是在滑动时&lt;strong&gt;当前显示页面&lt;/strong&gt;的&lt;strong&gt;左边页面的位置&lt;/strong&gt;, 具体来说是&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;i.&lt;/em&gt; 在&lt;strong&gt;向右&lt;/strong&gt;滑动时, &lt;code&gt;position&lt;/code&gt;的值为当前页面的值, 如果滑动成功(即滑动到右一页面), &lt;code&gt;OnPageScrolled&lt;/code&gt;会被再一次调用, 此时&lt;code&gt;position&lt;/code&gt;的值为滑动成功后的页面&lt;code&gt;position+1&lt;/code&gt;, 如果滑动失败, &lt;code&gt;position&lt;/code&gt;依然不变&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; 从 `0`滑动`1`时, 滑动时`position`是`0`, 滑动成功后`OnPageScrolled`会再被调用一次且`position`会变成`1`, 滑动失败`position`依然为`0`, 这跟向左滑动有区别, 需要注意
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;ii.&lt;/em&gt; 在&lt;strong&gt;向左&lt;/strong&gt;滑动时, &lt;code&gt;position&lt;/code&gt;的值为滑动的目标页面, 滑动成功后, 不会再次调用&lt;code&gt;OnPageScrolled&lt;/code&gt;. 如果滑动失败, 最后一次会再次调用&lt;code&gt;OnPageScrolled&lt;/code&gt;, 此时&lt;code&gt;position&lt;/code&gt;为原先页面.&lt;/p&gt;
&lt;p&gt;​     从&lt;code&gt;1&lt;/code&gt;滑动到&lt;code&gt;0&lt;/code&gt;时, &lt;code&gt;position&lt;/code&gt;的值为&lt;code&gt;0&lt;/code&gt;, 成功滑动到页面&lt;code&gt;1&lt;/code&gt;后也不会再次调用该方法, 这个有区别于向右滑动. 然而如果滑动失败, 则会再一次调用该方法, 此时&lt;code&gt;position&lt;/code&gt;的值为&lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;参数&lt;code&gt;positionOffset&lt;/code&gt;指的是滑动时, &lt;code&gt;index&lt;/code&gt;为&lt;code&gt;position + 1&lt;/code&gt;的页面占显示窗口(&lt;code&gt;ViewPager&lt;/code&gt;)的百分比, 其取值为&lt;code&gt;[0, 1)&lt;/code&gt;, 当值为&lt;code&gt;0&lt;/code&gt;时, 页面停止滑动. &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;i.&lt;/em&gt; 向右滑动时, &lt;code&gt;positionOffset&lt;/code&gt;从&lt;code&gt;0&lt;/code&gt;变大到接近&lt;code&gt;1&lt;/code&gt;(不包含), 最后变成&lt;code&gt;0&lt;/code&gt;(滑动停止时)&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ii.&lt;/em&gt; 向左滑动时, &lt;code&gt;positionOffset&lt;/code&gt;从&lt;code&gt;1&lt;/code&gt;(不包含)变小到&lt;code&gt;0&lt;/code&gt;(当为&lt;code&gt;0&lt;/code&gt;时已经停止滑动)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;positionOffsetPixels&lt;/code&gt;指的是滑动像素值, 情况和&lt;code&gt;positionOffset&lt;/code&gt;是一致的. &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;i.&lt;/em&gt; 向右滑动, &lt;code&gt;positionOffsetPixels&lt;/code&gt;一直增大到和显示窗口(&lt;code&gt;ViewPager&lt;/code&gt;)一样, 滑动停止时变为&lt;code&gt;0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ii.&lt;/em&gt; 向左滑动, &lt;code&gt;positionOffsetPixels&lt;/code&gt;从窗口大小一直减小到&lt;code&gt;0&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OnPageSelected(int position)&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;该方法会在滑动成功时立即被调用, 滑动成功的意思指手指在滑动页面&lt;strong&gt;足够长&lt;/strong&gt;的距离后, 手指离开屏幕的一瞬间, 屏幕会自行滑动到目标页面即为滑动成功; 如果&lt;strong&gt;距离不够&lt;/strong&gt;, 页面会回弹, 即为滑动失败. &lt;code&gt;OnPageSelected&lt;/code&gt;会在滑动成功的瞬间立即被调用, 无论当前页面是否还在滑动中. &lt;code&gt;position&lt;/code&gt;指的是目标页面的索引值. &lt;strong&gt;注意&lt;code&gt;OnPageSelected&lt;/code&gt;在调用时, &lt;code&gt;OnPageScrolled&lt;/code&gt;可能会还在继续被调用中&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OnPageScrollStateChanged(int state)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该方法在页面状态有改变时会调用, &lt;code&gt;state&lt;/code&gt;指当前页面的状态, 一共有三个状态. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;i.&lt;/em&gt; &lt;code&gt;ViewPager.SCROLL_STATE_DRAGGING&lt;/code&gt; 页面在拖拽, 值为&lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ii.&lt;/em&gt; &lt;code&gt;ViewPager.SCROLL_STATE_SETTLING&lt;/code&gt; 手指离开屏幕, 页面正滑向目标页面, 值为&lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;iii.&lt;/em&gt; &lt;code&gt;ViewPager.SCROLL_STATE_IDLE&lt;/code&gt; 页面空闲中, 无任何滑动拖拽动画, 值为&lt;code&gt;0&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;页面的状态总是会经历&lt;code&gt;1&lt;/code&gt;,  &lt;code&gt;2&lt;/code&gt;,  &lt;code&gt;0&lt;/code&gt;的顺序状态, 手指按到屏幕时, 状态为&lt;code&gt;1&lt;/code&gt;, 手指离开屏幕时, 状态为&lt;code&gt;2&lt;/code&gt;, 页面无任何动画时, 状态为&lt;code&gt;0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;Reference:&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://dalufan.com/2015/09/08/android-setOnPageChangeListener/"&gt;http://dalufan.com/2015/09/08/android-setOnPageChangeListener/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="android"></category><category term="viewpager"></category><category term="页面指示器"></category></entry><entry><title>Android高效加载图片防止OOM</title><link href="https://ivicel.info/2018/02/androidgao-xiao-jia-zai-tu-pian-fang-zhi-oom.html" rel="alternate"></link><published>2018-02-22T00:00:00+08:00</published><updated>2018-02-22T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-02-22:/2018/02/androidgao-xiao-jia-zai-tu-pian-fang-zhi-oom.html</id><summary type="html">&lt;p&gt;想要高效的加载 Bitmap, 最主要的思想就是只加载能显示的尺寸大小. 其通 &lt;code&gt;BitmapFactory.Options&lt;/code&gt; 里的 &lt;code&gt;option.inSampleSize&lt;/code&gt; 来设置图片的采样率. 图片的&lt;strong&gt;长&lt;/strong&gt;和&lt;strong&gt;宽&lt;/strong&gt;都会被设置成 *&lt;em&gt;1/&lt;code&gt;option.inSampleSize&lt;/code&gt; *&lt;/em&gt; 大小.即当为 1 时, 为原始大小; 当为 2 时, 图片为 &lt;code&gt;(长 * 1/2) * (宽 * 1/2) * 4&lt;/code&gt;(ARGB8888), 缩小了 4 倍. 即图片会被设置成 &lt;code&gt;1/option.inSampleSize * 1/option.inSampleSize&lt;/code&gt; 大小.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;inSampleSize&lt;/code&gt; 一般取为 2 的指数 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;想要高效的加载 Bitmap, 最主要的思想就是只加载能显示的尺寸大小. 其通 &lt;code&gt;BitmapFactory.Options&lt;/code&gt; 里的 &lt;code&gt;option.inSampleSize&lt;/code&gt; 来设置图片的采样率. 图片的&lt;strong&gt;长&lt;/strong&gt;和&lt;strong&gt;宽&lt;/strong&gt;都会被设置成 *&lt;em&gt;1/&lt;code&gt;option.inSampleSize&lt;/code&gt; *&lt;/em&gt; 大小.即当为 1 时, 为原始大小; 当为 2 时, 图片为 &lt;code&gt;(长 * 1/2) * (宽 * 1/2) * 4&lt;/code&gt;(ARGB8888), 缩小了 4 倍. 即图片会被设置成 &lt;code&gt;1/option.inSampleSize * 1/option.inSampleSize&lt;/code&gt; 大小.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;inSampleSize&lt;/code&gt; 一般取为 2 的指数, 有些系统会对其向下取整为近似 2 的指数, 但不是所有系统都会这么做. 如果当长和宽的 &lt;code&gt;inSampleSize&lt;/code&gt; 不一样时, 取较小的值, 这样可以让图片不至于模糊&lt;/p&gt;
&lt;p&gt;生成所需大小的 bitmap 的一般步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt; 一个新 &lt;code&gt;BitmapFactory.Options&lt;/code&gt; 对象, 并将其 &lt;code&gt;BitmapFactory.Options.inJustDecodeBounds&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt;, 这样可以使其解析图片时, 并不会加载图片而只是解读其中信息&lt;/li&gt;
&lt;li&gt;获得图片的长和宽, 分别为所期望的长和宽进行对比, 取其中&lt;strong&gt;比值大&lt;/strong&gt;的数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BitmapFactory.Options.inJustDecodeBounds&lt;/code&gt; 设置成 &lt;code&gt;false&lt;/code&gt;, 重新解析出所需图片&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;lt;&lt;Android开发权威指南&gt;&amp;gt;依据想需要的大小生成 &lt;code&gt;bitmap&lt;/code&gt;, 其取的值是较大值, 然后向下取整. 这样能获得更小的分辨率, 占用的内存更小&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public Bitmap loadSpecifySizeImage(String imagePath, int destWidth, int destHeight) {
    BitmapFactory.Options options = new BitmapFactory.Options();
    /* 设置为true后, 在decode时不会真的加载图片而是获取图片信息 */
    options.inJustDecodeBounds = true;
    BitmapFactory.decodeFile(imagePath, options);
    int srcWidth = options.outWidth;
    int srcHeight = options.outHeight;
    int inSampleSize = 1;
    if (srcWidth &amp;gt; destWidth || srcHeight &amp;gt; destHeight) {
        float widthScale = srcWidth / destWidth;
        float heightScale = srcHeight / destHeight;
        /* inSampleSize指的是将原图片的长宽都按 1/inSampleSize 缩放, 所以取比例较大的值 */
        inSampleSize = Math.round(widhtScale &amp;gt; heightScale ? widthScale : heightScale);
    }
    options.inJustDecodeBounds = false;
    options.inSampleSize = inSampleSize;
    return BitmapFactory.decodeFile(imagePath, options);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Android Develper 官网的示例, 其严格的按 2 的倍数来取值&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public Bitmap loadSpecifySizeImage(String imagePath, int destWidth, int destHeight) {
    BitmapFactory.Options options = new BitmapFactory.Options();
    options.inJustDecodeBounds = true;
    BitmapFactory.decodeFile(imagePath, options);
    int inSampleSize = 1;
    if (options.outWidth &amp;gt; destWidth || options.outHeight &amp;gt; destHeight) {
        // 取一半值, 按 2 的倍数
        final int halfWidth = options.outWidth / 2;
        final int halfHeight = opitons.outHeight / 2;
        while (halfWidth / inSampleSize &amp;gt;= destWidth &amp;amp;&amp;amp;
               halfHeight / inSampleSize &amp;gt;= destHeight) {
            inSampleSize *= 2;   
        }
    }

    options.inJustDecodeBounds = false;
    otpions.inSampleSize = inSampleSize;
    return BitmapFactory.decodeFile(imagePath, options);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Reference&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&amp;lt;&lt;Android开发艺术&gt;&amp;gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;&lt;Android开发权威指南&gt;&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.android.com/topic/performance/graphics/load-bitmap.html"&gt;https://developer.android.com/topic/performance/graphics/load-bitmap.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="andorid图片加载"></category></entry><entry><title>Anroid FileProvider的使用</title><link href="https://ivicel.info/2018/02/anroid-fileproviderde-shi-yong.html" rel="alternate"></link><published>2018-02-22T00:00:00+08:00</published><updated>2018-02-22T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-02-22:/2018/02/anroid-fileproviderde-shi-yong.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;FileProvider&lt;/code&gt; 是在 &lt;code&gt;v4 support library&lt;/code&gt; 里的, 使用之前要添加 &lt;code&gt;v4 support library&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;默认 &lt;code&gt;v7 support&lt;/code&gt; 继承了 &lt;code&gt;v4&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;在&lt;code&gt;manifest&lt;/code&gt;中指定分享的文件, 具体的分享目录路径在&lt;code&gt;res/xml/filepaths&lt;/code&gt;中指定, &lt;code&gt;android:authorities&lt;/code&gt;为指定的认证, 自行定义, 一般为 &lt;code&gt;package name&lt;/code&gt; + &lt;code&gt;fileprovider&lt;/code&gt;, 其他为固定写法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.myapp"&amp;gt;
      &amp;lt;application
        ...&amp;gt;

        &amp;lt;provider
            android:name …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;FileProvider&lt;/code&gt; 是在 &lt;code&gt;v4 support library&lt;/code&gt; 里的, 使用之前要添加 &lt;code&gt;v4 support library&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;默认 &lt;code&gt;v7 support&lt;/code&gt; 继承了 &lt;code&gt;v4&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;在&lt;code&gt;manifest&lt;/code&gt;中指定分享的文件, 具体的分享目录路径在&lt;code&gt;res/xml/filepaths&lt;/code&gt;中指定, &lt;code&gt;android:authorities&lt;/code&gt;为指定的认证, 自行定义, 一般为 &lt;code&gt;package name&lt;/code&gt; + &lt;code&gt;fileprovider&lt;/code&gt;, 其他为固定写法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.myapp"&amp;gt;
      &amp;lt;application
        ...&amp;gt;

        &amp;lt;provider
            android:name="android.support.v4.content.FileProvider"
            android:authorities="com.example.myapp.fileprovider"
            android:grantUriPermissions="true"
            android:exported="false"&amp;gt;
            &amp;lt;meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/filepaths"/&amp;gt;
        &amp;lt;/provider&amp;gt;

        ...
    &amp;lt;/application&amp;gt;
&amp;lt;/manifest&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;res/xml/filepaths&lt;/code&gt;写法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-xml"&gt;&amp;lt;paths&amp;gt;
  &amp;lt;files-path path="images" name="my-images"/&amp;gt;
  &amp;lt;cache-path path="..." name="..."/&amp;gt;
  &amp;lt;external-files-path path="...." name="..."/&amp;gt;
  &amp;lt;external-cache-path path="...." name="..."/&amp;gt;
  &amp;lt;external-path path="..." name="...."/&amp;gt;
&amp;lt;/paths&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;file-path&lt;/code&gt;为&lt;code&gt;Context.getFilesDir()&lt;/code&gt;代表的目录, 内部(&lt;strong&gt;internal&lt;/strong&gt;)存储目录&lt;code&gt;files/&lt;/code&gt;.可能有两个位置, &lt;code&gt;/data/data/package_name/files&lt;/code&gt;下, 或者&lt;code&gt;/data/user/../package_name/files&lt;/code&gt;下&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cache-path&lt;/code&gt;为&lt;code&gt;Context.getCacheDir()&lt;/code&gt;代表的内部目录 &lt;code&gt;cache/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;external-files-path&lt;/code&gt;为外部存储目录&lt;code&gt;Context#getExternalFilesDir(String)&lt;/code&gt; 和&lt;code&gt;Context.getExternalFilesDir(null)&lt;/code&gt;这个目录一般在外部存储中的&lt;code&gt;Android/data/package_name/files&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;external-cache-path&lt;/code&gt;为外部缓存目录&lt;code&gt;Android/data/package_name/cache&lt;/code&gt;中, 由&lt;code&gt;Context.getExternalCacheDir()&lt;/code&gt;获得&lt;/li&gt;
&lt;li&gt;&lt;code&gt;external-path&lt;/code&gt;为外部存储的根目录&lt;code&gt;Context.getExternalStorageDirectory()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果使用外部目录, 因为存在 &lt;code&gt;SDCard&lt;/code&gt;可插拔的原因, 最好使用&lt;code&gt;Environment.getExternalStorageState()&lt;/code&gt;来检测当前外部存储状态, 返回&lt;code&gt;Environment.MEDIA_MOUNTED&lt;/code&gt;表示存储可用.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;path="path"&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代表是指定目录下的子目录, 或者当前目录(使用&lt;code&gt;.&lt;/code&gt;表示共享当前目录)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;name="name"&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代表将共享的目录名称(&lt;code&gt;path&lt;/code&gt;)在生成&lt;code&gt;content://uri&lt;/code&gt;时替换成这个值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;FileProvider.getUriForFile(Context, String, File)&lt;/code&gt;方法来获取共享的文件&lt;code&gt;uri&lt;/code&gt;路径&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;/* 生成 content://com.example.myapp.fileprovider/my_images/default_image.jpg */
File imagePath = new File(context.getFilesPath(), "images");
File newFile = new File(imagePath, "default_image.jpg");
Uri contentUri = FileProvider.getUriForFile(context, "com.example.myapp.fileprovider",
     newFile);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;authorities&lt;/code&gt;参数要和&lt;code&gt;meta-data&lt;/code&gt;中写的一样, 不然会找不到共享目录, 抛出错误. &lt;code&gt;getUriForFile&lt;/code&gt;会在设定好的&lt;code&gt;xml&lt;/code&gt;文件中从上逐行进行匹配, 若匹配不到任何一行, 抛出&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;给&lt;code&gt;uri&lt;/code&gt;授予权限, 为了兼容&lt;strong&gt;Kitkat&lt;/strong&gt;(SDK 19)及以下的Android版本, 一定要对&lt;code&gt;uri&lt;/code&gt;授予读写权限. 在&lt;code&gt;Kitkat&lt;/code&gt;以上的版本会自动授予权限.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;Context.grantUriPermissioin(package, Uri, mode_flags)&lt;/code&gt;来授权, 比如&lt;code&gt;Intent.FLAG_GRANT_READ_URI_PERMISSIOIN&lt;/code&gt;和&lt;code&gt;Intent.FLAG_GRANT_WRITE_URI_PERMISSION&lt;/code&gt;标志位, 在适当的时候使用&lt;code&gt;Context.revokeUriPermission(Uri, mode_flags)&lt;/code&gt;来去掉授予的权限&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;或者使用&lt;code&gt;Intent.setData()&lt;/code&gt;把&lt;code&gt;uri&lt;/code&gt;放到&lt;code&gt;intent&lt;/code&gt;中后, 使用&lt;code&gt;Intent.setFlags()&lt;/code&gt;来设置权限标志位, 建议使用这种授权方式, 这样就不用手动来取消授权了&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;List&amp;lt;ResolveInfo&amp;gt; resolveActivities = getPackageManager().queryInetntActivities(
     imageCapture, PackageManager.MATCH_DEFAULT_ONLY);
/* 为每个activity授权 */
for (ResolveInfo resolveActivity : resolveActivities) {
    grantUriPermission(resolveActivity.activityInfo.packageName, uri,
         Intent.FLAG_GRANT_WRITE_PERMISSION);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​&lt;/p&gt;
&lt;h5&gt;Reference:&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://developer.android.google.cn/reference/android/support/v4/content/FileProvider.html?hl=zh-cn#getUriForFile(android.content.Context, java.lang.String, java.io.File)"&gt;Android Developer FileProvider&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.android.google.cn/training/secure-file-sharing"&gt;Android Tranning Share a File&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="android"></category><category term="fileprovider"></category></entry><entry><title>Interpolator值</title><link href="https://ivicel.info/2018/02/interpolatorzhi.html" rel="alternate"></link><published>2018-02-22T00:00:00+08:00</published><updated>2018-02-22T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-02-22:/2018/02/interpolatorzhi.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="android"></category><category term="interpolator"></category></entry><entry><title>Java小数舍位情况</title><link href="https://ivicel.info/2018/02/javaxiao-shu-she-wei-qing-kuang.html" rel="alternate"></link><published>2018-02-22T00:00:00+08:00</published><updated>2018-02-22T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-02-22:/2018/02/javaxiao-shu-she-wei-qing-kuang.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ROUND_UP&lt;/code&gt;：远离零方向舍入。向绝对值最大的方向舍入，只要舍弃位非 0 即进位。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ROUND_DOWN&lt;/code&gt;：趋向零方向舍入。向绝对值最小的方向输入，所有的位都要舍弃，不存在进位情况。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ROUND_CEILING&lt;/code&gt;：向正无穷方向舍入。向正最大方向靠拢。若是正数，舍入行为类似于 &lt;code&gt;ROUND_UP&lt;/code&gt;，若为负数，舍入行为类似于 &lt;code&gt;ROUND_DOWN&lt;/code&gt;。&lt;code&gt;Math.round()&lt;/code&gt; 方法就是使用的此模式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ROUND_FLOOR&lt;/code&gt;：向负无穷方向舍入。向负无穷方向靠拢。若是正数，舍入行为类似于 &lt;code&gt;ROUND_DOWN&lt;/code&gt;；若为负数，舍入行为类似于 &lt;code&gt;ROUND_UP&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HALF_UP&lt;/code&gt;：最近数字舍入 (5 进)。这是我们最经典的四舍五入。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HALF_DOWN&lt;/code&gt;：最近数字舍入 (5 舍)。在这里 5 是要舍弃的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HAIL_EVEN&lt;/code&gt;：银行家舍入法。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;银行家舍入法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;舍去位小于5时, 直接舍去&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;舍去位大于5时 …&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ROUND_UP&lt;/code&gt;：远离零方向舍入。向绝对值最大的方向舍入，只要舍弃位非 0 即进位。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ROUND_DOWN&lt;/code&gt;：趋向零方向舍入。向绝对值最小的方向输入，所有的位都要舍弃，不存在进位情况。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ROUND_CEILING&lt;/code&gt;：向正无穷方向舍入。向正最大方向靠拢。若是正数，舍入行为类似于 &lt;code&gt;ROUND_UP&lt;/code&gt;，若为负数，舍入行为类似于 &lt;code&gt;ROUND_DOWN&lt;/code&gt;。&lt;code&gt;Math.round()&lt;/code&gt; 方法就是使用的此模式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ROUND_FLOOR&lt;/code&gt;：向负无穷方向舍入。向负无穷方向靠拢。若是正数，舍入行为类似于 &lt;code&gt;ROUND_DOWN&lt;/code&gt;；若为负数，舍入行为类似于 &lt;code&gt;ROUND_UP&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HALF_UP&lt;/code&gt;：最近数字舍入 (5 进)。这是我们最经典的四舍五入。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HALF_DOWN&lt;/code&gt;：最近数字舍入 (5 舍)。在这里 5 是要舍弃的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HAIL_EVEN&lt;/code&gt;：银行家舍入法。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;银行家舍入法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;舍去位小于5时, 直接舍去&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;舍去位大于5时, 直接进1后舍去&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;舍去位等于5时:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1) 舍去位后面有数, 则直接进位1, 然后舍去&lt;/p&gt;
&lt;p&gt;2) 舍去位后面没数. &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  1. 如果舍去位前为**偶数**, 则直接舍去不进位
  2. 如果舍去位前为**奇数**, 则进位后舍去
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;举例, 要舍去的位为&lt;strong&gt;粗体&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;11.55&lt;strong&gt;4&lt;/strong&gt;  =&amp;gt;  11.55     // 小于5&lt;/p&gt;
&lt;p&gt;11.55&lt;strong&gt;6&lt;/strong&gt;  =&amp;gt;  11.56         // 大于5&lt;/p&gt;
&lt;p&gt;11.55&lt;strong&gt;5&lt;/strong&gt;1  =&amp;gt;  11.556   // 舍去位后面有数, 进位&lt;/p&gt;
&lt;p&gt;11.54&lt;strong&gt;5&lt;/strong&gt;  =&amp;gt;   11.55        // 舍去位后面没数, 前为偶数, 直接舍去&lt;/p&gt;
&lt;p&gt;11.55&lt;strong&gt;5&lt;/strong&gt;  =&amp;gt;   11.56        // 舍去位后面没数, 前为奇数, 直接进位&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Reference:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://cmsblogs.com/?p=54"&gt;http://cmsblogs.com/?p=54&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="java"></category></entry><entry><title>Java中static关键字以及修饰符</title><link href="https://ivicel.info/2018/02/javazhong-staticguan-jian-zi-yi-ji-xiu-shi-fu.html" rel="alternate"></link><published>2018-02-22T00:00:00+08:00</published><updated>2018-02-22T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-02-22:/2018/02/javazhong-staticguan-jian-zi-yi-ji-xiu-shi-fu.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;类中的变量会按照定义的先后顺序来进行初始化, 并且优先于任何方法(包括构造方法)&lt;/p&gt;
&lt;p&gt;另外, &lt;code&gt;static&lt;/code&gt;变量会优先于普通变量进行初始化, &lt;code&gt;static&lt;/code&gt;变量也是按顺序&lt;/p&gt;
&lt;p&gt;只有&lt;code&gt;static&lt;/code&gt;初始化完成, 普通变量才会初始化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;1. &lt;code&gt;static&lt;/code&gt;修饰类&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 修饰内部类时, 内部类是一个嵌套类, 不含有指向外部类的引用
// 只能使用外部类的 static 变量和方法
public class OutterClass {
  public OutterClass() {}

  public static class InnerClass {}
}   &lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. &lt;code&gt;static&lt;/code&gt;修饰成员变量&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 修饰类成员变量时, 变量值会在第一次访问类时被赋值, 第一次new, 第一次访问变量



class Bowl {
    Bowl(int marker) {
        System.out.println("Bowl(" + marker + ")");
    }

    void f1 …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;类中的变量会按照定义的先后顺序来进行初始化, 并且优先于任何方法(包括构造方法)&lt;/p&gt;
&lt;p&gt;另外, &lt;code&gt;static&lt;/code&gt;变量会优先于普通变量进行初始化, &lt;code&gt;static&lt;/code&gt;变量也是按顺序&lt;/p&gt;
&lt;p&gt;只有&lt;code&gt;static&lt;/code&gt;初始化完成, 普通变量才会初始化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;1. &lt;code&gt;static&lt;/code&gt;修饰类&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 修饰内部类时, 内部类是一个嵌套类, 不含有指向外部类的引用
// 只能使用外部类的 static 变量和方法
public class OutterClass {
  public OutterClass() {}

  public static class InnerClass {}
}   &lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. &lt;code&gt;static&lt;/code&gt;修饰成员变量&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 修饰类成员变量时, 变量值会在第一次访问类时被赋值, 第一次new, 第一次访问变量



class Bowl {
    Bowl(int marker) {
        System.out.println("Bowl(" + marker + ")");
    }

    void f1(int marker) {
        System.out.println("class Bowl: f1(" + marker + ")");
    }
}

class Table {
    static Bowl bowl1 = new Bowl(1);
    Table() {
        System.out.println("Table()");
        bowl1.f1(1);
    }

    void f2(int marker) {
        System.out.println("class Table: f2(" + marker + ")");
    }

    static Bowl bow2 = new Bowl(2);
}

class Cupboard {
    Bowl bowl3 = new Bowl(3);
    static Bowl bowl4 = new Bowl(4);
    Cupboard() {
        System.out.println("Cupboard()");
        bowl4.f1(2);
    }

    void f3(int marker) {
        System.out.println("Cupboard");
        bowl4.f1(2);
    }

    static Bowl bowl5 = new Bowl(5);
}

public class StaticTest {
    public static void main(String[] args) {
        System.out.println("Creating new Cupboard() in main.....first");
        new Cupboard();
        System.out.println("Creating new Cupborad() in main.....second");
        new Cupboard();
        table.f2(1);
        cupboard.f3(1);
    }

    static Table table = new Table();
    static Cupboard cupboard = new Cupboard();
}

// 输出
/*
Bowl(1)
Bowl(2)
Table()
class Bowl: f1(1)
Bowl(4)
Bowl(5)
Bowl(3)
Cupboard()
class Bowl: f1(2)
Creating new Cupboard() in main.....first
Bowl(3)
Cupboard()
class Bowl: f1(2)
Creating new Cupborad() in main.....second
Bowl(3)
Cupboard()
class Bowl: f1(2)
class Table: f2(1)
Cupboard
class Bowl: f1(2)
*/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在程序运行后, 首先会触发类&lt;code&gt;StaticTest&lt;/code&gt;的两个&lt;code&gt;static&lt;/code&gt;变量的初始化&lt;/p&gt;
&lt;p&gt;&lt;code&gt;static Table table = new Table()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这句会使类&lt;code&gt;Table&lt;/code&gt;中的&lt;code&gt;static&lt;/code&gt;变量初始化, 而后在&lt;code&gt;cupboard&lt;/code&gt;的初始化中可以看到&lt;code&gt;static&lt;/code&gt;的&lt;code&gt;bowl4&lt;/code&gt; &lt;code&gt;bowl5&lt;/code&gt;会优先非&lt;code&gt;static&lt;/code&gt;初始化&lt;/p&gt;
&lt;p&gt;&lt;code&gt;static Cupboard cupboard = new Cupboard()&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;3. &lt;code&gt;static&lt;/code&gt;修饰代码块&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// static 在修饰代码块时同修饰成员方法是一样的, 只初始化一次
public class StaticTest {
    static int n;
    static int m;

    static {
        n = 5;
        m = 6;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;4. &lt;code&gt;static&lt;/code&gt;修饰类方法&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;static&lt;/code&gt;修饰的类方法可以使用&lt;code&gt;类名.方法名&lt;/code&gt;进行访问, 相当一个全局方法. &lt;code&gt;static&lt;/code&gt;方法只能访问&lt;code&gt;static&lt;/code&gt;变量和调用 &lt;code&gt;static&lt;/code&gt;方法&lt;/p&gt;
&lt;h4&gt;5. &lt;code&gt;Java&lt;/code&gt; 修饰类&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;修饰符&lt;/th&gt;
&lt;th&gt;当前类&lt;/th&gt;
&lt;th&gt;同一包内&lt;/th&gt;
&lt;th&gt;子孙类&lt;/th&gt;
&lt;th&gt;其他包&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;protected&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;default&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;private&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="java"></category><category term="静态static"></category><category term="java修饰符"></category></entry><entry><title>View 事件体系</title><link href="https://ivicel.info/2018/02/view-shi-jian-ti-xi.html" rel="alternate"></link><published>2018-02-22T00:00:00+08:00</published><updated>2018-02-22T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-02-22:/2018/02/view-shi-jian-ti-xi.html</id><summary type="html">&lt;h5&gt;&lt;code&gt;view&lt;/code&gt;坐标和滑动方法&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;触摸事件&lt;code&gt;MotionEvent&lt;/code&gt;和&lt;code&gt;TouchSlop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;单指触摸屏幕时, 一般会产生&lt;code&gt;MotionEvent.ACTION_DOWN&lt;/code&gt;(手指接触屏幕时), &lt;code&gt;MotionEvent.ACTION_MOVE&lt;/code&gt;(手指移动时), &lt;code&gt;MotionEvent.ACTION_UP&lt;/code&gt;(手指离开屏幕时). &lt;/p&gt;
&lt;p&gt;触摸事件产生时, 可以获取其位置.&lt;/p&gt;
&lt;p&gt;获取其相对&lt;strong&gt;当前&lt;code&gt;View&lt;/code&gt;&lt;/strong&gt;的位置: 相对左边&lt;code&gt;MotionEvent.getX()&lt;/code&gt;, 相对上边&lt;code&gt;MotionEvent.getY()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取共相对&lt;strong&gt;屏幕&lt;/strong&gt;的位置: 相对屏幕左边&lt;code&gt;MotionEvent.getRawX()&lt;/code&gt;, 相对屏幕上边&lt;code&gt;MotionEvent.getRawY()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TouchSlop&lt;/code&gt;为系统所能识别出的最小的距离, 其值由系统决定. 可以通过&lt;code&gt;ViewConfiguration.getScaledTouchSlop()&lt;/code&gt;来获得&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;滑动速度追踪&lt;code&gt;VelocityTracker&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;滑动速度指的是在某一个时间段内的速度. &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;/* 首先可以在 View …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;h5&gt;&lt;code&gt;view&lt;/code&gt;坐标和滑动方法&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;触摸事件&lt;code&gt;MotionEvent&lt;/code&gt;和&lt;code&gt;TouchSlop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;单指触摸屏幕时, 一般会产生&lt;code&gt;MotionEvent.ACTION_DOWN&lt;/code&gt;(手指接触屏幕时), &lt;code&gt;MotionEvent.ACTION_MOVE&lt;/code&gt;(手指移动时), &lt;code&gt;MotionEvent.ACTION_UP&lt;/code&gt;(手指离开屏幕时). &lt;/p&gt;
&lt;p&gt;触摸事件产生时, 可以获取其位置.&lt;/p&gt;
&lt;p&gt;获取其相对&lt;strong&gt;当前&lt;code&gt;View&lt;/code&gt;&lt;/strong&gt;的位置: 相对左边&lt;code&gt;MotionEvent.getX()&lt;/code&gt;, 相对上边&lt;code&gt;MotionEvent.getY()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取共相对&lt;strong&gt;屏幕&lt;/strong&gt;的位置: 相对屏幕左边&lt;code&gt;MotionEvent.getRawX()&lt;/code&gt;, 相对屏幕上边&lt;code&gt;MotionEvent.getRawY()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TouchSlop&lt;/code&gt;为系统所能识别出的最小的距离, 其值由系统决定. 可以通过&lt;code&gt;ViewConfiguration.getScaledTouchSlop()&lt;/code&gt;来获得&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;滑动速度追踪&lt;code&gt;VelocityTracker&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;滑动速度指的是在某一个时间段内的速度. &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;/* 首先可以在 View 中的 onTouchEvent 内获得追踪事件 */
VelocityTracker vt = VelocityTracker.obtain();
vt.addMovement(event);
/* 然后必须要先设定时间段以便计算出该时间内的速度, 最后再获取速度, 速度为负时表示向左滑动 */
vt.computeCurrentVelocity(1000);          //计算1000ms内的速度
int xVelocity = (int)vt.getXVelocity();       //横向速度, 手指向左滑动为负
int yVelocity = (int)vt.getYVelocity();       //纵向速度, 手指向上滑动为负
/* 回收内存 */
vt.clear();
vt.recycle();&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;手势检测&lt;code&gt;GestureDetector&lt;/code&gt;, 单击, 滑动, 长按, 双击&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 在view 里onTouchEvent中截断事件来进行监听
GestureDetector mGestureDetector = new GestureDetector(context);
// 设置是否需要长按
mGestureDetector.setIsLongpressEnabled(false);
return mGestureDetector.onTouchEvent(event);&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GestureDetector.OnGestureListener&lt;/code&gt;接口&lt;ol&gt;
&lt;li&gt;&lt;code&gt;onDown&lt;/code&gt;手指触摸到屏幕时.由一个&lt;code&gt;ACTION_DOWN&lt;/code&gt;触发&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onShowPress&lt;/code&gt;手指触摸到屏但没有松开或者是移动, 一般用来给用户触摸找反馈, 高亮文本.由一个&lt;code&gt;ACTION_DOWN&lt;/code&gt;触发.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onSingleTapUp&lt;/code&gt;手指(在触摸后)松开, 单击行为. 伴随一个&lt;code&gt;MotionEvent.ACTION_UP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onScroll&lt;/code&gt;手指触摸屏幕后滚动, 由一个&lt;code&gt;ACTION_DOWN&lt;/code&gt;和多个&lt;code&gt;ACTION_MOVE&lt;/code&gt;触发&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onLongPress&lt;/code&gt;触摸后长按&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onFling&lt;/code&gt;按下屏幕后, 快速滑动后松开. 由一个&lt;code&gt;ACTION_DOWN&lt;/code&gt;和多个&lt;code&gt;ACTION_MOVE&lt;/code&gt;和一个&lt;code&gt;ACTION_UP&lt;/code&gt;触发&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;GestureDetector.OnDoubleTapListener&lt;/code&gt;接口&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;onDoubleTap&lt;/code&gt;双击. 不能和&lt;code&gt;onSingleTapConfirmed&lt;/code&gt;共存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onSingleTapConfirmed&lt;/code&gt;严格的单击行为. 如果触发了这个, 即使接下快速第二次触击也会被认为是一次单击而不是产生双击行为.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onDoubleTapEvent&lt;/code&gt;表示发生了双击行为. 会依次调用&lt;code&gt;ACTION_DOWN&lt;/code&gt;, &lt;code&gt;ACTION_MOVE&lt;/code&gt;, &lt;code&gt;ACTION_UP&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;view&lt;/code&gt;的滑动方法. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;code&gt;view.scrollTo&lt;/code&gt;和&lt;code&gt;view.scrollBy&lt;/code&gt;方法滑动&lt;/p&gt;
&lt;p&gt;注意这两个方法滚动的&lt;strong&gt;并非&lt;code&gt;view&lt;/code&gt;本身&lt;/strong&gt;而是&lt;strong&gt;&lt;code&gt;view&lt;/code&gt;的内容&lt;/strong&gt;, 所以要想滑动某个&lt;code&gt;view&lt;/code&gt;, 需要获取到其父&lt;code&gt;view&lt;/code&gt;然后到父&lt;code&gt;view&lt;/code&gt;进行滑动. 即&lt;code&gt;((View)childView.getParent()).scrollX&lt;/code&gt;如此.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;scrollBy&lt;/code&gt;其中也是调用&lt;code&gt;scrollTo&lt;/code&gt;来滑动, 只不过中内部进行了计算&lt;code&gt;scrollTo(offsetX + mScrollX, offsetY + mScrollY)&lt;/code&gt;. 而&lt;code&gt;scrollTo&lt;/code&gt;在内部调用了&lt;code&gt;invalidateInternal(left - mScrollX, top - mScrollY, right - mScrollX, bottom - mScrollY, true, false)&lt;/code&gt;, 其中&lt;code&gt;left&lt;/code&gt;, &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt;为上次的坐标点. 所以当传入&lt;strong&gt;负数&lt;/strong&gt;的时候才是向右移动&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mScrollX&lt;/code&gt;和&lt;code&gt;mScrollY&lt;/code&gt;分别左内容边框到view左边框, 上内容边框到view上边框的大小, 可以通过&lt;code&gt;view.getScrollX()&lt;/code&gt;, &lt;code&gt;view.getScrollY()&lt;/code&gt;获得该值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过动画给&lt;code&gt;view&lt;/code&gt;施加平移效果&lt;/p&gt;
&lt;p&gt;这种方法便是通过改变&lt;code&gt;view&lt;/code&gt;的&lt;code&gt;translationX&lt;/code&gt;和&lt;code&gt;translationY&lt;/code&gt;值. &lt;/p&gt;
&lt;p&gt;老旧的动画方法并没有真的改变了&lt;code&gt;view&lt;/code&gt;的位置, 所以在&lt;code&gt;view&lt;/code&gt;"移动"到新位置时, 其一些比如单击事件并不能通过点击新位置产生. 这些可以使用属性动画解决, 而现在也只使用属性动画(Property Animator)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过改变&lt;code&gt;view&lt;/code&gt;的&lt;code&gt;LayoutParams&lt;/code&gt;参数使得&lt;code&gt;view&lt;/code&gt;重新布局&lt;/p&gt;
&lt;p&gt;比如发变&lt;code&gt;view&lt;/code&gt;的&lt;code&gt;margin&lt;/code&gt;等等, 或者通其一些关联的&lt;code&gt;view&lt;/code&gt;做变化, 以便影响到目标&lt;code&gt;view&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;比如在一个垂直的&lt;code&gt;LinearLayout&lt;/code&gt;, 上边是一个高度为0的&lt;code&gt;view&lt;/code&gt;, 下面为目标&lt;code&gt;view&lt;/code&gt;, 通过改变上边&lt;code&gt;view&lt;/code&gt;的高度来使用目标&lt;code&gt;view&lt;/code&gt;的高度发生变化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;Scroller&lt;/code&gt;类.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Scroller&lt;/code&gt;类是一个滑动的&lt;code&gt;Helper&lt;/code&gt;类, 其本质上是使用&lt;code&gt;view.scrollTo&lt;/code&gt;方法来滑动, 但内部有一个可定义&lt;code&gt;Interpolator&lt;/code&gt;类, 即插值属性来提供滑动变动曲线, 使得滑动更加的流畅.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-Java"&gt; /* 一般使用 Scroller 类来滚动 View 时, 都使用在自定义 View 中 
  * 在自定义 View 的构造方法获取一个 Scroller 实例
  * 然后重写 View.computeScroll 方法, 该方法会在重绘 view 时被调用
  * 在 View.computeScroll 中使用 Scroller.computeScrollOffset 来确认是否完成滑动
  * 若是没有完成, 则调用 View.scrollTo 来滑动 View 内容的位置, 然后再次调用 View.postInvalidate 方法促使 View 重绘以便再次检查滑动是否完成
  * 如此的反复回调直到滑动的完成
  */
 public class CustomView extends View {
    private Scroller mScroller;

    public CustomView(Context context, AttributeSet attrs, int defStyleAttr) {
       super(context, attrs, defStyleAtrr);
       mScroller = new Scroller(context);
     }

    /* 提供一个外部使用的滚动方法, 参数为滚动的目标坐标, 同 view.scrollTo */
    public void smoothScrollTo(int destX, int destY) {
        int deltaX = destX - getScrollX();
        int deltaY = destY - getScrollY();
        /* 该方法并没有产生滑动, 而只是设置了一变量值, 比如初始位置和滑动距离, 滑动时间等 */
        mScroller.startScroll(getScrollX(), getScrollY(), deltaX, deltaY);
        /* 促使 view 进行重绘 */
        invalidate();
     }

    public void smoothScrollBy(int deltaX, int deltaY) {
        smoothScrollTo(mScroller.getCurrX() + deltaX, mScroller.getCurrY() + deltaY);  
     }

    @Override
    public void computeScroll() {
         /* view 在绘制的时候会调用该方法
          * 此时我们调用 scroller.computeScrollOffset 来确认是否已经滑动到目标位置
          * 若是没有的话, 返回 true. 然后我们继续滑动 view 的位置 
          */
        if (mScroller.computeScrollOffset()) {
            /* 真正的滑动调用, mScroller.getCurrX(), getCurrY() 方法获得的是在设计时间 duration 时计算后的位置, 而 getFinalX() 则获得最终位置. */
            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
            /* 因为滑动可能还没有完成, 所以再次调用一次 view 重绘 */
            postInvalidate();
         }
     }
 }&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;&lt;code&gt;view&lt;/code&gt;事件的分发体系&lt;/h5&gt;
&lt;p&gt;同一事件序列是指手指接触屏幕的那一刻起, 到手指离开屏幕的进结束, 这其中产的一系列事件. 这包括&lt;code&gt;ACTION_DOWN&lt;/code&gt;和0个或多个&lt;code&gt;ACTION_MOVE&lt;/code&gt;和&lt;code&gt;ACTION_UP&lt;/code&gt;事件. &lt;/p&gt;
&lt;p&gt;在默认不做特殊处理的情况下一个事件序列只能被一个&lt;code&gt;view&lt;/code&gt;处理&lt;/p&gt;
&lt;p&gt;&lt;code&gt;view&lt;/code&gt;的事件分发首先由&lt;code&gt;Activity&lt;/code&gt;最先捕获, 然后一层一层的分发到具体的子&lt;code&gt;view&lt;/code&gt;, 如果中途没有被截断的话;&lt;/p&gt;
&lt;p&gt;子&lt;code&gt;view&lt;/code&gt;如果没有处理这个事件的话, 最后再沿路返回到&lt;code&gt;Activity&lt;/code&gt;中.&lt;/p&gt;
&lt;p&gt;首先看&lt;code&gt;Activity#dispatchTouchEvent&lt;/code&gt;和&lt;code&gt;PhoneWindow#superDispatchTouchEvent&lt;/code&gt;代码&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// Activity#dispatchTouchEvent

public boolean dispatchTouchEvent(MotionEvent ev) {
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        /*
         * onUserInteraction() 是一个空方法, 可以覆写这个方法来检测用户与手机产生的交互
         * 对应的还有 onUserLeaveHint() 来检测用户手指离开了屏幕
         */
        onUserInteraction(); 
    }
    /*
     * Window 是一个抽象类, 其只有一个惟一的实现 PhoneWindow. 
     * PhoneWindow#superDispatchTouchEvent() 方法惟一作用就是把事件继续向下传递到 DecorView
     *
     */
    if (getWindow().superDispatchTouchEvent(ev)) {
        return true;
    }
    return onTouchEvent(ev);
}

/******************************************************/
// DecorView#superDispatchTouchEvent

public boolean superDispatchTouchEvent(MotionEvent ev) {
    /* mDecor 即 DecorView 类 */
    return mDecor.superDispatchTouchEvent(ev); 
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;DecorView&lt;/code&gt;继承了&lt;code&gt;FrameLayout&lt;/code&gt;并实现了&lt;code&gt;RootViewSurfaceTracker&lt;/code&gt;, &lt;code&gt;WindowCallbacks&lt;/code&gt;. &lt;code&gt;DecorView&lt;/code&gt;即是屏幕的总父&lt;code&gt;view&lt;/code&gt;, 包括了标题栏和内容部分, 即是&lt;code&gt;setContentView&lt;/code&gt;的父&lt;code&gt;view&lt;/code&gt;. 其在接收到&lt;code&gt;view&lt;/code&gt;事件后, 会继续向下派发, 由于&lt;code&gt;FrameLayout&lt;/code&gt;并没覆写这个方法, 所以最终传到父&lt;code&gt;ViewGroup&lt;/code&gt;来处理.   (&lt;del&gt;这火传的2333333&lt;/del&gt;)&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;public boolean superDispatchTouchEvent(MotionEvent ev) {
    return super.dispatchTouchEvent(ev);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ViewGroup#dispatchTouchEvent&lt;/code&gt;. &lt;code&gt;ViewGroup&lt;/code&gt;会判断是否要向下一层&lt;code&gt;view&lt;/code&gt;传递事件, 这样一层一层如此循环, 最终完成整个事件的分发.&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// ViewGroup#dispatchTouchEvent

public boolean dispatchTouchEvent(MotionEvent ev) {
    /* ..... */
    /* 省略前面是一些事件的判断 */
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action &amp;amp; MotionEvent.ACTION_MASK;

        // Handle an initial down.
        // ACTION_DOWN 事件时, 重置所有的标志位
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture. 
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }

        final boolean intercepted;
        /* 这里检查 ViewGroup 是否要中断事件向下分发和调用 onIterceptTouchEvent
         * 当手指刚接触屏幕时为 ACTION_DOWN, 所以条件必然成立, 也就是说在不设置标志位下, 
         * ViewGroup 一定可以中断事件继续分发. 第二条件是 mFirstTouchTarget 的值.
         * 该变量指的是消费事件的 view, ACTION_DOWN时必为null, 如果派发成功, 
         * 在接下来的 ACTION_MOVE, ACTION_UP 则不会为 null 值
         *
         * 接下来则要判断拦截标志位. FLAG_DISALLOW_INTERCEPT 是由 
         * ViewGroup#requestDisallowInterceptTouchEvent 方法进行设置的,
         * 这样一来 ViweGroup 就不再拦截到该事件
         * 但 ACTION_DOWN 为例外, 因为 ViewGroup 会对该类事件做标志重置, 所以不管子 View 如何请求
         * ViewGroup 依然可以拦截到 ACTION_DOWN
         * 
         */
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags &amp;amp; FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                ev.setActoin(action);
            } else {
                intercepted = false;
            }
        } else {
            intercepted = true;
        }
    /* ......... */
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由以上可以看出, &lt;code&gt;ViewGroup#onInterceptTouchEvent&lt;/code&gt;并不是每次都会被调用到&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果事件是&lt;code&gt;ACTION_DOWN&lt;/code&gt;, 则一定会被调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不是&lt;code&gt;ACTION_DOWN&lt;/code&gt;, 则要考虑:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是否有了接收事件的目标子&lt;code&gt;view&lt;/code&gt;. 没有的话,直接设置中断事件派发, 并且不会调用&lt;code&gt;onInterceptTouchEvent&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有了接收事件&lt;code&gt;view&lt;/code&gt;, 则查看子&lt;code&gt;view&lt;/code&gt;是否请求设置不要中断事件标志&lt;code&gt;ViewGroup#requestDisallowInterceptTouchEvent&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;设置后则不调用; 没有设置则会调用&lt;code&gt;onInterceptTouchEvent&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;ViewGroup&lt;/code&gt;只在&lt;strong&gt;当为鼠标的左键(主按键)的按下事件并且屏幕能滚动时&lt;/strong&gt;才会中断事件的派发, 否则默认不中断分发事件 &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// ViewGroup#onInterceptTouchEvent

public boolean onInterceptTouchEvent(ev) {
    if (ev.isFromSource(InputDevice.SOURCE_MOUSE) &amp;amp;&amp;amp;
        ev.getAction() == MotionEvent.ACTION_DOWN &amp;amp;&amp;amp;
        ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY) &amp;amp;&amp;amp;
        isOnScrollbarThumb(ev.getX(), ev.getY())) {
        return true;
    }
    return false;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ViewGroup#dispatchTouchEvent&lt;/code&gt;中如果没有中断派发时, 查找接收的子&lt;code&gt;view&lt;/code&gt;, 如果查找到了, 就调用其&lt;code&gt;dispatchTouchEvent&lt;/code&gt;, 没有找到则调用&lt;code&gt;super.dispatchTouchEvent&lt;/code&gt;, 其实就是&lt;code&gt;View#dispatchTouchEvent&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;来看&lt;code&gt;View#dispatchTouchEvent&lt;/code&gt;的代码. 由于&lt;code&gt;View&lt;/code&gt;作为&lt;code&gt;ViewGroup&lt;/code&gt;的父类, 所以该方法作用在于两方面.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一是作为子&lt;code&gt;view&lt;/code&gt;即像&lt;code&gt;TextView&lt;/code&gt;之类时处理从&lt;code&gt;ViewGroup&lt;/code&gt;派发下来的事件&lt;/li&gt;
&lt;li&gt;二是作为&lt;code&gt;ViewGroup&lt;/code&gt;的父类, 处理&lt;code&gt;ViewGroup#dispatchTouchEvent&lt;/code&gt;(实际是在&lt;code&gt;ViewGroup#dispatchTransformedTouchEvent&lt;/code&gt;)调用父类的&lt;code&gt;dispatchTouchEvent&lt;/code&gt;时&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// View#dispatchTouchEvent
public boolean dispatchTouchEvent(MotionEvent event) {
    if (event.isTargetAccessibilityFocus()) {
        // We don't have focus or no virtual descendant has it, do not handle the event.
        if (!isAccessibilityFocusedViewOrHost()) {
            return false;
        }
        // We have focus and got the event, then use normal event dispatch.
        event.setTargetAccessibilityFocus(false);
    }

    boolean result = false;

    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }

    final int actionMasked = event.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        // Defensive cleanup for new gesture
        stopNestedScroll();
    }

    if (onFilterTouchEventForSeCurity(event)) {
        if ((mViewFlags &amp;amp; ENABLED_MASK) == ENABLED &amp;amp;&amp;amp; handleScrollBarDragging(event)) {
            return = true; 
        }
        /* 
         * 这里会检查几个地方
         * 如果 view 在 enable (默认) 状态下
         * 并且设置了 onTouchListener 回调, 则调用 listener 的 onTouch 方法 
         *
         * 如果调用了 onTouch 方法, 该方法的返回值会对 View#onTouchEvent 方法产生影响
         * onTouch 返回 true 时则不会再调用 View#onTouchEvent 
         * 反之才会调用, 这样方便在 View 之外中断默认的处理方法, onTouch 方法优先级更高
         */
        // noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null &amp;amp;&amp;amp; li.mOnTouchListener != null &amp;amp;&amp;amp;
            (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED &amp;amp;&amp;amp;
            li.mOnTouchListener.onTouch(this, event)) {
            result = true; 
        }
        // onTouch(如果调用了) 返回 false 则在这里回调了 View#onTouchEvent 方法
        if (!result &amp;amp;&amp;amp; onTouchEvent(event)) {
            result = true;
        } 
    }

    if (!result &amp;amp;&amp;amp; mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }

    // Clean up after nested scrolls if this is the end of a gesture
    // alse cancel it if we tried an ACTION_DOWN but we didn't want the rest
    // of the gesture
    if (actionMasked == MotionEvent.ACTION_UP ||
        actionMasked == MotionEvent.ACTIOIN_CANCEL ||
        (actionMasked == MotionEvent.ACTION_DOWN &amp;amp;&amp;amp; !result)) {
      stopNestedScroll();
    }
    return result;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来看 &lt;code&gt;View#onTouchEvent&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// View#onTouchEvent

public boolean onTouchEvent(MotionEvent event) {
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();

    // 检查是否可以单击或者长按或者是长按弹出菜单(类似鼠标右健)
    final boolean clickable = ((viewFlags &amp;amp; (CLICKABLE) == CLICKABLE) ||
        (viewFlags &amp;amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||
        (viewFlags &amp;amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);

    // 检查 view 是否是 disable 状态, 但即使 view 是 disable 
    // 但是可 clickable 状态下也会消费掉该事件, 只是没任何反应而已
    if ((viewFlags &amp;amp; ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP &amp;amp;&amp;amp; (mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        mPrivateFlags3 &amp;amp;= ~PFLAG3_FINGER_DOWN;
        // A disabled view that is clickable still consume the touch
        // events, it just doesn't respond to them
        return clickable;
    }
    // 如果使用 setTouchDelegate 代理方法, 则执行该方法, 和 setOnTouchListener 一样
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return ture;
        }
    }

    // TOOLTIP类似 hover 或者右键鼠标的状态
    // 在这要注意一些如 ImageView 默认是不可点击的, 所以直接返回的 false
    // 然后事件会回退到 ViewGroup 由 ViewGroup 来处理
    // 但该 view 还是捕获到 ACTION_DOWN 
    // 这里就要注意一个坑, 因为事件序列只会由某一个 View/ViewGroup 来处理掉,
    // 所以像 ImageView 这样的不可点击时, 事件回退来 ViewGroup
    // 这样一来, ACTION_DOWN 之后的该序列里的事件就不会再传递到 ImageView 来
    if (clickable || (viewFlags &amp;amp; TOOLTIP) == TOOLTIP) {
        switch (action) {
            case MotionEvent.ACTION_UP:
                mPrivateFlags3 &amp;amp;= ~PFLAG3_FINGER_DOWN;
                if ((viewFlags &amp;amp; TOOLTIP) == TOOLTIP) {
                    handleTooltipUp();
                }
                if (!clickable) {
                    removeTapCallback();
                    removeLongPressCallback();
                    mInContextButtonPress = false;
                    mHasPerformedLongPress = false;
                    mIgnoreNextUpEvent = false;
                    break;
                }
                boolean prepressed = (mPrivateFlags &amp;amp; PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don't have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() &amp;amp;&amp;amp; isFocusableInTouchMode() &amp;amp;&amp;amp; !isFocused()) {
                        focusTaken = requestFocus();
                    }

                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                    }

                    if (!mHasPerformedLongPress &amp;amp;&amp;amp; !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();

                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // Use a Runnable and post this rather than calling
                            // performClick directly. This lets other visual state
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }

                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }

                    if (prepressed) {
                        postDelayed(mUnsetPressedState,
                                ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }

                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_DOWN:
                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {
                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                }
                mHasPerformedLongPress = false;

                if (!clickable) {
                    checkForLongClick(0, x, y);
                    break;
                }

                if (performButtonActionOnTouchDown(event)) {
                    break;
                }

                // Walk up the hierarchy to determine if we're inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();

                // For views inside a scrolling container, delay the pressed feedback for
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(0, x, y);
                }
                break;

            case MotionEvent.ACTION_CANCEL:
                if (clickable) {
                    setPressed(false);
                }
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                mPrivateFlags3 &amp;amp;= ~PFLAG3_FINGER_DOWN;
                break;

            case MotionEvent.ACTION_MOVE:
                if (clickable) {
                    drawableHotspotChanged(x, y);
                }

                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    // Remove any future long press/tap checks
                    removeTapCallback();
                    removeLongPressCallback();
                    if ((mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0) {
                        setPressed(false);
                    }
                    mPrivateFlags3 &amp;amp;= ~PFLAG3_FINGER_DOWN;
                }
                break;
            }
        return true;
    }
    return false;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事件分发的一些总结:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ACTION_DOWN&lt;/code&gt; 是一个&lt;strong&gt;特殊&lt;/strong&gt;的事件. 如果&lt;code&gt;View&lt;/code&gt;只消耗了&lt;code&gt;ACTION_DOWN&lt;/code&gt;事件(&lt;strong&gt;返回 true&lt;/strong&gt;), 那么序列里接下来的事件全都交给该 &lt;code&gt;View&lt;/code&gt; 来消耗.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果&lt;code&gt;View&lt;/code&gt;没有消耗掉接下来比如&lt;code&gt;ACTION_MOVE&lt;/code&gt;, &lt;code&gt;ACTION_UP&lt;/code&gt;之类的事件(&lt;strong&gt;返回&lt;code&gt;false&lt;/code&gt;&lt;/strong&gt;), 那这些事件也不会回退给上一层父&lt;code&gt;ViewGroup&lt;/code&gt;, 这些事件便会消失&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果某个&lt;code&gt;View&lt;/code&gt;没有消耗掉&lt;code&gt;ACTION_DOWN&lt;/code&gt;事件(返回了&lt;code&gt;false&lt;/code&gt;), 那么同一个序列中的其他事件就不会再交给这个&lt;code&gt;View&lt;/code&gt;了. 所有的事件包括第一个&lt;code&gt;ACTION_DOWN&lt;/code&gt;都会被一层一层回退, 如果一直没有&lt;code&gt;View/ViewGroup&lt;/code&gt;消耗掉, 最终会回退到&lt;code&gt;Activity&lt;/code&gt;. 但在这一层层中, 我们可以检测到第一次的&lt;code&gt;ACTION_DOWN&lt;/code&gt;调用, 然后决定是否要消耗事件序列. 原因同 &lt;strong&gt;1&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;一种特殊情况的举例: 
正常情况下, 一个事件序列只能被一个 &lt;code&gt;View&lt;/code&gt; 拦截消耗, 但如果最后接收事件的 &lt;code&gt;View&lt;/code&gt; 是不可&lt;code&gt;clickable&lt;/code&gt;(包括单击, 长按), 那这个 &lt;code&gt;View&lt;/code&gt; 只能在 &lt;code&gt;onTouch&lt;/code&gt; (如果调用&lt;code&gt;View#setOnTouchListener&lt;/code&gt;设置了的话)捕获到, 然后会把这个序列事件(包括 &lt;code&gt;ACTION_DOWN&lt;/code&gt;)回退给父 &lt;code&gt;ViewGroup&lt;/code&gt;, 这个也证实第 1 点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;View&lt;/code&gt; 没有 &lt;code&gt;onInterceptTouchEvent&lt;/code&gt; 方法的, 一但有事件传给它, 在没有设置&lt;code&gt;setTouchEventListener&lt;/code&gt; 或者该方法里的 &lt;code&gt;onTouch&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 时, 会调用 &lt;code&gt;onTouchEvent&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;view&lt;/code&gt;如果不是&lt;code&gt;clickable&lt;/code&gt;的, 默认情况下是不能消耗事件的, 非&lt;code&gt;clickable&lt;/code&gt;的&lt;code&gt;view&lt;/code&gt;可以设置&lt;code&gt;setTouchEventListener&lt;/code&gt;来返回&lt;code&gt;true&lt;/code&gt;截断被消耗事件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;View&lt;/code&gt; 的 &lt;code&gt;enable&lt;/code&gt; 属性并不影响 &lt;code&gt;onTouchEvent&lt;/code&gt; 的默认返回值(&lt;code&gt;true&lt;/code&gt;), 只有&lt;code&gt;clickable&lt;/code&gt;才是&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onClick&lt;/code&gt; 调用发生的前提是 &lt;code&gt;view&lt;/code&gt; 是 &lt;code&gt;clickable&lt;/code&gt;, 并且在它的&lt;code&gt;View#onTouchEvent&lt;/code&gt; 消耗了 &lt;code&gt;ACTION_DOWN&lt;/code&gt; 和 &lt;code&gt;ACTION_UP&lt;/code&gt; 事件, 如果这其中一个被 &lt;code&gt;setTouchEventListener&lt;/code&gt; 拦截消耗了, &lt;code&gt;click&lt;/code&gt; 事件不会被调用 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;ViewGroup#requestDisallowInterceptTouchEvent&lt;/code&gt;可以请求不拦截&lt;code&gt;ACTION_DOWN&lt;/code&gt;以外的事件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Reference&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/yanbober/article/details/50419117"&gt;http://blog.csdn.net/yanbober/article/details/50419117&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://juejin.im/entry/571a591a2e958a006be9f473"&gt;https://juejin.im/entry/571a591a2e958a006be9f473&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/carson_ho/article/details/54136311"&gt;http://blog.csdn.net/carson_ho/article/details/54136311&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&amp;lt;&lt;Android开发艺术探索&gt;&amp;gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="view事件"></category><category term="view坐标"></category><category term="view滑动"></category><category term="view触摸"></category></entry><entry><title>View绘制流程</title><link href="https://ivicel.info/2018/02/viewhui-zhi-liu-cheng.html" rel="alternate"></link><published>2018-02-22T00:00:00+08:00</published><updated>2018-02-22T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2018-02-22:/2018/02/viewhui-zhi-liu-cheng.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一.  &lt;code&gt;view&lt;/code&gt;的&lt;code&gt;MeasureSpec&lt;/code&gt;测量取值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于&lt;code&gt;DecorView&lt;/code&gt;其大小要求要&lt;code&gt;ViewRootImpl&lt;/code&gt;中测量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果要求&lt;code&gt;MACTH_PARENT&lt;/code&gt;,就设置为窗口的大小&lt;code&gt;windowSize&lt;/code&gt;, 模式为精确&lt;code&gt;EXACTLY&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;如果要求为内容大小&lt;code&gt;WRAP_CONTENT&lt;/code&gt;, 就设置为窗口大小&lt;code&gt;windowSize&lt;/code&gt;, 模式为至多&lt;code&gt;AT_MOST&lt;/code&gt;, 表示不能超过子&lt;code&gt;view&lt;/code&gt;这个大小&lt;/li&gt;
&lt;li&gt;默认设置为要求的大小&lt;code&gt;rootDimension&lt;/code&gt;, 模式为精确&lt;code&gt;EXACTLY&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;   // ViewRootImpl#getRootMeasureSpec
   private static int getRootMeasureSpec(int windowSize, int rootDimension) {
           int measureSpec;
           switch (rootDimension) {
           case ViewGroup.LayoutParams.MATCH_PARENT:
               // Window can't resize …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一.  &lt;code&gt;view&lt;/code&gt;的&lt;code&gt;MeasureSpec&lt;/code&gt;测量取值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于&lt;code&gt;DecorView&lt;/code&gt;其大小要求要&lt;code&gt;ViewRootImpl&lt;/code&gt;中测量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果要求&lt;code&gt;MACTH_PARENT&lt;/code&gt;,就设置为窗口的大小&lt;code&gt;windowSize&lt;/code&gt;, 模式为精确&lt;code&gt;EXACTLY&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;如果要求为内容大小&lt;code&gt;WRAP_CONTENT&lt;/code&gt;, 就设置为窗口大小&lt;code&gt;windowSize&lt;/code&gt;, 模式为至多&lt;code&gt;AT_MOST&lt;/code&gt;, 表示不能超过子&lt;code&gt;view&lt;/code&gt;这个大小&lt;/li&gt;
&lt;li&gt;默认设置为要求的大小&lt;code&gt;rootDimension&lt;/code&gt;, 模式为精确&lt;code&gt;EXACTLY&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;   // ViewRootImpl#getRootMeasureSpec
   private static int getRootMeasureSpec(int windowSize, int rootDimension) {
           int measureSpec;
           switch (rootDimension) {
           case ViewGroup.LayoutParams.MATCH_PARENT:
               // Window can't resize. Force root view to be windowSize.
               measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
               break;
           case ViewGroup.LayoutParams.WRAP_CONTENT:
               // Window can resize. Set max size for root view.
               measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
               break;
           default:
               // Window wants to be an exact size. Force root view to be that size.
               measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
               break;
           }
           return measureSpec;
       }&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;普通子&lt;code&gt;view&lt;/code&gt;的大小要受到父&lt;code&gt;ViewGroup&lt;/code&gt;的&lt;code&gt;MeasureSpec.getMode&lt;/code&gt;的值(&lt;code&gt;UNSPECIFIED&lt;/code&gt;, &lt;code&gt;EXACTLY&lt;/code&gt;, &lt;code&gt;AT_MOST&lt;/code&gt;)影响.子&lt;code&gt;view&lt;/code&gt;的大小指子&lt;code&gt;view&lt;/code&gt;的&lt;strong&gt;内容+左右&lt;code&gt;margin&lt;/code&gt;+左右&lt;code&gt;padding&lt;/code&gt;值&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="子view的MeasureSpec" src="../../assets/images/子view的MeasureSpec.png" /&gt;&lt;/p&gt;
&lt;p&gt;子&lt;code&gt;view&lt;/code&gt;的测量要从父&lt;code&gt;ViewGroup&lt;/code&gt;开始, 在&lt;code&gt;ViewGroup#measureChildWithMargins&lt;/code&gt;中, 如果这个&lt;code&gt;view&lt;/code&gt;支持&lt;code&gt;margin&lt;/code&gt;, &lt;code&gt;padding&lt;/code&gt;的话&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// ViewGroup#measureChildWithMargins

protected void measureChildWithMargins(View child,
            int parentWidthMeasureSpec, int widthUsed,
            int parentHeightMeasureSpec, int heightUsed) {
        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();

        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin
                        + widthUsed, lp.width);
        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin
                        + heightUsed, lp.height);

        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
    }

// 在计算 margin, padding 后, 调用 getChildMeasureSpec 来获得子 view 大小和模式 
// 然后进行子 view 测量循环

// ViewGroup#getChildMeasureSpec
// 该方法结果取值为上表

public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
        int specMode = MeasureSpec.getMode(spec);
        int specSize = MeasureSpec.getSize(spec);

        // 去掉 margin 和 padding 之后的大小, 负值表示超出父 ViewGroup, 则取 0
        int size = Math.max(0, specSize - padding);

        int resultSize = 0;
        int resultMode = 0;

        switch (specMode) {
        // Parent has imposed an exact size on us
        case MeasureSpec.EXACTLY:
            if (childDimension &amp;gt;= 0) {
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size. So be it.
                resultSize = size;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        // Parent has imposed a maximum size on us
        case MeasureSpec.AT_MOST:
            if (childDimension &amp;gt;= 0) {
                // Child wants a specific size... so be it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size, but our size is not fixed.
                // Constrain child to not be bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        // Parent asked to see how big we want to be
        case MeasureSpec.UNSPECIFIED:
            if (childDimension &amp;gt;= 0) {
                // Child wants a specific size... let him have it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size... find out how big it should
                // be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size.... find out how
                // big it should be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            }
            break;
        }
        //noinspection ResourceType
        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
    }&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;h4&gt;二. &lt;code&gt;View&lt;/code&gt;的工作流程&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;view&lt;/code&gt;的测量分两种情况, 没有子&lt;code&gt;view&lt;/code&gt;的测量, 另一种是测量&lt;code&gt;ViewGroup&lt;/code&gt;, 此时需要再递归测量&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当测量&lt;code&gt;view&lt;/code&gt;时会调用&lt;code&gt;View#measure&lt;/code&gt;, 该方法是&lt;code&gt;final&lt;/code&gt;不能重写. 如果&lt;code&gt;view&lt;/code&gt;没有测量过或者是需要重新测量的, 该方法会调用&lt;code&gt;View#onMeasure&lt;/code&gt;, 如有需要可以重写&lt;code&gt;View#onMeasure&lt;/code&gt;, &lt;strong&gt;注意, 如果需要&lt;code&gt;view&lt;/code&gt;支持&lt;code&gt;padding&lt;/code&gt;属性则需要在此处理&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// View#onMeasure

protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    // getSuggestMinimumXXX 主要是检测是否设置了背景, 如果设置了取
    // mMinXXX 和 background.mMinXXX 的中的最大值. 没有设置则取 mMinXXX
    // mMinXXX 由 xml 中的 android:minHeight, android:minWidth 来设置

    setMeasuredDimension(
        getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
        getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}

// View#getDefaultSize

public static int getDefaultSize(int size, int measureSpec) {
      int result = size;
      int specMode = MeasureSpec.getMode(measureSpec);
      int specSize = MeasureSpec.getSize(measureSpec);

      switch (specMode) {
        // 该值多用于系统控件的测量
        case MeasureSpec.UNSPECIFIED:
            result = size;
            break;
        // 一般自定义 view 时使用这两个选项
        case MeasureSpec.AT_MOST:
        case MeasureSpec.EXACTLY:
            result = specSize;
            break;
      }
      return result;
  }

// View#getSuggestMinimumWidth

// 如果 view 没有背景, 返回 android:minWidth, 默认为0
// 如果 view 有背景, 返回 背景的最小宽度 和 android:minWidth 中的最大值 
// 高度下同
protected int getSuggestedMinimumWidth() {
    return (mBackground == null) ? mMinWidth : 
            max(mMinWidth, mBackground.getMinimumWidth());
}

// View#getSuggestMinimumHeight

protected int getSuggestedMinimumHeight() {
    return (mBackground == null) ? mMinHeight : 
            max(mMinHeight, mBackground.getMinimumHeight());
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般自定义&lt;code&gt;view&lt;/code&gt;多使用&lt;code&gt;AT_MOST&lt;/code&gt;, &lt;code&gt;EXACTLY&lt;/code&gt;来指定大小&lt;/p&gt;
&lt;p&gt;这样其&lt;code&gt;specWidth&lt;/code&gt;, &lt;code&gt;specHeight&lt;/code&gt;就决定其宽/高度的大小. 所以当我们直接继承&lt;code&gt;View&lt;/code&gt;来自定义&lt;code&gt;view&lt;/code&gt;时, 如果设置&lt;code&gt;view&lt;/code&gt;的宽/高为&lt;code&gt;wrap_content&lt;/code&gt;时, 结合上表中的值, 可以知道如果我们不测量该&lt;code&gt;view&lt;/code&gt;内容的大小, 其最终的大小为父&lt;code&gt;ViewGroup&lt;/code&gt;的大小, 和设置&lt;code&gt;match_parent&lt;/code&gt;一样. 可以使用以下的方法解决&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// 重写该 view 的 onMeasure, 测量内容大小
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);

    int widthMeasureMode = MeasureSpec.getMode(widthMeasureSpec);
    int widthMeasureSize = MeasureSpec.getSize(widthMeasureSpec);

    int heightMeasureMode = MeasureSpec.getMode(heightMeasureSpec);
    int heightMeasureSize = MeasureSpec.getSize(heightMeasureSpec);

    // mWidth, mHeight 是自己设定的一个默认的宽/高度
    ViewGroup.LayoutParams lp = getLayoutParams();
    int width = (widthSpecMode == MeasureSpec.AT_MOST &amp;amp;&amp;amp; 
        lp.width == ViewGroup.LayoutParams.WRAP_CONTENT) ? mWidth : widthMeasureSize;
    int height = (heightSpecMode == MeasureSpec.AT_MOST &amp;amp;&amp;amp;
        lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) ? mHeight : heightMeasureSize;
    setMeasuredDimension(width, height)
}&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ViewGroup&lt;/code&gt;的&lt;code&gt;measure&lt;/code&gt;过程. 对于&lt;code&gt;ViewGroup&lt;/code&gt;来说, 除了要测量自己的大小外, 还有递归的测量各个子元素的大小. 由于不同的布局其测量方法定义不同, 所以&lt;code&gt;ViewGroup&lt;/code&gt;没有默认的&lt;code&gt;onMeasure&lt;/code&gt;方法, 而是需要具体的继承类来实现该方法. &lt;code&gt;onMeasure&lt;/code&gt;中调用&lt;code&gt;measureChildren&lt;/code&gt;或是&lt;code&gt;measureChildWithMargins&lt;/code&gt;来测量子类&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是如果不需要子&lt;code&gt;view&lt;/code&gt;支持&lt;code&gt;margin&lt;/code&gt;时, 使用&lt;code&gt;ViewGroup#measureChildren&lt;/code&gt;来测量, 否则应当使用&lt;code&gt;ViewGroup#measureChildWithMargins&lt;/code&gt;, 自定义的&lt;code&gt;ViewGroup&lt;/code&gt;在重写&lt;code&gt;onMeasure&lt;/code&gt;时需要特别注意&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// ViewGroup#measureChildren

// measureChild 主要递归的调用 view#measure 来测量子 view
// 的大小, 如果 view 不为 View.GONE 的话
protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
    final int size = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i &amp;lt; size; ++i) {
        final View child = children[i];
        if ((child.mViewFlags &amp;amp; VISIBILITY_MASK) != GONE) {
            measureChild(child, widthMeasureSpec, heightMeasureSpec);
        }
    }
}

protected void measureChild(View child, int parentWidthMeasureSpec,
        int parentHeightMeasureSpec) {
    final LayoutParams lp = child.getLayoutParams();

    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
            mPaddingLeft + mPaddingRight, lp.width);
    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
            mPaddingTop + mPaddingBottom, lp.height);

    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;layout&lt;/code&gt;过程. 当&lt;code&gt;ViewGroup&lt;/code&gt;的位置确定后, 其会调用&lt;code&gt;layout&lt;/code&gt;, 并在其中调用 &lt;code&gt;onLayout&lt;/code&gt;来遍历子&lt;code&gt;view&lt;/code&gt;的&lt;code&gt;layout&lt;/code&gt;方法来确定子&lt;code&gt;view&lt;/code&gt;的位置. 子&lt;code&gt;view&lt;/code&gt;的&lt;code&gt;layout&lt;/code&gt;会调用自己的&lt;code&gt;onLayout&lt;/code&gt;方法. &lt;code&gt;ViewGroup&lt;/code&gt;没有默认实现&lt;code&gt;onLayout&lt;/code&gt;, 交给具体的布局来实现, 以方法实现不同的布局&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-java"&gt;// ViewGroup#layout
@Override
public final void layout(int l, int t, int r, int b) {
    if (!mSuppressLayout &amp;amp;&amp;amp; (mTransition == null ||          
         !mTransition.isChangingLayout())) {
        if (mTransition != null) {
            mTransition.layoutChange(this);
        }
        super.layout(l, t, r, b);
    } else {
        // record the fact that we noop'd it; request layout when transition finishes
        mLayoutCalledWhileSuppressed = true;
    }
}

// View#layout
public void layout(int l, int t, int r, int b) {
    if ((mPrivateFlags3 &amp;amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) {
        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);
        mPrivateFlags3 &amp;amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
    }

    int oldL = mLeft;
    int oldT = mTop;
    int oldB = mBottom;
    int oldR = mRight;

    boolean changed = isLayoutModeOptical(mParent) ?
            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);

    if (changed || (mPrivateFlags &amp;amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {
        onLayout(changed, l, t, r, b);

        if (shouldDrawRoundScrollbar()) {
            if(mRoundScrollbarRenderer == null) {
                mRoundScrollbarRenderer = new RoundScrollbarRenderer(this);
            }
        } else {
            mRoundScrollbarRenderer = null;
        }

        mPrivateFlags &amp;amp;= ~PFLAG_LAYOUT_REQUIRED;

        ListenerInfo li = mListenerInfo;
        if (li != null &amp;amp;&amp;amp; li.mOnLayoutChangeListeners != null) {
            ArrayList&amp;lt;OnLayoutChangeListener&amp;gt; listenersCopy =
                    (ArrayList&amp;lt;OnLayoutChangeListener&amp;gt;)li.mOnLayoutChangeListeners.clone();
            int numListeners = listenersCopy.size();
            for (int i = 0; i &amp;lt; numListeners; ++i) {
                listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);
            }
        }
    }

    mPrivateFlags &amp;amp;= ~PFLAG_FORCE_LAYOUT;
    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;

    if ((mPrivateFlags3 &amp;amp; PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT) != 0) {
        mPrivateFlags3 &amp;amp;= ~PFLAG3_NOTIFY_AUTOFILL_ENTER_ON_LAYOUT;
        notifyEnterOrExitForAutoFillIfNeeded(true);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​   绘制过程&lt;code&gt;draw&lt;/code&gt;. 绘制过程主要分为1.绘制背景&lt;code&gt;background.draw(canvas)&lt;/code&gt;, 2.绘制自己&lt;code&gt;onDraw&lt;/code&gt;, 3.绘制&lt;code&gt;children&lt;/code&gt;.&lt;code&gt;dispatchDraw&lt;/code&gt;方法, 4. 绘制装饰&lt;code&gt;onDrawScrollBars&lt;/code&gt;. 主要调用&lt;code&gt;View#draw&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;​   在&lt;code&gt;View&lt;/code&gt;中有一个&lt;code&gt;View#setWillNotDraw&lt;/code&gt;方法, 设置&lt;code&gt;true&lt;/code&gt;表示不绘制该&lt;code&gt;view&lt;/code&gt;. 默认为&lt;code&gt;false&lt;/code&gt;. 当继承&lt;code&gt;ViewGroup&lt;/code&gt;时, 需要手动设置为&lt;code&gt;false&lt;/code&gt;关闭该标志位以便通过&lt;code&gt;onDraw&lt;/code&gt;来绘制&lt;code&gt;view&lt;/code&gt;&lt;/p&gt;</content><category term="android"></category><category term="view绘制"></category></entry><entry><title>Grokking Algorithms-3</title><link href="https://ivicel.info/2017/04/grokking-algorithms-3.html" rel="alternate"></link><published>2017-04-11T00:00:00+08:00</published><updated>2017-04-11T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2017-04-11:/2017/04/grokking-algorithms-3.html</id><summary type="html">&lt;h4&gt;集合覆盖问题(Set Covering)&lt;/h4&gt;
&lt;p&gt;假设某个广播节目在播出时要尽可能覆盖每个地方, 现有一些广播电台, 每个电台能在某几个地方播出, 电台播出范围有重合, 在怎么选择使用最少的电台覆盖到最多的地方&lt;/p&gt;
&lt;p&gt;一种方法是使用贪婪算法, 但有可能不是最佳解, 近似最佳解&lt;/p&gt;
&lt;p&gt;贪婪算法每次的选择都尽可能覆盖到最多的地方, 重复这个直到全部地方被覆盖完&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;state_needed = set(['mt', 'wa', 'or', 'id', 'nv', 'ut', 'ca', 'az'])
# 各个电台广播可以覆盖到的地方
stations = {
    'kone': set(['id', 'nv', 'ut']),
    'ktwo': set(['wa', 'id', 'mt']),
    'kthree': set(['or', 'nv', 'ca']),
    'kfour': set(['nv', 'ut']),
    'kfive': set(['ca', 'az'])
}


def greedy_set_covery …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;h4&gt;集合覆盖问题(Set Covering)&lt;/h4&gt;
&lt;p&gt;假设某个广播节目在播出时要尽可能覆盖每个地方, 现有一些广播电台, 每个电台能在某几个地方播出, 电台播出范围有重合, 在怎么选择使用最少的电台覆盖到最多的地方&lt;/p&gt;
&lt;p&gt;一种方法是使用贪婪算法, 但有可能不是最佳解, 近似最佳解&lt;/p&gt;
&lt;p&gt;贪婪算法每次的选择都尽可能覆盖到最多的地方, 重复这个直到全部地方被覆盖完&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;state_needed = set(['mt', 'wa', 'or', 'id', 'nv', 'ut', 'ca', 'az'])
# 各个电台广播可以覆盖到的地方
stations = {
    'kone': set(['id', 'nv', 'ut']),
    'ktwo': set(['wa', 'id', 'mt']),
    'kthree': set(['or', 'nv', 'ca']),
    'kfour': set(['nv', 'ut']),
    'kfive': set(['ca', 'az'])
}


def greedy_set_covery(covering, covered):
    # 最后选出的集合
    final_covered_set = set()
    needed_covered = covered
    all_covering = covering

    while needed_covered:
        most_covered_numbers = 0
        for item in all_covering:
            intersection = all_covering[item] &amp;amp; needed_covered
            if len(intersection) &amp;gt; most_covered_numbers:
                best_covered = item
                most_covered_numbers = len(intersection)
                print(best_covered)
        # 如果有某个点无法覆盖时, 返回 None
        if most_covered_numbers == 0:
            return None
        final_covered_set.add(best_covered)
        needed_covered -= covering[best_covered]
        covering.pop(best_covered)
    return final_covered_set

covered_set = greedy_set_covery(stations, state_needed)
print(covered_set)
&lt;/code&gt;&lt;/pre&gt;</content><category term="算法"></category><category term="Python"></category><category term="数据结构"></category></entry><entry><title>Grokking Algorithms-1</title><link href="https://ivicel.info/2017/04/grokking-algorithms-1.html" rel="alternate"></link><published>2017-04-07T00:00:00+08:00</published><updated>2017-04-07T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2017-04-07:/2017/04/grokking-algorithms-1.html</id><summary type="html">&lt;h4&gt;binary search 二分法查找&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;# 二分法查找, 返回数值在 list 中的位置, 否则返回 None
def binary_search(num_list, item):
    # 确定查找的数在列表中
    if item &amp;lt; num_list[0] or item &amp;gt; num_list[-1]:
        return None
    # 最小值位置
    low = 0
    # 最大值位置
    high = len(num_list) - 1

    while low &amp;lt;= high:
        # 中间位置, 向下取整
        mid = (low + hight) // 2
        if num_list[mid] &amp;lt; item:
            low = mid + 1
        elif num_list …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;h4&gt;binary search 二分法查找&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;# 二分法查找, 返回数值在 list 中的位置, 否则返回 None
def binary_search(num_list, item):
    # 确定查找的数在列表中
    if item &amp;lt; num_list[0] or item &amp;gt; num_list[-1]:
        return None
    # 最小值位置
    low = 0
    # 最大值位置
    high = len(num_list) - 1

    while low &amp;lt;= high:
        # 中间位置, 向下取整
        mid = (low + hight) // 2
        if num_list[mid] &amp;lt; item:
            low = mid + 1
        elif num_list[mid] &amp;gt; item:
            high = mid - 1
        else:
            return mid
    return None&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;Big O notation 大 O 表示法&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Algorithm speed isn't measured in seconds, but in growth of number of operations  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Instead, we talk about how quickly the run time of an algorithm increases as the size of the input increases  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run time of algorithms is expressed in Big O notation&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;O(log n) is faster than O(n), but it gets a lot faster as the list of items you're searching grows&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4&gt;selection sort 选择排序&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;def selection_sort(arr):
    def findSmallest(arr):
        smallest = arr[0]
        smallest_index = 0
        for i in range(1, len(arr)):
            if arr[i] &amp;lt; smallest:
                smallest = arr[i]
                smallest_index = i
        return smallest_index
    newArr = []
    for i in range(len(arr)):
        smallest = findSmallest(arr)
        newArr.append(arr.pop(smallest))
    return newArr

def bubble_sort(arr):
    index = 0
    length = len(arr)
    for x in range(length):
        for y in range(x + 1, length):
            if arr[x] &amp;gt; arr[y]:
                arr[x], arr[y] = arr[y], arr[x]&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;divide &amp;amp; conquer 分而治之&lt;/h4&gt;
&lt;p&gt;在 1680m X 640m 的土地上如何划出最多均匀方块&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以 640 为基准, 可以划出两个 640 * 640 的方块, 这样剩下的便是 640 * 400 的土地&lt;br /&gt;
再以 400 为基准, 可以划出一个 400 * 400 的方块, 这样剩下的便是一个 400 * 240 的土地&lt;br /&gt;
这样不断为一条较小边为基准画方块, 最后便可以得到最后一个 80 * 80 大小的方块, 这个长度便是最佳长度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将问题范围不断缩小后, 求出最简单问题的解, 然后用这个解去求原始问题的解, 递归使用这种思想&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;# n!
def fb(n):
    if n == 1:
        return 1
    return n * fb(n - 1)&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;快速排序法&lt;/h4&gt;
&lt;p&gt;快速排序法使用的便是一种分而治之的方&lt;/p&gt;
&lt;p&gt;每次从数组中选出一个数(base), 把小于该数的放在左边数组, 大于的放在右边数组&lt;/p&gt;
&lt;p&gt;分好之后, 再对左, 右两边的数组重复上一步&lt;/p&gt;
&lt;p&gt;最后直到只有一个数时, 将这些数组依次组合起来&lt;/p&gt;
&lt;p&gt;快速排序法的排序速度在于基数的选择&lt;/p&gt;
&lt;p&gt;如若每次都选择到数组的中间大小值时, 需要递归层数是&lt;code&gt;O(log n)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;随机选择需要递归层数是&lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;每层都需要比较&lt;code&gt;n&lt;/code&gt;次&lt;/p&gt;
&lt;p&gt;最坏情况是&lt;code&gt;O(log n&amp;lt;sup&amp;gt;2&amp;lt;/sup&amp;gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;平均情况是&lt;code&gt;O(nlog n)&lt;/code&gt;, 也是最好情况&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;def quicksort(arr):
    if len(arr) &amp;lt; 2:
        return arr
    base = arr[0]
    smaller = [x for x in arr[1:] if x &amp;lt; base]
    greater = [x for x in arr[1:] if x &amp;gt; base]
    return quicksort(smaller) + [base] + quicksort(greater)&lt;/code&gt;&lt;/pre&gt;</content><category term="算法"></category><category term="Python"></category><category term="二分法查找"></category><category term="数据结构"></category></entry><entry><title>Grokking Algorithms-2</title><link href="https://ivicel.info/2017/04/grokking-algorithms-2.html" rel="alternate"></link><published>2017-04-07T00:00:00+08:00</published><updated>2017-04-07T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2017-04-07:/2017/04/grokking-algorithms-2.html</id><summary type="html">&lt;h4&gt;图&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;# 使用散列表来表示图
class GraphItem:


class Graph:
    item = {}

    # 向图中加入顶点

    # 删除顶点
    def dl

&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;广度优先算法&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;# 在图 graph 中从 start 到 item 的广度优先算法
def breadth_first_search(start, item):
    import queue
    search_queue = queue.Queue()
    # 将 start 顶点的邻接点加入到队列中
    for element in start['neighbors']:
        if match(element, item):
            return True
        else:
            # 顶点标记为灰, 表示已经入队查找过
            element['mark'] = 'gray'
            search_queue.put …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;h4&gt;图&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;# 使用散列表来表示图
class GraphItem:


class Graph:
    item = {}

    # 向图中加入顶点

    # 删除顶点
    def dl

&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;广度优先算法&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;# 在图 graph 中从 start 到 item 的广度优先算法
def breadth_first_search(start, item):
    import queue
    search_queue = queue.Queue()
    # 将 start 顶点的邻接点加入到队列中
    for element in start['neighbors']:
        if match(element, item):
            return True
        else:
            # 顶点标记为灰, 表示已经入队查找过
            element['mark'] = 'gray'
            search_queue.put(element)
    # 查找队列
    while not search_queue.empty():
        # 获得队列中顶点
        element = search_queue.get()
        element['mark'] = 'black'
        for node in element['neighbors']:
            # 白色表示还没搜索过的顶点
            if node['mark'] == 'white':
                if match(node, item):
                    return True
                else:
                    # 顶点标记为灰, 表示已经入队查找过
                    node['mark'] = 'gray'
                    search_queue.put(node)&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;加权图和狄克斯特拉算法(Dijkstra's algorithm)&lt;/h4&gt;
&lt;p&gt;边带权重(weight)的图称为加权图&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;Dijkstra's algorithm&lt;/code&gt;算法计算加权图中顶点到顶点之间边之各权重为最大或最小&lt;/p&gt;
&lt;p&gt;狄克斯特拉算法只能计算&lt;strong&gt;有向&lt;/strong&gt;, &lt;strong&gt;无循环&lt;/strong&gt;, &lt;strong&gt;权重为正&lt;/strong&gt;的加权图&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;找出最便宜的节点，即可在最短时间内前往的节点 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重复这个过程，直到对图中的每个节点都这样做了(先行标注终点, 不对终点的邻接点再做处理)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算最终路径。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;graph = {
    'compare': lambda x, y:  x &amp;lt; y,
    's': {'a': 24, 'b': 10},
    'a': {'d': 4},
    'b': {'c': 5, 'e': 8},
    'c': {'d': 5, 'a': 1},
    'd': {'f': 4},
    'e': {'d': 12},
    'f': {}
}




def dikjistra_algorithm(graph, start, end):
    if start not in graph or end not in graph:
        return None
    # 已处理过的顶点, 不再搜索其邻接点
    processed = [end]
    # 到某个顶点的最小权重需经过的上一顶点
    parents = {k: start for k in graph[start]}
    # 到某个顶点需要的最小权重
    costs = {key: value for key, value in graph[start].items()}
    # 每次从 costs 里找到最小权重的顶点来搜索其邻接点
    def find_lowest_cost_node(costs):
        lowest_cost = None
        lowest_cost_node = None
        for node in costs:
            if node not in processed:
                lowest_cost = lowest_cost if lowest_cost else costs[node]
                lowest_cost_node = lowest_cost_node if lowest_cost_node else node
                cost = costs[node]
                if graph.get('compare')(cost, lowest_cost):
                    lowest_cost = cost
                    lowest_cost_node = node
        return lowest_cost_node

    node = find_lowest_cost_node(costs)
    while node is not None:
        cost = costs[node]
        neighbors = graph[node]
        for n in neighbors.keys():
            new_cost = cost + neighbors[n]
            if n in costs and graph.get('compare')(costs[n], new_cost):
                continue
            costs[n] = new_cost
            parents[n] = node
        processed.append(node)
        node = find_lowest_cost_node(costs)
    route = []
    cost = costs[end]
    while end != start:
        route.append(end)
        end = parents[end]
    route.append(start)
    return {'route': route[-1::-1], 'cost': cost}

result = dikjistra_algorithm(graph, 's', 'f')
print('parents: ', end='')
print(result['route'])
print('costs: ', end='')
print(result['cost'])
&lt;/code&gt;&lt;/pre&gt;</content><category term="算法"></category><category term="Python"></category><category term="数据结构"></category></entry><entry><title>Matserting Algorithms with C-7: 排序和搜索</title><link href="https://ivicel.info/2017/04/matserting-algorithms-with-c-7-pai-xu-he-sou-suo.html" rel="alternate"></link><published>2017-04-02T00:00:00+08:00</published><updated>2017-04-02T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2017-04-02:/2017/04/matserting-algorithms-with-c-7-pai-xu-he-sou-suo.html</id><summary type="html">&lt;h4&gt;插入排序(选择排序, 冒泡排序Insertion Sort)&lt;/h4&gt;
&lt;p&gt;插入排序每次从数组里选出一个元素, 和新数组里的元素一一进行对比, 然后将新元素排到比它最大/小的元素的左或右边, 时间复杂度为 O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* issort.c */
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

/* data 指向数组, size 是数组中元素个数, esize 是每个元素的大小, compare 是元素之间的比较函数 */
iint issort(void *data, int size, int esize, int (*compare)(const void *key1,
    const void *key2))
{
    /* char指针是 1 字节大小的指向, a[i * esize …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;h4&gt;插入排序(选择排序, 冒泡排序Insertion Sort)&lt;/h4&gt;
&lt;p&gt;插入排序每次从数组里选出一个元素, 和新数组里的元素一一进行对比, 然后将新元素排到比它最大/小的元素的左或右边, 时间复杂度为 O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* issort.c */
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

/* data 指向数组, size 是数组中元素个数, esize 是每个元素的大小, compare 是元素之间的比较函数 */
iint issort(void *data, int size, int esize, int (*compare)(const void *key1,
    const void *key2))
{
    /* char指针是 1 字节大小的指向, a[i * esize]则引用到了第 i 个大小为 esize 的地址 */
    char *a = data;
    void *key;
    int i, j;

    /* allocate storage for the key element */
    if ((key = (char *)malloc(esize)) == NULL) {
        return -1;
    }

    for (j = 1; j &amp;lt; size; j++) {
        memcpy(key, &amp;amp;a[j * esize], esize);

        i = j - 1;
        while (i &amp;gt;=0 &amp;amp;&amp;amp; compare(&amp;amp;a[i *esize], key) &amp;gt; 0) {
            memcpy(&amp;amp;a[(i + 1) * esize], &amp;amp;a[i * esize], esize);
            i--;
        }
        /*
        等同上面的 while
        for (i = j - 1; i &amp;gt;= 0; i--) {
            if (compare(&amp;amp;a[i *esize], key) &amp;gt; 0) {
                memcpy(&amp;amp;a[(i + 1) * esize], &amp;amp;a[i * esize], esize);
            } else {
                break;
            }
        }
        */
        memcpy(&amp;amp;a[(i + 1) * esize], key, esize);
    }
    free(key);
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;快速排序(Quick sort)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;每次选择一个数据, 然后所有的数据和这个数对比, 小的放在左边, 大的放在右边&lt;/li&gt;
&lt;li&gt;然后对左, 右两边的新数组继续重复第一步, 一直到左, 右数组都为空, 依次返回数组&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;快速排序的时间复杂度依赖于每次所选的数, 最坏为&lt;code&gt;O(n&amp;lt;sup&amp;gt;2&amp;gt;&amp;lt;/sup&amp;gt;)&lt;/code&gt;, 平均是&lt;code&gt;O(nlog n)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;为最大可能接近&lt;code&gt;O(nlog n)&lt;/code&gt;, 每次都随机从数组中选择三个数, 取这三个数的中间值&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include "sort.h"

static int compare_int(const void *int1, const void *int2)
{
    if (*(const int *)int1 &amp;gt; *(const int *)int2) {
        return 1;
    } else if (*(const int *)int1 &amp;lt; *(const int *)int2) {
        return -1;
    } else {
        return 0;
    }
}

static int partition(void *data, int esize, int i, int k,
    int (*compare)(const void *key1, const void *key2))
{
    char *a = (char *)data;
    void *pval, *temp;
    int r[3];

    if ((pval = malloc(esize)) == NULL) {
        return -1;
    }
    if ((temp = malloc(esize)) == NULL) {
        free(pval);
        return -1;
    }
    /* 随机选取三个位置, 排序后取中间的值, 尽量保证左右两边的值是均匀的 */
    r[0] = (rand() % (k - i + 1)) + i;
    r[1] = (rand() % (k - i + 1)) + i;
    r[2] = (rand() % (k - i + 1)) + i;
    issort(r, 3, sizeof(int), compare_int);
    memcpy(pval, &amp;amp;a[r[1] * esize], esize);

    i--;
    k++;
    /* 每选中一个数, 在调换位置之后都保证其左边的数不会符合 compare() &amp;lt; 0 */
    while (1) {
        do {
            k--;
        }while (compare(&amp;amp;a[k * esize], pval) &amp;gt; 0);

        do {
            i++;
        }while (compare(&amp;amp;a[i * esize], pval) &amp;lt; 0);

        if (i &amp;gt;= k) {
            break;
        } else {
            memcpy(temp, &amp;amp;a[i * esize], esize);
            memcpy(&amp;amp;a[i * esize], &amp;amp;a[k * esize], esize);
            memcpy(&amp;amp;a[k * esize], temp, esize);
        }
    }
    free(pval);
    free(temp);

    return k;
}

/**
 * data 是数组指向
 * size 是数组大小
 * esize 是每个元素的大小
 * i 是数组的头结点下标, 初始为 0
 * k 是数组末尾结点下标, 初始为 size - 1
 * compare 是比较函数, 大于返回 1, 小于返回 -1, 等于返回 0
 */
int qksort(void *data, int size, int esize, int i, int k,
    int (*compare)(const void *key1, const void *key2))
{
    int j;

    while (i &amp;lt; k) {
        if ((j = partition(data, esize, i, k, compare)) &amp;lt; 0) {
            return -1;
        }
        /* 每次递归都先处理上个 key 的位置的左边的数据 */
        if (qksort(data, size, esize, i, j, compare) &amp;lt; 0) {
            return -1;
        }
        /* 将位置改到位置 */
        i = j + 1;
    }
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;快速排序的例子: 目录列表&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;#include &amp;lt;stdi.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;
#include "sort.h"

typedef struct Directory_ {
    char name[MAXNAMLEN + 1];
}Directory;

static int compare_dir(const void *key1, const void *key2)
{
    int retval;

    if ((retval = strcmp(((const Directory *)key1)-&amp;gt;name,
        ((const Directory *)key2)-&amp;gt;name)) &amp;gt; 0) {
        return 1;
    } else if (retval &amp;lt; 0) {
        return -1;
    } else {
        return 0;
    }
}

int directls(const char *path, Directory **dir)
{
    DIR *dirptr;
    Directory *temp = NULL;
    struct dirent *curdir;
    int count, i;
    /* 打开目录 */
    if ((dirptr = opendir(path)) == NULL) {
        return -1;
    }

    dir = &amp;amp;temp;
    count = 0;

    while ((curdir = readdir(dirptr)) != NULL) {
        count++;
        if ((temp = (Directory *)realloc(*dir, count * sizeof(Directory))) == NULL) {
            free(*dir);
            return -1;
        } else {
            *dir = temp;
        }
        strcpy(((*dir)[count - 1]).name, curdir-&amp;gt;d_name);
    }
    closedir(dirptr);

    if (qksort(*dir, count, sizeof(Directory), 0, count - 1, compare_dir) != 0) {
        return -1;
    }
    return count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;归并排序(Merge Sort)&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include "sort.h"

static int merge(void *data, int esize, int i, int j, int k,
    int (*compare)(const void *key1, const void *key2))
{
    char *a = data,
         *m;
    int ipos, jpos, mpos;

    ipos = i;
    jpos = j + 1;
    mpos = 0;

    if ((m = (char *)malloc(esize * ((k - i) + 1))) == NULL) {
        return -1;
    }

    while (ipos &amp;lt;= j || jpos &amp;lt;= k) {
        if (ipos &amp;gt; j) {
            while (jpos &amp;lt;= k) {
                memcpy(&amp;amp;m[mpos * esize], &amp;amp;a[jpos * esize], esize);
                jpos++;
                mpos++;
            }
            continue;
        } else if (jpos &amp;gt; k) {
            while (ipos &amp;lt;= j) {
                memcpy(&amp;amp;m[mpos * esize], &amp;amp;a[ipos * esize], esize);
                ipos++;
                mpos++;
            }
            continue;
        }

        if (compare(&amp;amp;a[ipos * esize], &amp;amp;a[jpos * esize]) &amp;lt; 0) {
            memcpy(&amp;amp;m[mpos * esize], &amp;amp;a[ipos * esize], esize);
            ipos++;
            mpos++;
        } else {
            memcpy(&amp;amp;m[mpos * esize], &amp;amp;a[jpos * esize], esize);
            jpos++;
            mpos++;
        }
    }

    memcpy(&amp;amp;a[i * esize], m, esize * ((k - i) + 1));
    free(m);
    return 0;
}


/**
 * data 是数组指向
 * size 是数组大小
 * esize 是每个元素的大小
 * i 是数组的头结点下标, 初始为 0
 * k 是数组末尾结点下标, 初始为 size - 1
 * compare 是比较函数, 大于返回 1, 小于返回 -1, 等于返回 0
 */
int mgsort(void *data, int size, int esize, int i, int k,
    int (*compare)(const void *key1, const void *key2))
{
    int j;

    if (i &amp;lt; k) {
        j = (int)(((i + k - 1)) / 2);

        if (mgsort(data, size, esize, i, j, compare) &amp;lt; 0) {
            return -1;
        }
        if (mgsort(data, size, esize, j + 1, k, compare) &amp;lt; 0) {
            return -1;
        }
        if (merge(data, esize, i, j, k, compare) &amp;lt; 0) {
            return -1;
        }
    }

    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* 一种排序数组的方法, 每次会使用新的内存来保存左右值, 写回原数组后再释放 */
int merge_sort(void *data, int size, int esize,
    int (*compare)(const void *key1, const void *key2))
{
    char *d = (char *)data;
    char *key, *left, *right;
    int i,
        pos_left = 0,
        pos_right = 0,
        length = (size - 1) * esize;
    int r[3];


    if ((left = (char *)malloc(length)) == NULL ||
        (right = (char *)malloc(length)) == NULL ||
        (key = (char *)malloc(esize)) == NULL) {
        return -1;
    }

    /* 随机确定某个数的位置 */
    r[0] = rand() % size;
    r[1] = rand() % size;
    r[2] = rand() % size;
    issort(r, 3, sizeof(int), compare_int);
    memset(left, '\0', length);
    memset(right, '\0', length);
    memcpy(key, &amp;amp;d[r[1] * esize], esize);
    /* 比较大小, 分到左右数组 */
    for (i = 0; i &amp;lt; size; i++) {
        if (i != r[1]) {
            if (compare(&amp;amp;d[i * esize], key) &amp;gt; 0) {
                /* right */
                memcpy(&amp;amp;right[pos_right * esize], &amp;amp;d[i * esize], esize);
                pos_right++;
            } else {
                /* left */
                memcpy(&amp;amp;left[pos_left * esize], &amp;amp;d[i * esize], esize);
                pos_left++;
            }
        }
    }
    /* 分好的数组写回原数组, 然后释放左右数组 */
    for (i = 0; i &amp;lt; pos_left; i++) {
        memcpy(&amp;amp;d[i * esize], &amp;amp;left[i * esize], esize);
    }
    memcpy(&amp;amp;d[(pos_left) * esize], key, esize);
    for (i = 0; i &amp;lt; pos_right; i++) {
        memcpy(&amp;amp;d[(pos_left + i + 1) * esize], &amp;amp;right[i * esize], esize);
    }
    free(left);
    free(right);
    free(key);
    /* 在原数组上继续比较分好的左右两边 */
    if (pos_left &amp;gt; 1 &amp;amp;&amp;amp; merge_sort(d, pos_left, esize, compare) != 0) {
        return -1;
    }
    if (pos_right &amp;gt; 1 &amp;amp;&amp;amp; merge_sort(&amp;amp;d[(pos_left + 1) * esize], pos_right,
        esize, compare) != 0) {
        return -1;
    }
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;计数排序(Counting Sort)&lt;/h4&gt;
&lt;p&gt;计数排序只能用于整型或者那些可以用整型来表示的数据集合, 通过计算一个集合中元素出现的次数来确定集合如何排列&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include "sort.h"


int ctsort(int *data, int size, int k)
{
    int *counts, *temp;
    int i, j;

    if ((counts = (int *)malloc(size * sizeof(int))) == NULL) {
        return -1;
    }

    for (i = 0; i &amp;lt; k; i++) {
        counts[i] = 0;
    }

    for (j = 0; j &amp;lt; size; j++) {
        counts[data[j]] = counts[data[j]] + 1;
    }

    for (i = 1; i &amp;lt; k; i++) {
        counts[i] = counts[i] + counts[i - 1];
    }

    for (j = size - 1; j &amp;gt;= 0; j--) {
        temp[counts[data[j]] - 1] = data[j];
        counts[data[j]] = counts[data[j]] - 1;
    }

    memcpy(data, temp, size * sizeof(int));

    free(counts);
    free(temp);
    return 0;
}


#### 基数排序(Radix Sort)

基数排序是一种高效的纯属排序算法, 其方法是将数据按位分开, 并从数据的最低有效位到最高有效位进行比较, 依次排序, 从而得到有序的数据集合

对于数据{15, 12, 49, 16, 36, 40}来说, 第一次对个位数进行从低到高排序后{40, 12, 15, 16, 36, 49},然后再对十位数个的数进行排序最后得到最终结果{12, 15, 16, 36, 40, 49}

基数排序并不局限于对整型数据进行排序, 只要能把元素分割成整型数, 就可以使用基数排序


​```c
#include &amp;lt;limits.h&amp;gt;
#include &amp;lt;math.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include "sort.h"

int rxsort(int *data, int size, int p, int k)
{
    int *counts, *temp;
    int index, pval, i, j, n;

    if ((counts = (int *)malloc(k * sizeof(int))) == NULL) {
        return -1;
    }

    if ((temp = (int *)malloc(size * sizeof(int))) == NULL) {
        return -1;
    }

    for (n = 0; n &amp;lt; p; n++) {
        for (i = 0; i &amp;lt; k; i++) {
            counts[i] = 0;
        }

        pval = (int)pow((double)k, (double)n);

        for (j = 0; j &amp;lt; size; j++) {
            index = (int)(data[j] / pval) % k;
            counts[index] = counts[index] + 1;
        }

        for (i = 1; i &amp;lt; k; i++) {
            counts[i] = counts[i] + counts[i - 1];
        }

        for (j = size - 1; j &amp;gt;= 0; j--) {
            index = (int)(data[j]/pval) % k;
            temp[counts[index] - 1] = data[j];
            counts[index] = counts[index] - 1;
        }
        memcpy(data, temp, size * sizeof(int));
    }
    free(counts);
    free(temp);
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;二分查找(Binary Search)&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include "search.h"


int bisearch(void *sorted, void *target, int size, int esize,
    int (*compare)(const void *key1, const void *key2))
{
    int left, middle, right;

    left = 0;
    right = size - 1;

    while (left &amp;lt;= right) {
        middle = (left + right) / 2;

        switch (compare(((char *)sorted + (esize * middle)), target)) {
            case -1:
                left = middle + 1;
                break;

            case 1:
                right = middle - 1;
                break;

            case 0:
                return middle;
        }
    }
    return -1;
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;二分查找示例: 拼写检查器&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;


#define SPELL_SIZE 31

static int compare_str(const void *str1, const void *str2)
{
    int retval;

    if ((retval = strcmp((const char *)str1, (const char *)str2)) &amp;gt; 0) {
        return -1;
    } else if (retval &amp;lt; 0) {
        return -1;
    } else {
        return 0;
    }
}

/**
 * dictionary 是一个可接受的有序字符串数组
 * size 是字典中字符串的个数
 * word 是被检查的单词
 */
int spell(char (*dictionary)[SPELL_SIZE], int size, const char *word)
{
    if (bisearch(dictionary, word, size, SPELL_SIZE, compare_str) &amp;gt;= 0){
        return -1;
    } else {
        return 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;</content><category term="算法"></category><category term="C"></category><category term="数据结构"></category><category term="排序"></category><category term="搜索"></category></entry><entry><title>Matserting Algorithms with C-7: 图</title><link href="https://ivicel.info/2017/04/matserting-algorithms-with-c-7-tu.html" rel="alternate"></link><published>2017-04-02T00:00:00+08:00</published><updated>2017-04-02T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2017-04-02:/2017/04/matserting-algorithms-with-c-7-tu.html</id><summary type="html">&lt;h3&gt;图(Graphs)&lt;/h3&gt;
&lt;p&gt;&lt;img alt="图" src="../../assets/images/图.png" /&gt;&lt;/p&gt;
&lt;p&gt;图由&lt;strong&gt;顶点&lt;/strong&gt;(vertices)和&lt;strong&gt;边&lt;/strong&gt;(edges)组成, 图的边分为&lt;strong&gt;有向&lt;/strong&gt;和&lt;strong&gt;无向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图表示为&lt;code&gt;G=(V, E)&lt;/code&gt;, V 代表顶点的集合, E 和 V 是一种二元关系&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有向图: V={1, 2, 3, 4} 和 E = {(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 2), (3, 4)}&lt;/p&gt;
&lt;p&gt;无向图: V={1, 2, 3 …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;h3&gt;图(Graphs)&lt;/h3&gt;
&lt;p&gt;&lt;img alt="图" src="../../assets/images/图.png" /&gt;&lt;/p&gt;
&lt;p&gt;图由&lt;strong&gt;顶点&lt;/strong&gt;(vertices)和&lt;strong&gt;边&lt;/strong&gt;(edges)组成, 图的边分为&lt;strong&gt;有向&lt;/strong&gt;和&lt;strong&gt;无向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图表示为&lt;code&gt;G=(V, E)&lt;/code&gt;, V 代表顶点的集合, E 和 V 是一种二元关系&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有向图: V={1, 2, 3, 4} 和 E = {(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 2), (3, 4)}&lt;/p&gt;
&lt;p&gt;无向图: V={1, 2, 3, 4} 和 E = {(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)}&lt;/p&gt;
&lt;p&gt;有向图中&lt;code&gt;(1, 2)&lt;/code&gt;代表中顶点 &lt;code&gt;1&lt;/code&gt;指向顶点&lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;图中两个重要关系是&lt;strong&gt;邻接&lt;/strong&gt;(adjacency)和&lt;strong&gt;关联&lt;/strong&gt;(incidence)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;无向图中, 顶点相连就是邻接, 而在有向图中, 只有两个顶点都相互指向对方是才是邻接的, 上图 1 和 2 就不邻接&lt;/p&gt;
&lt;p&gt;关联是指顶点和边之间的关系. 有向图&lt;code&gt;(1, 2)&lt;/code&gt;中称&lt;code&gt;1&lt;/code&gt;关联到&lt;code&gt;2&lt;/code&gt;, 无向图都是相互关联的&lt;/p&gt;
&lt;p&gt;顶点的入度(in-degree)是指以顶点为终点的边的数目&lt;/p&gt;
&lt;p&gt;顶点的出度(out-degree)是指以顶点为起点的边的数目&lt;/p&gt;
&lt;p&gt;无向图中入度和出度都指顶点边的数目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;路径&lt;/strong&gt;是依次遍历顶点序列之间的边所形成的轨迹. 如果存在一条&lt;code&gt;u&lt;/code&gt;到&lt;code&gt;u&amp;lt;sup&amp;gt;'&amp;lt;/sup&amp;gt;&lt;/code&gt;的路径, 则称&lt;code&gt;u&lt;/code&gt;到&lt;code&gt;u&amp;lt;sup&amp;gt;'&amp;lt;/sup&amp;gt;&lt;/code&gt;是可达的. 没有重复顶点的路径称为&lt;strong&gt;简单路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果从某顶点出发, 最后能够返回该顶点, 则称该路径为&lt;strong&gt;环&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果图中的每个顶点都能通过某条路径到达其他顶点, 对于无向图则称为&lt;strong&gt;连通&lt;/strong&gt;, 对有向图称为&lt;strong&gt;强连通&lt;/strong&gt;. 如果只有图中部分是连通的, 无向图中称为&lt;strong&gt;连通分支&lt;/strong&gt;, 有向图中称为&lt;strong&gt;强连通分支&lt;/strong&gt;. 如果移除某个结点, 使得图或分支推动连通性, 则称该顶点为&lt;strong&gt;关结点&lt;/strong&gt;. 如果移除某条边使得图失去连通性, 则称该边为&lt;strong&gt;桥&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算机中通常使用&lt;strong&gt;邻接链表&lt;/strong&gt;(adjacency-list representation)来表示图. 邻接表按照链表的方式组织, 链表中的每个结构都包含两个成员: 一个顶点和与该顶点邻接的顶点所组成的一个邻接表&lt;/p&gt;
&lt;p&gt;有向图中, 邻接表的顶点总数同总的边数相等; 无向图中, 邻接表的顶点总数是边的两倍&lt;/p&gt;
&lt;p&gt;&lt;img alt="邻接表" src="../../assets/images/邻接表.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;搜索方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;广度优先算法(breadth-first search)&lt;/h4&gt;
&lt;p&gt;在进一步探索图中的顶点之前先访问当前顶点的所有邻接结点.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;开始前, 首先选择一个起始顶点并将其涂成灰色, 而其他顶点为白色. 然后把起始点单独置于一个队列中.  &lt;/li&gt;
&lt;li&gt;对于队列中的每个顶点(初始状态下只有起始顶点), 依次找出和队列首部顶点相邻接的顶点, 将其涂成灰色然后加入到队列末尾.  &lt;/li&gt;
&lt;li&gt;将队列首部顶点涂黑表示已经访问过, 然后出队; 继续访问下一个首部顶点, 回到第 3 步继续查找相邻接的顶点; 如果相邻接的顶点是白色, 表示还没有发现它, 将其涂成灰色, 并把它入队到末尾.  &lt;/li&gt;
&lt;li&gt;直到队列中没有任何顶点时, 完成搜索&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="图广度优先算法" src="../../assets/images/图广度优先算法.png" /&gt;&lt;/p&gt;
&lt;h4&gt;深度优先算法(depth-first search)&lt;/h4&gt;
&lt;p&gt;在访问某个顶点后, 递归地访问此顶点的所有未访问过的相邻顶点, 尽可能深的持续探索直到无法继续为止&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;选择一个起始点并涂成灰色加入到栈中, 其他顶点涂为白色.  &lt;/li&gt;
&lt;li&gt;查找该顶点所有的邻接顶点, 如果是白色表示尚未发现该顶点, 则把该顶点涂成灰色并加入到栈中.  &lt;/li&gt;
&lt;li&gt;最后加入也即是栈顶的顶点, 以该顶点为起始点重复第 2 步; 这样依次循环递归第 2 和 3 步骤, 直到栈顶邻接的顶点全涂成灰色, 或是没有邻接的顶点&lt;/li&gt;
&lt;li&gt;当栈顶顶点没有邻接时或是邻接全是灰色时, 将栈顶涂成黑色, 表示已经访问过该顶点, 然后将其出栈.  &lt;/li&gt;
&lt;li&gt;对栈顶重复第 2, 3, 4 步骤, 直到所有的顶点都出栈.  &lt;/li&gt;
&lt;li&gt;当栈中所有顶点都出栈后, 如果图中还有白色顶点, 则选择其中的任意一个作为起始点, 从第 2 步骤开始, 直至图中所有的顶点都被涂成黑色&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="图广度优先算法" src="../../assets/images/图广度优先算法.png" /&gt;&lt;/p&gt;
&lt;p&gt;图抽象数据类型头文件&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* graph.h */
#ifndef GRAPH_H
#define GRAPH_H

#include &amp;lt;stdlib.h&amp;gt;
#include "list.h"
#include "set.h"

/* 邻接链表顶点结构 */
typedef struct AdjList_ {
    /* 顶点数据 */
    void *vertex;
    /* 邻接顶点集合 */
    Set adjacent;
}AdjList;

/* 图结构 */
typedef struct Graph_ {
    /* 图中顶点数量 */
    int vcount;
    /* 图中边的数量 */
    int ecount;

    int (*match)(const void *key1, const void *key2);
    void (*destroy)(void *data);
    /* 链表 */
    List adjlists;
}Graph;

typedef enum VertexColor_ {white, gray, black} VertexColor;
/* 初始化 */
void graph_init(Graph *graph, int (*match)(const void *key1, const void *key2),
    void (*destroy)(void *data));
/* 销毁 */
void graph_destroy(Graph *graph);
/* 插入顶点 */
int graph_ins_vertex(Graph *graph, const void *data):
/* 在 data1 和 data2 中建立邻接关系 */
int graph_ins_edge(Graph *graph, const void *data1, const void *data2);
/* 删除顶点 */
int graph_rem_vertex(Graph *graph, void **data);
/* 删除边 */
int graph_rem_edge(Graph *graph, void **data);
/* 取得顶点的邻接表 */
int graph_adjlist(const Graph *graph, const void *data, AdjList **adjlist);
/* 判断 data2 是否是 data1 的邻接点 */
int graph_is_adjacent(const Graph *graph, const void *data1, const void *data2);

#define graph_adjlists(graph) ((graph)-&amp;gt;adjlists)
#define graph_vcount(graph) ((graph)-&amp;gt;vcount)
#define graph_ecount(graph) ((graph)-&amp;gt;ecount)

#endif&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图的实现&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* graph.c */
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include "graph.h"
#include "list.h"
#include "set.h"

/* 初始化 */
void graph_init(Graph *graph, int (*match)(const void *key1, const void *key2),
    void (*destroy)(void *data))
{
    graph-&amp;gt;vcount = 0;
    graph-&amp;gt;ecount = 0;
    graph-&amp;gt;destroy = destroy;
    graph-&amp;gt;match = match;
    /* 初始化图链表 */
    list_init(&amp;amp;graph-&amp;gt;adjlists, NULL);
}

/* 销毁 */
void graph_destroy(Graph *graph)
{
    AdjList *adjlist;

    /* 删除每一个顶点 */
    while (list_size(&amp;amp;graph-&amp;gt;adjlists) &amp;gt; 0) {
        /* 删除链表结点 */
        if (list_rem_next(&amp;amp;graph-&amp;gt;adjlists, NULL, (void **)&amp;amp;adjlist) == 0) {
            /* 释放顶点的邻接顶点 */
            set_destroy(&amp;amp;adjlist-&amp;gt;adjacent);
            if (graph-&amp;gt;destroy != NULL) {
                graph-&amp;gt;destroy(adjlist-&amp;gt;vertex);
            }
            free(adjlist);
        }
    }
    /* 删除链表 */
    list_destroy(&amp;amp;graph-&amp;gt;adjlists);
    memset(graph, 0, sizeof(Graph));
}

int graph_ins_vertex(Graph *graph, const void *data)
{
    ListElmt *element;
    AdjList *adjlist;
    int retval;

    /* 确认没有重复数据存在图中链表里 */
    for (element = list_head(&amp;amp;graph-&amp;gt;adjlists); element != NULL;
        element = list_next(element)) {
        if (graph-&amp;gt;match(data, ((AdjList *)list_data(element))-&amp;gt;vertext)) {
            return -1;
        }
    }
    /* 顶点内存 */
    if ((adjlist = (AdjList *)malloc(sizeof(AdjList))) == NULL) {
        return -1;
    }
    adjlist-&amp;gt;vertex = (void *)data;
    /* 初始化新顶点邻接点 */
    set_init(&amp;amp;adjlist-&amp;gt;adjacent, graph-&amp;gt;match, NULL);
    /* 将新顶点插入到链表尾部 */
    if ((retval = list_ins_next(&amp;amp;graph-&amp;gt;adjlists, list_tail(&amp;amp;graph-&amp;gt;adjlists),
        adjlist)) != 0) {
        return retval;
    }
    /* 增加顶点数量 */
    graph-&amp;gt;vcount++;
    return retval;
}

int graph_ins_edge(Graph *graph, const void *data1, const void *data2)
{
    ListElmt *element;
    int retval;

    /* 查找是否存在顶点数据 data2 */
    for (element = list_head(&amp;amp;graph-&amp;gt;adjlists); element != NULL; 
        element = list_next(element)) {
        if (graph-&amp;gt;match(data2, ((AdjList *)list_data(element))-&amp;gt;vertex)) {
            break;
        }
    }
    /* 顶点不存在 */
    if (element == NULL) {
        return -1;
    }

    /* 查找是否存在顶点数据 data1 */
    for (element = list_head(&amp;amp;graph-&amp;gt;adjlists); element != NULL; 
        element = list_next(element)) {
        if (graph-&amp;gt;match(data1, ((AdjList *)list_data(element))-&amp;gt;vertex)) {
            break;
        }
    }
    /* 顶点不存在 */
    if (element == NULL) {
        return -1;
    }
    /* 插入边关系集合 
     * 邻接点集合里结点数据指向实际的数据, 而不是顶点结构
     */
    if ((retval = set_insert(&amp;amp;((AdjList *)list_data(element)-&amp;gt;adjacent, data2))) != 0) {
        return retval;
    }
    graph-&amp;gt;ecount++;
    return 0;
}
/* 删除顶点 */
int graph_rem_vertex(Graph *graph, void **data)
{
    ListElmt *element, *temp, *prev = NULL;
    AdjList *adjlist;
    int found = 0;

    /*遍历链表中所有顶点, 找到匹配的顶点和邻接点 */
    for (element = list_head(&amp;amp;graph-&amp;gt;adjlists); element != NULL;
        element = list_next(element)) {
        /* 当该顶点是其他顶点的邻接点时, 不允许删除 */
        if (set_is_memember(&amp;amp;((AdjList *)list_data(element))-&amp;gt;adjacent, *data)) {
            return -1;
        }
        /* 找到匹配的顶点位置 */
        if (graph-&amp;gt;match(*data, ((AdjList *)list_data(element))-&amp;gt;vertex)) {
            temp = element;
            found = 1;
        }
        if (!found) {
            prev = element;
        }
    }
    /* 未找到符合顶点 */
    if (!found) {
        return -1;
    }
    /* 不能删除有还有邻接点的顶点 */
    if (set_size(&amp;amp;((AdjList *)list_data(temp))-&amp;gt;adjacent) &amp;gt; 0) {
        return -1;
    }
    /* 删除顶点 */
    if (list_rem_next(&amp;amp;graph-&amp;gt;adjlists, prev, (void **)&amp;amp;adjlist) != 0) {
        return -1;
    }

    *data = adjlist-&amp;gt;vertex;
    free(adjlist);

    graph-&amp;gt;vcount--;
    return 0;
}

int graph_rem_edge(Graph *graph, void *data1, void *data2)
{
    ListElmt *element;
    /* 查找第一个顶点 */
    for (element = list_head(&amp;amp;graph-&amp;gt;adjlists); element != NULL;
        element = list_next(element)) {
        if (graph-&amp;gt;match(data1, ((AdjList *)list_data(element))-&amp;gt;vertex)) {
            break;
        }
    }

    if (element == NULL) {
        return -1;
    }
    /* 将顶点的邻接边删除 */
    if (set_remove(&amp;amp;((AdjList *)list_data(element))-&amp;gt;adjacent, data2) != 0) {
        return -1;
    }

    graph-&amp;gt;ecount--;
    return 0;
}
/* 取得顶点 */
int graph_adjlist(const Graph *graph, const void *data, AdjList **adjlist)
{
    ListElmt *element, *prev = NULL;
    /* locate the adjacency list for the vertex */
    for (element = list_head(&amp;amp;graph-&amp;gt;adjlists); element != NULL;
        element = list_next(element)) {
        if (graph-&amp;gt;match(data, ((AdjList *)list_data(element))-&amp;gt;vertex)) {
            break;
        }
        prev = element;
    }
    /* return if the vertex was not found */
    if (element == NULL) {
        return -1;
    }
    /* pass back the adjacency list for the vertex */
    *adjlist = list_data(element);
    return 0;
}
/* 判断邻接关系 */
int graph_is_adjacent(const Graph *graph, const void *data1, const void *data2)
{   
    ListElmt *element, *prev = NULL

    for (element = list_head(&amp;amp;graph-&amp;gt;adjlists); element != NULL;
        element = list_next(element)) {
        if (graph-&amp;gt;match(data1, ((AdjList *)list_data(element))-&amp;gt;vertex)) {
            break;
        }
        prev = element;
    }

    if (element == NULL) {
        return -1;
    }
    return set_is_memember(&amp;amp;((AdjList *)list_data(element))-&amp;gt;adjacent, data2);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图的应用: 计算网络跳数(Counting Network Hops)&lt;/p&gt;
&lt;p&gt;&lt;img alt="网络跳数" src="../../assets/images/网络跳数.png" /&gt;&lt;/p&gt;
&lt;p&gt;使用广度优先算法, 对于某个顶点的的邻接点, 其邻接点的跳数都等于该顶点跳数加上 1&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* bfs.c */
#include &amp;lt;string.h&amp;gt;
#include "graph.h"
#include "list.h"
#include "queue.h"
#include "set.h"


/* define a struct for vertices in a breadth-first search */
typedef struct BfsVertext_ {
    void *data;
    /* 顶点颜色 */
    VertexColor color;
    int hops;
}BfsVertex;

int bfs(Graph *graph, BfsVertex *start, List *hops)
{
    Queue queue;
    AdjList *adjlist, *clr_adjlist;
    BfsVertex *clr_vertex, *adj_vertex;
    ListElmt *element, *member;

    /* 初始化顶点颜色 */
    for (element = list_head(&amp;amp;graph_adjlists(graph)); element != NULL;
        element = list_next(element)) {
        clr_vertex = ((AdjList *)list_data(element))-&amp;gt;vertex;
        if (graph-&amp;gt;match(clr_vertex, start)) {
            /* 确定起点 */
            clr_vertex-&amp;gt;color = gray;
            clr_vertex-&amp;gt;hops = 0;
        } else {
            clr_vertex-&amp;gt;color = white;
            clr_vertex-&amp;gt;hops = -1;
        }
    }
    /* 取得起始顶点 */
    if (graph_adjlist(graph, start, &amp;amp;clr_adjlist) != 0) {
        return -1;
    }

    /* 将起始点加入队列中 */
    queue_init(&amp;amp;queue, NULL);
    if (queue_enqueue(&amp;amp;queue, clr_adjlist) != 0) {
        queue_destroy(&amp;amp;queue);
        return -1;
    }
    /* 循环队列, 广度优先 */
    while (queue_size(&amp;amp;queue) &amp;gt; 0) {
        adjlist = queue_peek(&amp;amp;queue);
        /* 循环邻接点 */
        for (member = set_head(&amp;amp;adjlist-&amp;gt;adjacent); member != NULL;
            member = member-&amp;gt;next) {
            /* 注意集合结点存储的数据指向并不是一个顶点, 而是顶点指向的实际数据 */
            adj_vertex = set_data(member);
            /* 确认顶点存在于图中 */
            if (graph_adjlist(graph, adj_vertex, &amp;amp;clr_adjlist) != 0) {
                queue_destroy(&amp;amp;queue);
                return -1;
            }
            clr_vertex = clr_adjlist-&amp;gt;vertex;

            if (clr_vertex-&amp;gt;color == white) {
                /* 如果顶点还没有添加到队列中, 将其涂成灰色并加入到队列里 */
                clr_vertex-&amp;gt;color = gray;
                /*  队列首部顶点到达这个顶点所需跳数 + 1, 也即是起始点到该点的跳数 */
                clr_vertex-&amp;gt;hops = ((BfsVertex *)adjlist-&amp;gt;vertex)-&amp;gt;hops + 1;

                if (queue_enqueue(&amp;amp;queue, clr_adjlist) != 0) {
                    queue_destroy(&amp;amp;queue);
                    return -1;
                }
            }
        }
        /* 队首部出队, 涂成黑色 */
        if (queue_dequeue(&amp;amp;queue, (void **)&amp;amp;adjlist) == 0) {
            ((BfsVertex *)adjlist-&amp;gt;vertex)-&amp;gt;color = black;
        } else {
            queue_destroy(&amp;amp;queue);
            return -1;
        }
    }
    /* 完成循环成销毁队列 */
    queue_destroy(&amp;amp;queue);
    /* 初始一个队列 hops */
    list_init(hops, NULL);
    for (element = list_head(&amp;amp;graph_adjlist(graph)); element != NULL;
        element = list_next(element)) {
        clr_vertex = ((AdjList *)list_data(element))-&amp;gt;vertex;
        /* 对于 hops 值为即为到达该顶点所需最少跳数, -1 是不可到达的顶点 */
        if (clr_vertex-&amp;gt;hops != -1) {
            if (list_ins_next(hops, list_tail(hops), clr_vertex) != 0) {
                list_destroy(hops);
                return -1;
            }
        }
    }
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图的应用: 拓扑排序(Topological Sorting)&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* dfs.c */
#include &amp;lt;stdlib.h&amp;gt;
#include "graph"
#include "list.h"
#include "set.h"

typedef struct DfsVertex_ {
    void *data;
    VertexColor color;
}DfsVertex;

static int dfs_main(Graph *graph, AdjList *adjlist, List *ordered)
{
    AdjList *clr_adjlist;
    DfsVertex *clr_vertex, *adj_vertex;
    ListElmt *member;
    /* change the color of vertex to gray */
    ((DfsVertex *)adjlist-&amp;gt;vertex)-&amp;gt;color = gray;
    /* search its adjacency set */
    for (member = set_head(&amp;amp;adjlist-&amp;gt;adjacent); member != NULL;
        member = member-&amp;gt;next) {
        /* determine the color of the next adjacent vertex */
        adj_vertex = set_data(member);
        /* 取得该顶点 */
        if (graph_adjlist(graph, adj_vertex, &amp;amp;clr_adjlist) != 0) {
            return -1;
        }
        clr_vertex = clr_adjlist-&amp;gt;vertex;
        /* move one vertex deeper when the next adjacent vertex is white */
        /* 如果顶点是白色, 表明还没被访问过, 如果有邻接点, 继续向下层访问 */
        if (clr_vertex-&amp;gt;color == white) {
            if (dfs_main(graph, clr_adjlist, ordered) != 0) {
                return -1;
            }
        }
    }
    /* color the current vertex black and make it first in the list */
    ((DfsVertex *)adjlist-&amp;gt;vertex)-&amp;gt;color = black;

    if (list_ins_next(ordered, NULL, (DfsVertex *)adjlist-&amp;gt;vertex) != 0) {
        return -1;
    }
    return 0;
}

int dfs(Graph *graph, List *ordered)
{
    DfsVertex *vertex;
    ListElmt *element;

    /* initial all of the vertices in the graph */
    for (element = list_head(&amp;amp;graph-&amp;gt;adjlists); element != NULL;
        element = list_next(element)) {
        vertex = ((AdjList *)list_data(element))-&amp;gt;vertex;
        vertex-&amp;gt;color = white;
    }

    /* initialize list */
    list_init(ordered, NULL);
    /* perform depth-first search */
    for (element = list_head(&amp;amp;graph-&amp;gt;adjlists); element != NULL;
        element = list_next(element)) {
        /* ensure that every component of unconnected graphs is searched */
        vertex = ((AdjList *)list_data(element))-&amp;gt;vertex;
        if (vertex-&amp;gt;color == white) {
            /* 确保所有顶点遍历到, 发生错误就退出 */
            if (dfs_main(graph, (AdjList *)list_data(element), ordered) != 0) {
                list_destroy(ordered);
                return -1;
            }
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content><category term="算法"></category><category term="C"></category><category term="图"></category><category term="数据结构"></category></entry><entry><title>Matserting Algorithms with C-6: 堆和优先队列</title><link href="https://ivicel.info/2017/04/matserting-algorithms-with-c-6-dui-he-you-xian-dui-lie.html" rel="alternate"></link><published>2017-04-01T00:00:00+08:00</published><updated>2017-04-01T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2017-04-01:/2017/04/matserting-algorithms-with-c-6-dui-he-you-xian-dui-lie.html</id><summary type="html">&lt;h3&gt;堆 (Heap)&lt;/h3&gt;
&lt;p&gt;堆是一棵二叉树, 子结点存储的值比父结点的值大称为最小值堆, 子结点存储的值比父结点小称为最大值堆&lt;/p&gt;
&lt;p&gt;堆是有序的排列, 父子结点存在大小关系, 兄弟结点不存在直接的关系, 堆是快速取得最大/小值的数据结构&lt;/p&gt;
&lt;p&gt;堆的实现通常存储在一个连续的数组中, 从根结点为&lt;code&gt;0&lt;/code&gt;位置, 任意结点&lt;code&gt;i&lt;/code&gt;其父结点的的位置是&lt;code&gt;int((i-2)/2)&lt;/code&gt;, 舍弃掉小数部分&lt;/p&gt;
&lt;p&gt;堆是左平衡的树, 随着结点的增加, 树会逐级从左至右增长.&lt;/p&gt;
&lt;p&gt;向堆中插入节点&lt;/p&gt;
&lt;p&gt;&lt;img alt="向堆中插入结点" src="../../assets/images/向堆中插入结点.png" /&gt;&lt;/p&gt;
&lt;p&gt;删除堆顶点&lt;/p&gt;
&lt;p&gt;&lt;img alt="删除堆顶点" src="../../assets/images/删除堆顶点.png" /&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* heap.h */
#ifndef HEAP_H
#define HEAP_H
/* 堆的数据结构 */
typedef struct Heap_ {
    int size;
    /* 调用者自定义比较函数, 符合返回 &amp;gt; 0, 不符合返回 &amp;lt; 0, 相等返回 = 0 */
    int (*compare)(const void *key1 …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;h3&gt;堆 (Heap)&lt;/h3&gt;
&lt;p&gt;堆是一棵二叉树, 子结点存储的值比父结点的值大称为最小值堆, 子结点存储的值比父结点小称为最大值堆&lt;/p&gt;
&lt;p&gt;堆是有序的排列, 父子结点存在大小关系, 兄弟结点不存在直接的关系, 堆是快速取得最大/小值的数据结构&lt;/p&gt;
&lt;p&gt;堆的实现通常存储在一个连续的数组中, 从根结点为&lt;code&gt;0&lt;/code&gt;位置, 任意结点&lt;code&gt;i&lt;/code&gt;其父结点的的位置是&lt;code&gt;int((i-2)/2)&lt;/code&gt;, 舍弃掉小数部分&lt;/p&gt;
&lt;p&gt;堆是左平衡的树, 随着结点的增加, 树会逐级从左至右增长.&lt;/p&gt;
&lt;p&gt;向堆中插入节点&lt;/p&gt;
&lt;p&gt;&lt;img alt="向堆中插入结点" src="../../assets/images/向堆中插入结点.png" /&gt;&lt;/p&gt;
&lt;p&gt;删除堆顶点&lt;/p&gt;
&lt;p&gt;&lt;img alt="删除堆顶点" src="../../assets/images/删除堆顶点.png" /&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* heap.h */
#ifndef HEAP_H
#define HEAP_H
/* 堆的数据结构 */
typedef struct Heap_ {
    int size;
    /* 调用者自定义比较函数, 符合返回 &amp;gt; 0, 不符合返回 &amp;lt; 0, 相等返回 = 0 */
    int (*compare)(const void *key1, const void *key2);
    void (*destroy)(void *data);

    void **tree;
} Heap;

void heap_init(Heap *heap, int (*compare)(const void *key1, const void *key2),
    void (*destroy)(void *data));

void heap_destroy(Heap *heap);
/* 插入结点, 复杂度是 O(lg n) */
int heap_insert(Heap *heap, const void *data);
/* 释放堆顶部的结点  复杂度是O(lg n) */
int heap_extract(Heap *heap, void **data);
#define heap_size(heap) ((heap)-&amp;gt;size)

#endif&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;堆的实现 &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* heap.c */
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#include "heap.h"
/* 父结点位置 */
#define heap_parent(npos) ((int)(((npos) - 1) / 2))
/* 左子结点位置 */
#define heap_left(npos) (((npos) * 2) + 1)
/* 右子结点位置 */
#define heap_right(npos) (((npos) * 2) + 2)
/* 初始化 */
void heap_init(Heap *heap, int (*compare)(const void *key1, const void *key2),
    void (*destroy)(void *data))
{
    heap-&amp;gt;size = 0;
    heap-&amp;gt;compare = compare;
    heap-&amp;gt;destroy = destroy;
    heap-&amp;gt;tree = NULL;
}

/* 销毁 */
void heap_destroy(Heap *heap)
{
    int i;

    if (heap-&amp;gt;destroy != NULL) {
        for (i = 0; i &amp;lt; heap_size(heap); i++) {
            heap-&amp;gt;destroy(heap-&amp;gt;tree[i]);
        }
    }
    free(heap-&amp;gt;tree);
    memset(heap, 0, sizeof(Heap));
}

/* 插入结点 */
int heap_insert(Heap *heap, const void *data)
{
    void *temp;
    int ipos, ppos;
    /* 重新给树分配一个连续的内存 */
    if ((temp = (void *)realloc(heap-&amp;gt;tree, (heap_size(heap) + 1) * sizeof(void *)))
        == NULL) {
        return -1;
    } else {
        heap-&amp;gt;tree = temp;
    }
    /* 新数据插入到数组尾部 */
    heap-&amp;gt;tree[heap_size(heap)] = (void *data);
    /* 新结点位置 */
    ipos = heap_size(heap);
    /* 新结点的父结点位置 */
    ppos = heap_parent(ipos);

    /* 比较新结点与父结点的大小, 将大于/小于的值交换, 以保持树的结构 
     * compare 为调用者自定义的比较函数
     */
    while (ipos &amp;gt; 0 &amp;amp;&amp;amp; heap-&amp;gt;compare(heap-&amp;gt;tree[ppos], heap-&amp;gt;tree[ipos]) &amp;lt; 0) {
        temp = heap-&amp;gt;tree[ppos];
        heap-&amp;gt;tree[ppos] = heap-&amp;gt;tree[ipos];
        heap-&amp;gt;tree[ipos] = temp;
        ipos = ppos;
        ppos = heap_parent(ipos);
    }
    heap-&amp;gt;size++;
    return 0;
}

/* 删除根结点 */
int heap_extract(Heap *heap, void **)
{
    void *save, *temp;
    int ipos, lpos, rpos, mpos;
    /* 空堆 */
    if (heap_size(heap) == 0) {
        return -1;
    }
    /* 根结点数据 */
    *data = heap-&amp;gt;tree[0];
    /* 最右结点数据 */
    save = heap-&amp;gt;tree[heap_size(heap) - 1];
    /* 原堆内只有一个数据时 */
    if (heap_size(heap) == 1) {
        free(heap-&amp;gt;tree);
        heap-&amp;gt;size = 0;
        heap-&amp;gt;tree = NULL;
        return 0;
    }
    /* 多于一个数据时, 重新申请内存 */
    if ((temp = (void **)realloc(heap-&amp;gt;tree, (heap_size(heap) - 1) * sizeof(void *)))
        == NULL) {
        return -1;
    }
    heap-&amp;gt;tree = temp;
    heap-&amp;gt;size--;
    /* 原堆内尾结点调换成根结点 */
    heap-&amp;gt;tree[0] = save;

    ipos = 0;
    // lpos = heap_left(ipos);
    // rpos = heap_right(ipos);

    while (1) {
        /* 比较根结点与其子结点的大小, 以保持树的结构 */
        lpos = heap_left(ipos);
        rpos = heap_right(ipos);

        if (lpos &amp;lt; heap_size(heap) &amp;amp;&amp;amp; heap-&amp;gt;compare(heap-&amp;gt;tree[lpos],
            heap-&amp;gt;tree[ipos]) &amp;gt; 0) {
            mpos = lpos;
        } else {
            mpos = ipos;
        }

        if (rpos &amp;lt; heap_size(heap) &amp;amp;&amp;amp; heap-&amp;gt;compare(heap-&amp;gt;tree[rpos],
            heap-&amp;gt;tree[mpos]) &amp;gt; 0) {
            mpos = rpos;
        }
        /* 顶点条件为最大/小值时 */ 
        if (mpos == ipos) {
            break;
        } else {
            temp = heap-&amp;gt;tree[mpos];
            heap-&amp;gt;tree[mpos] = heap-&amp;gt;tree[ipos];
            heap-&amp;gt;tree[ipos] = temp;
            ipos = mpos;
        }
    }
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;优先队列(Priority Queues)&lt;/h3&gt;
&lt;p&gt;优先队列将数据按照数据的优先级顺序排列, 这样可以最快定位到优先级最高的元素. 例如在服务器做负载均衡时, 最空闲的服务器优先级最高, 这样可以更好的处理请求服务&lt;/p&gt;
&lt;p&gt;优先队列的实现&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* pqueue.h */
#ifndef PQUEUE_H
#define PQUEUE_H

#include "heap.h"
/* 使用堆来实现优先队列 */
typedef Heap PQueue;
/* 队列中的比较函数 compare , 当 key1 优先级大于 key2 时, 返回 1, 小于返回 -1, 相等返回 0 */
#define pqueue_init heap_init
#define pqueue_insert heap_insert
#define pqueue_extract heap_extract
/* 返回优先级最高的元素 */
#define pqueue_peek(pqueue) ((pqueue)-&amp;gt;tree == NULL ? NULL : ((pqueue)-&amp;gt;tree[0]))
/* 队列大小 */
#define pqueue_size heap_size

#endif &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优先队列的示例: 包裹分拣&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* parels.c */
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include "pqueue.h"

/* 包裹的优先级 */
typedef struct Parcel_ {
    int priority;
}Parcel;
/* 取得优先级最大的包裹, 参数 parcel 指向取得的包裹 */
int get_parcel(PQueue *parcels, Parcel *parcel)
{
    Parcel *data;
    /* 队列中没有包裹或取包裹时出错 */
    if (pqueue_size(parcels) == 0 ||
        pqueue_extract(parcels, (void **)&amp;amp;data) != 0) {
        return -1;
    }

    memcpy(parcel, data, sizeof(Parcel));
    free(data);
    return 0;
}
/* 将包裹加入到队列中 */
int put_parcel(PQueue *parcels, const Parcel *parcel)
{
    Parcel *data;
    /* 新包裹内存 */
    if ((data = (Parcel *)malloc(sizeof(Parcel))) == NULL) {
        return -1;
    }
    memcpy(data, parcel, sizeof(Parcel));
    if (pqueue_insert(parcels, data) != 0) {
        return -1;
    }
    return 0;
}&lt;/code&gt;&lt;/pre&gt;</content><category term="算法"></category><category term="C"></category><category term="集合"></category><category term="数据结构"></category></entry><entry><title>Matserting Algorithms with C-5: 树</title><link href="https://ivicel.info/2017/03/matserting-algorithms-with-c-5-shu.html" rel="alternate"></link><published>2017-03-27T00:00:00+08:00</published><updated>2017-03-27T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2017-03-27:/2017/03/matserting-algorithms-with-c-5-shu.html</id><summary type="html">&lt;h3&gt;二叉树(Binary tree)&lt;/h3&gt;
&lt;p&gt;&lt;img alt="二叉树" src="../../assets/images/二叉树.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先序遍历&lt;/strong&gt;: 根结点-&amp;gt;左子结点-&amp;gt;右子结点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中序遍历&lt;/strong&gt;: 左子结点-&amp;gt;根结点-&amp;gt;右子结点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后序遍历&lt;/strong&gt;: 左子结点-&amp;gt;右子结点-&amp;gt;根结占&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;层级遍历&lt;/strong&gt;: 树根结点-&amp;gt;下层左结点-&amp;gt;该层右结点 (广度优先方法)&lt;/p&gt;
&lt;p&gt;&lt;img alt="树的遍历方法" src="../../assets/images/树的遍历方法.png" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;树的平衡是指在添加结点到下一层是必须保证本层的结点是满额的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二叉的接口定义&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* 这里不没包含插入和删除非叶子结点的操作, 这些操作需要根据具体的应用将树中的其他结点做相应的调整 */
/* bitree.h */
#ifndef BITREE_H
#define BITREE_H
#include &amp;lt;stdlib.h&amp;gt;

/* 节点结构 */
typedef struct BiTreeNode_ {
    void *data;
    /* 左结点 */
    struct BiTreeNode_ *left;
    /* 右结点 */
    struct BiTreeNode_ *right;
}BiTreeNode;

/* 二叉树结构 */
typedef …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;h3&gt;二叉树(Binary tree)&lt;/h3&gt;
&lt;p&gt;&lt;img alt="二叉树" src="../../assets/images/二叉树.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先序遍历&lt;/strong&gt;: 根结点-&amp;gt;左子结点-&amp;gt;右子结点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中序遍历&lt;/strong&gt;: 左子结点-&amp;gt;根结点-&amp;gt;右子结点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后序遍历&lt;/strong&gt;: 左子结点-&amp;gt;右子结点-&amp;gt;根结占&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;层级遍历&lt;/strong&gt;: 树根结点-&amp;gt;下层左结点-&amp;gt;该层右结点 (广度优先方法)&lt;/p&gt;
&lt;p&gt;&lt;img alt="树的遍历方法" src="../../assets/images/树的遍历方法.png" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;树的平衡是指在添加结点到下一层是必须保证本层的结点是满额的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二叉的接口定义&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* 这里不没包含插入和删除非叶子结点的操作, 这些操作需要根据具体的应用将树中的其他结点做相应的调整 */
/* bitree.h */
#ifndef BITREE_H
#define BITREE_H
#include &amp;lt;stdlib.h&amp;gt;

/* 节点结构 */
typedef struct BiTreeNode_ {
    void *data;
    /* 左结点 */
    struct BiTreeNode_ *left;
    /* 右结点 */
    struct BiTreeNode_ *right;
}BiTreeNode;

/* 二叉树结构 */
typedef struct BiTree_ {
    int size;
    /* 为二叉搜索树使用, 比较两结点的大小, key1&amp;gt;key2 返回 1, 小于返回 -1, 相等返回 0 */
    int (*compare)(const void *key1, const void *key2);
    void (*destroy)(void *data);
    BiTreeNode *root;
}BiTree;
/* 初始化 */
void bitree_init(BiTree *tree, void (*destroy)(void *data));
/* 销毁 */
void bitree_destroy(BiTree *tree);
/* 插入左结点 */
void bitree_ins_left(BiTree *tree, BiTreeNode *node, const void *data);
/* 插入右结点 */
void bitree_ins_right(biTree *tree, BiTreeNode *node, const void *data);
/* 删除结点以及其下层全部的子结点, 并未实现只删除任意结点而不删除子结点 */
void bitree_rem_left(BiTree *tree, BiTreeNode *node);
void bitree_rem_right(biTree *tree, BiTreeNode *node);
/* 将两棵树合成新的二叉树, data 为根结点 */
int bitree_merge(BiTree *merge, BiTree *left, BiTree *right, const void *data);

#define bitree_size(tree) ((tree)-&amp;gt;size)
#define bitree_root(tree) ((tree)-&amp;gt;root)
#define bitree_is_eob(node) ((ndoe) == NULL)
#define bitree_is_leaf(node) ((node)-&amp;gt;left == NULL &amp;amp;&amp;amp; (node)-&amp;gt;rigth == NULL)
#define bitree_data(node) ((node)-&amp;gt;data)
#define bitree_left(node) ((node)-&amp;gt;left)
#define bitree_right(node) ((ndoe)-&amp;gt;right)

#endif&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二叉树的实现 &lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include "bitree.h"

void bitree_init(BiTree *tree, void (*destroy)(void *data))
{
    tree-&amp;gt;size = 0;
    tree-&amp;gt;destroy = destroy;
    tree-&amp;gt;root = NULL;
}

void bitree_destroy(BiTree *tree)
{
    bitree_rem_left(tree, NULL);
    memset(tree, 0, sizeof(BiTree));
}

int bitree_ins_left(BiTree *tree, BiTreeNode *node, const void *data)
{
    BiTreeNode *new_node, **position;

    if (node == NULL) {
        if (bitree_size(tree) &amp;gt; 0) {
            return -1;
        }
        /* node 为 NULL 并且树为空时, 作根结点 */
        position = &amp;amp;tree-&amp;gt;root;
    } else {
        if (bitree_left(node) != NULL) {
            /* 已有左结点 */
            return -1;
        }
        position = &amp;amp;node-&amp;gt;left; 
    }
    /* 申请内存 */
    if ((new_node = (BiTreeNode *)malloc(sizeof(BiTreeNode))) == NULL) {
        return -1;
    }
    new_node-&amp;gt;data = (void *)data;
    new_node-&amp;gt;left = NULL;
    new_node-&amp;gt;right = NULL;
    *position = new_node;
    tree-&amp;gt;size++;
    return 0;
}

int bitree_ins_right(BiTree *tree, BiTreeNode *node, const void *data)
{
    BiTreeNode *new_node, **position;
    if (node == NULL) {
        if (bitree_size(tree) &amp;gt; 0) {
            return -1;
        }
        position = &amp;amp;tree-&amp;gt;root;
    } else {
        if (bitree_right(node) != NULL) {
            return -1;
        }
        position = &amp;amp;node-&amp;gt;right;
    }
    if ((new_node = (BiTreeNode *)malloc(sizeof(BiTreeNode))) == NULL) {
        return -1;
    }
    new_ndoe-&amp;gt;data = (void *)data;
    new_node-&amp;gt;left = NULL;
    new_node-&amp;gt;right = NULL;
    *position = new_node;
    tree-&amp;gt;size++;
    return 0;
}

void bitree_rem_left(BiTree *tree, BiTreeNode *node)
{
    BiTreeNode **position;

    if (bitree_size(tree) == 0) {
        return;
    }
    if (node == NULL) {
        /* 传入 NULL 删除根结点 */
        position = &amp;amp;tree-&amp;gt;root;
    } else {
        position = &amp;amp;node-&amp;gt;left;
    }

    /* 确定是否有左结点 */
    if (*position != NULL) {
        bitree_rem_left(tree, *position);
        bitree_rem_right(tree, *position);
        if (tree-&amp;gt;destroy != NULL) {
            tree-&amp;gt;destroy((*position)-&amp;gt;data);
        }
        free(*position);
        *position = NULL;
        tree-&amp;gt;size--;
    }
}

void bitree_rem_right(biTree *tree, BiTreeNode *node)
{
    BiTreeNode **position;
    /* 空树 */
    if (bitree_size(tree) == 0) {
        return;
    }
    /* 传入 NULL 删除根结点下右结点 */
    if (node == NULL) {
        position = &amp;amp;tree-&amp;gt;root;
    } else {
        position = &amp;amp;node-&amp;gt;right;
    }

    /* 确认有右结点 */
    if (*position != NULL) {
        bitree_rem_left(tree, *position);
        biTree_rem_right(tree, *position);
        if (tree-&amp;gt;destroy != NULL) {
            tree-&amp;gt;destroy((*position)-&amp;gt;data);
        }
        free(*position);
        tree-&amp;gt;size--;
    }
}

int bitree_merge(BiTree *merge, BiTree *left, BiTree *right, const void *data)
{
    bitree_init(merge, left-&amp;gt;destroy);
    /* 设置新树根结点 */
    if (bitree_ins_left(merge, NULL, data) != 0) {
        bitree_destroy(merge);
        return -1;
    }
    bitree_root(merge)-&amp;gt;left = bitree_root(left);
    bitree_root(merge)-&amp;gt;right = bitree_root(right);
    /* 合并后树的大小 */
    merge-&amp;gt;size = merge-&amp;gt;size + bitree_size(left) + bitree_size(right);

    /* 将原先的左, 右树结点的大小和根结点重置 */
    left-&amp;gt;root = NULL;
    left-&amp;gt;size = 0;
    right-&amp;gt;root = NULL;
    right-&amp;gt;size = 0;
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;遍历二叉树的实现&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;#include "list.h"
#include "bitree.h"
/* 前序遍历 */
int preorder(const BiTreeNode *node, List *list)
{
    /* 非空结点 */
    if (!bitree_is_eob(node)) {
        /* 将数据加入到列表尾部 */
        if (list_ins_next(list, list_tail(list), bitree_data(node)) != 0) {
            return -1;
        }
        /* 递归左结点 */
        if (!bitree_is_eob(bitree_left(node))) {
            if (preorder(bitree_left(node), list) != 0) {
                return -1;
            }
        }
        /* 递归右结点 */
        if (!bitree_is_eob(bitree_right(node))) {
            if (preorder(bitree_right(node), list) != 0) {
                return -1;
            }
        }
    }
    return 0;
}
/* 中序遍历 */
int inorder(const BiTreeNode *node, List *list)
{
    /* 非 NULL 结点 */
    if (!bitree_is_eob(node)) {
        /* 查找左结点, 如果存在递归到末尾叶子结点 */
        if (!bitree_is_eob(bitree_left(node))) {
            if (inorder(bitree_left(node), list) != 0) {
                return -1;
            }
        }
        /* 将结点加到队列中 */
        if (list_ins_next(list, list_tail(list), bitree_data(node)) != 0) {
            return -1;
        }
        /* 查找右结点 */
        if (!bitree_is_eob(bitree_right(node))) {
            if (inorder(bitree_right(node), list) != 0) {
                return -1;
            }
        }
    }
    return 0;
}
/* 后序遍历 */
int postorder(const BiTreeNode *node, List *list)
{
    /* 非空结点 */
    if (!bitree_is_eob(node)) {
        /* 先递归左结点, 将左结点加入到队列中 */
        if (!bitree_is_eob(bitree_left(node))) {
            if (postorder(bitree_left(node), list) != 0) {
                return -1;
            }
        }
        /* 再递归右结点 */
        if (!bitree_is_eob(bitree_right(node))) {
            if (postorder(bitree_right(node), list) != 0) {
                return -1;
            }
        }
        /* 结点加入到队列 */
        if (list_ins_next(list, list_tail(list), bitree_data(node)) != 0) {
            return -1;
        }
    }
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;二叉搜索树&lt;/h3&gt;
&lt;p&gt;二叉搜索树中, 左结点总比根小, 右结点总比根大&lt;/p&gt;
&lt;p&gt;在二叉搜索树中查询一个结点, 从根结点开始, 当遇到一个比目标结点值大的结点时, 顺着该结点的左结点查找; 如果遇到的结点小于目标结点时, 则顺着该结点的右子树查找, 一直查到叶子结点&lt;/p&gt;
&lt;p&gt;只有当二叉搜索树保持平衡时其查找效率才是最高. 一种方法是将二叉树实现为 AVL树(Adel'son-Vel'skii and Landis)&lt;/p&gt;
&lt;p&gt;AVL树是一种特殊类型的二叉树, 它的每个结点都保存一份额外信息--结点的平衡因子&lt;/p&gt;
&lt;p&gt;结点的平衡因子 = 左子树高度 - 右子树高度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;+1 表示左倾斜(left-heavy)&lt;/li&gt;
&lt;li&gt;-1 表示右倾斜(rigth-heavy)&lt;/li&gt;
&lt;li&gt;0 表示平衡(left-heavy)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="AVL树" src="../../assets/images/AVL树.png" /&gt;&lt;/p&gt;
&lt;p&gt;向 AVL树中插入一个结点时, 必须计算因为执行了插入操作对平衡因子带来的改; 其次, 如果任何平衡因子为变为了±2, 就必须从这个结点开始往下重新平衡这棵树, 重新平衡的过程称为旋转&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LL(left-left)旋转&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 x 位于 A 的左子树下的左子树上, 执行 LL 旋转. 设 left 为 A 的左子树, 将 A 的左指针指向 left 的右结点, left 的右指针指向 A, 将原来指向 A 的指针改为指向 left, 旋转后, A 和 left 的平衡因子都改为 0&lt;/p&gt;
&lt;p&gt;&lt;img alt="LL旋转" src="../../assets/images/LL旋转.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LR(left-right)旋转&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 x 位于 A 的左子树下的右子树上时, 执行 LR 旋转. 设 left 是 A 的左子结点, A 的子孙结点 grandchild 为 left 的右子结点. 要执行 LR旋转, 将 left 的右子结点指向 grandchild 的左子结点, grandchild 的左子结点指向 left, A 的左子结点指向 grandchild 的右子结点, 再将 grandchild 的右子结点指向 A, 最后将原来指向 A 的指针指向 grandchild&lt;/p&gt;
&lt;p&gt;&lt;img alt="LR旋转" src="../../assets/images/LR旋转.png" /&gt;&lt;/p&gt;
&lt;p&gt;执行 LR 旋转后, 调整结点的平衡因子取决于旋转前 grandchild 结点的原平衡因子值&lt;/p&gt;
&lt;p&gt;下方的图展示了 3 种需要考虑到的情况&lt;/p&gt;
&lt;p&gt;如果 grandchild 结点的原始平衡因子为+1, 就将 A 的平衡因子设置为-1, 将 left 结点的平衡因子设置为 0&lt;/p&gt;
&lt;p&gt;如果 grandchild 结点的原始平衡因子为 0, 就将 A 和 left 结点的平衡因为都设置为 0&lt;/p&gt;
&lt;p&gt;如果 grandchild 结点的原始平衡因子为-1, 就将 A 的平衡因子设置为 0, 将 left 的平衡因为设置为+1&lt;/p&gt;
&lt;p&gt;&lt;img alt="LR旋转后更新" src="../../assets/images/LR旋转后更新.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RR(right-right)旋转&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 x 位于 A 的右子树下的右子树上时, 执行 RL 旋转. RR 旋转与 LL 旋转是对称关系. 设 A 的右结点为 right, 要执行 RR 旋转, 将 A 的右指针指向 right 的左子结点, right 的左指针指向 A, 原来指向 A 的指针修改为指向 right&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RL(right-left)旋转&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当 x 位于 A 的右子树下的左子树上的时, 执行 RL 旋转. RL 旋转与 LR 旋转是对称关系. 设 A 的右结点为 right, right 的左子结点为 grandchild. 要执行 RL 旋转, 将 right 结点的左子结点指向 grandchild 的右子结点, 将 grandchild 的右子结点指向 right, 将 A 的右子结点指向 grandchild 的左子结点, 将 grandchild 的左子结点指向 A, 最后将原来指向 A 的指针指向 grandchild&lt;/p&gt;
&lt;p&gt;如果 grandchild 结点的原始平衡因子为+1, 就将 A 的平衡因子设置为 0, 将 right 结点的平衡因子设置为 -1&lt;/p&gt;
&lt;p&gt;如果 grandchild 结点的原始平衡因子为 0, 就将 A 和 left 结点的平衡因为都设置为 0&lt;/p&gt;
&lt;p&gt;如果 grandchild 结点的原始平衡因子为-1, 就将 A 的平衡因子设置为 +1, 将 right 的平衡因为设置为0&lt;/p&gt;
&lt;p&gt;二叉搜索树头文件&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;#ifndef BISTREE_H
#define BISTREE_H

#include "bitree.h"

#define AVL_LFT_HEAVY 1
#define AVL_BALANCED 0
#define AVL_RGT_HEAVY -1

/* AVL 树结点结构 */
typedef struct AvlNode_ {
    void *data;
    /* 销毁结点后, 指向的数据被未被销毁时设置结点为隐藏 */
    int hidden;
    /* 平衡因子 */
    int factor;
}AvlNode;


typedef BiTree BisTree

void bistree_init(BisTree *tree, int (*compare)(const void *key1, const void *key2),
    void (*destroy)(void *data));
void bistree_destroy(BisTree *tree);
int bistree_insert(BisTree *tree, const void *data);
int bistree_remove(BisTree *tree, const void *data);
int bistree_lookup(BisTree *tree, void **data);

#define bistree_size(tree) ((tree)-&amp;gt;size)

#endif&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二叉搜索树实现&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* bistree.c */
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include "bistree.h"

static void destroy_right(BisTree *tree, BiTreeNode *node);

/* 左旋转 */
static void rotate_left(BiTreeNode **node)
{
    BiTreeNode *left, *grandchild;
    left = bitree_left(*node);
    if (((AvlNode *)bitree_data(left))-&amp;gt;factor == AVL_LFT_HEAVY) {
        /* Perform an LL rotation */
        bitree_left(*node) = bitree_right(left);
        bitree_right(left) = *node;
        ((AvlNode *)bitree_data(*node))-&amp;gt;factor = AVL_BALANCED;
        ((AvlNode *)bitree_data(left))-&amp;gt;factor = AVL_BALANCED;
        *node = left;
    } else {
        grandchild = bitree_right(left);
        bitree_right(left) = bitree_left(grandchild);
        bitree_left(grandchild) = left;
        bitree_left(*node) = bitree_right(grandchild);
        bitree_right(grandchild) = *node;

        switch (((AvlNode *)bitree_data(grandchild))-&amp;gt;factor) {
            case AVL_LFT_HEAVY:
                ((AvlNode *)bitree_data(*node))-&amp;gt;factor = AVL_RGT_HEAVY;
                ((AvlNode *)bitree_data(left))-&amp;gt;factor = AVL_BALANCED;
                break;

            case AVL_BALANCED:
                ((AvlNode *)bitree_data(*node))-&amp;gt;factor = AVL_BALANCED;
                ((AvlNode *)bitree_data(left))-&amp;gt;factor = AVL_BALANCED;
                break;

            case AVL_RGT_HEAVY:
                ((AvlNode *)bitree_data(*node))-&amp;gt;factor = AVL_BALANCED;
                ((AvlNode *)bitree_data(left))-&amp;gt;factor = AVL_LFT_HEAVY;
                break;
        }
        ((AvlNode *)bitree_data(grandchild))-&amp;gt;factor = AVL_BALANCED;
        *node = grandchild;
    }
}

/* 右旋转 */
static void rotate_right(BiTreeNode **node)
{
    BiTreeNode *right, *grandchild;
    right = bitree_right(*node);

    if (((AvlNode *)bitree_data(right))-&amp;gt;factor == AVL_RGT_HEAVY) {
        /* perform an RR rotation */
        bitree_right(*node) = bitree_left(right);
        bitree_left(right) = *node;
        ((AvlNode *)bitree_data(*node))-&amp;gt;factor = AVL_BALANCED;
        ((AvlNode *)bitree_data(right))-&amp;gt;factor = AVL_BALANCED;
        *node = right;
    } else {
        /* perform an RL rotation */
        grandchild = bitree_left(right);
        bitree_left(right) = bitree_right(grandchild);
        bitree_right(grandchild) = right;
        bitree_right(*node) = bitree_left(grandchild);
        bitree_left(grandchild) = *node;

        switch (((AvlNode *)bitree_data(grandchild))-&amp;gt;factor) {
            case AVL_LFT_HEAVY:
                ((AvlNode *)bitree_data(*node))-&amp;gt;factor = AVL_BALANCED;
                ((AvlNode *)bitree_data(right))-&amp;gt;factor = AVL_RGT_HEAVY;
                break;
            case AVL_BALANCED:
                ((AvlNode *)bitree_data(*node))-&amp;gt;factor = AVL_BALANCED;
                ((AvlNode *)bitree_data(right))-&amp;gt;factor = AVL_BALANCED;
                break;
            case AVL_RGT_HEAVY:
                ((AvlNode *)bitree_data(*node))-&amp;gt;factor = AVL_LFT_HEAVY;
                ((AvlNode *)bitree_data(right))-&amp;gt;factor = AVL_BALANCED;
                break;
        }
        ((AvlNode *)bitree_data(grandchild))-&amp;gt;factor = AVL_BALANCED;
        *node = grandchild;
    }
}

static void destroy_left(BisTree *tree, BiTreeNode *node)
{
    BiTreeNode **position;

    /* do not allow destructionn of an empty tree */
    if (bitree_size(tree) == 0) {
        return;
    }

    /* determine where to destroy nodes */
    if (node == NULL) {
        position = &amp;amp;tree-&amp;gt;root;
    } else {
        position = &amp;amp;node-&amp;gt;left;
    }

    /* destroy the nodes */
    if (*position != NULL) {
        destroy_left(tree, *position);
        destroy_right(tree, *position);

        if (tree-&amp;gt;destroy != NULL) {
            /* call a user-defined function to free dynamically allocated data */
            tree-&amp;gt;destroy(((AvlNode *)(*position)-&amp;gt;data)-&amp;gt;data);
        }

        /* free the AVL data in the node, then free the node itself */
        free((*position)-&amp;gt;data);
        free(*position);
        *position = NULL;

        /* adjust the size of the tree to account for the destroyed node */
        tree-&amp;gt;size--;
    }
}

static void destroy_right(BisTree *tree, BiTreeNode *node)
{
    BiTreeNode **position;

    /* do not allow destruction of an empty tree */
    if (bitree_size(tree) == 0) {
        return;
    }

    /* determine where to destroy nodes */
    if (node == NULL) {
        position = &amp;amp;tree-&amp;gt;root;
    } else {
        position = &amp;amp;node-&amp;gt;right;
    }

    /* destroy the nodes */
    if (*position != NULL) {
        destroy_left(tree, *position);
        destroy_right(tree, *position);

        if (tree-&amp;gt;destroy != NULL) {
            /* call a user-defined function to free dynamically allocated data */
            tree-&amp;gt;destroy(((AvlNode *)(*position)-&amp;gt;data)-&amp;gt;data);
        }

        /* free the AVL data in the node, then free the node itself */
        free((*position)-&amp;gt;data);
        free(*position);
        *position = NULL;

        /* adjust the size of the tree to account for the destroy node */
        tree-&amp;gt;size--;
    }
}

static int insert(BisTree *tree, BiTreeNode **node, const void *data, int *balanced)
{
    AvlNode *avl_data;
    int cmpval, retval;

    /* insert the data into the tree */
    if (bitree_is_eob(*node)) {
        /* handle insertion into an empty tree */
        if ((avl_data = (AvlNode *)malloc(sizeof(AvlNode))) == NULL) {
            return -1;
        }

        avl_data-&amp;gt;factor = AVL_BALANCED;
        avl_data-&amp;gt;hidden = 0;
        avl_data-&amp;gt;data = (void *)data;

        return bitree_ins_left(tree, *node, avl_data);
    } else {
        /* handle insertion into a tree that is not empty */
        cmpval = tree-&amp;gt;compare(data, ((AvlNode *)bitree_data(*node))-&amp;gt;data);
        if (cmpval &amp;lt; 0) {
            /* move to the left */
            if (bitree_is_eob(bitree_left(*node))) {
                if ((avl_data = (AvlNode *)malloc(sizeof(AvlNode))) == NULL) {
                    return -1;
                }
                avl_data-&amp;gt;factor = AVL_BALANCED;
                avl_data-&amp;gt;hidden = 0;
                avl_data-&amp;gt;data = (void *)data;

                if (bitree_ins_left(tree, *node, avl_data) != 0) {
                    return -1;
                }
                *balanced = 0;
            } else {
                if ((retval = insert(tree, &amp;amp;bitree_left(*node), data, balanced)) 
                    != 0) {
                    return retval;
                }
            }

            /* ensure that the tree remains balance */
            if (!(*balanced)) {
                switch (((AvlNode *)bitree_data(*node))-&amp;gt;factor) {
                    case AVL_LFT_HEAVY:
                        rotate_left(node);
                        *balanced = 1;
                        break;
                    case AVL_BALANCED:
                        ((AvlNode *)bitree_data(*node))-&amp;gt;factor = AVL_LFT_HEAVY;
                        break;
                    case AVL_RGT_HEAVY:
                        ((AvlNode *)bitree_data(*node))-&amp;gt;factor = AVL_BALANCED;
                        *balanced = 1;
                        break;
                }
            }
        } /* if (cmpval &amp;lt; 0) */
        else if (cmpval &amp;gt; 0) {
            /* move to right */
            if (bitree_is_eob(bitree_right(*node))) {
                if ((avl_data = (AvlNode *)malloc(sizeof(AvlNode))) == NULL) {
                    return -1;
                }

                avl_data-&amp;gt;factor = AVL_BALANCED;
                avl_data-&amp;gt;hidden = 0;
                avl_data-&amp;gt;data = (void *)data;

                if (bitree_ins_right(tree, *node, avl_data) != 0) {
                    return -1;
                }
                *balanced = 0;
            } else {
                if ((retval = insert(tree, &amp;amp;bitree_right(*node), data, balanced)) != 0) {
                    return retval;
                }
            }

            /* ensure that the tree remains balanced */
            if (!(*balanced)) {
                switch (((AvlNode *)bitree_data(*node))-&amp;gt;factor) {
                    case AVL_LFT_HEAVY:
                        ((AvlNode *)bitree_data(*node))-&amp;gt;factor = AVL_BALANCED;
                        *balanced = 1;
                        break;
                    case AVL_BALANCED:
                        ((AvlNode *)bitree_data(*node))-&amp;gt;factor = AVL_RGT_HEAVY;
                        break;
                    case AVL_RGT_HEAVY:
                    rotate_right(node);
                    *balanced = 1;
                }
            }
        } /* if (cmpval &amp;gt; 0) */
        else {
            /* handle finding a copy of the data */
            if (!((AvlNode *)bitree_data(*node))-&amp;gt;hidden) {
                /* do nothing since the data is in the tree and not hidden */
                return 1;
            } else {
                /* insert the new data and mark it as not hidden */
                if (tree-&amp;gt;destroy != NULL) {
                    /* destroy the hidden data since it is being replaced */
                    tree-&amp;gt;destroy(((AvlNode *)bitree_data(*node))-&amp;gt;data);
                }
                ((AvlNode *)bitree_data(*node))-&amp;gt;data = (void *)data;
                ((AvlNode *)bitree_data(*node))-&amp;gt;hidden = 0;

                /* do not rebalance because the tree structure is unchanged */
                *balanced = 1;
            }
        }
    }
    return 0;
}

statice int hide(BisTree *tree, BiTreeNode *node, const void *data)
{
    int cmpval, retval;

    if (bitree_is_eob(node)) {
        /* return that the data was not found */
        return -1;
    }

    cmpval = tree-&amp;gt;compare(data, ((AvlNode *)bitree_data(node))-&amp;gt;data);
    if (cmpval &amp;lt; 0) {
        /* move to the left */
        retval = hide(tree, bitree_left(node), data);
    } else if (cmpval &amp;gt; 0) {
        /* move to the right */
        retval = hide(tree, bitree_right(node), data);
    } else {
        /* mark the node as hidden */
        ((AvlNode *)bitree_data(node))-&amp;gt;hidden = 1;
        retval = 0;
    }
    return retval;
}

static int lookup(BisTree *tree, BiTreeNode *node, void **data)
{
    int cmpval, retval;

    if (bitree_is_eob(node)) {
        /* return that the data was not found */
        return -1;
    }

    cmpval = tree-&amp;gt;compare(*data, ((AvlNode *)bitree_data(node))-&amp;gt;data);
    if (cmpval &amp;lt; 0) {
        /* move to the left */
        retval = lookup(tree, bitree_left(node), data);
    } else if (cmpval &amp;gt; 0) {
        /* move to the right */
        retval = lookup(tree, bitree_right(node), data);
    } else {
        if (!((AvlNode *)bitree_data(node))-&amp;gt;hidden) {
            /* pass back the data from the tree */
            *data = ((AvlNode *)bitree_data(node))-&amp;gt;data;
            retval = 0;
        } else {
            /* return that the data was not found */
            return -1;
        }
    }
    return retval;
}

void bistree_init(BiTree *tree, int (*compare)(const void *key1, const void *key2),
    void (*destroy)(void *data))
{
    /* initialize the tree */
    bitree_init(tree, destroy);
    tree-&amp;gt;compare = compare;
}

void bistree_destroy(Bistree *tree)
{
    /* destroy all nodes in the tree */
    destroy_left(tree, NULL);

    /* no operations are allowed now, but clear the structure as a precaution */
    memset(tree, 0, sizeof(BisTree));
}

int bistree_insert(BisTree *tree, const void *data)
{
    int balanced = 0;
    return insert(tree, &amp;amp;bitree_root(tree), data, &amp;amp;balanced);
}

int bistree_remove(BisTree *tree, const void *data)
{
    return hide(tree, bitree_root(tree), data);
}

int bistree_lookup(BisTree *tree, void **data)
{
    return lookup(tree, bitree_root(tree), data);
}&lt;/code&gt;&lt;/pre&gt;</content><category term="算法"></category><category term="C"></category><category term="集合"></category><category term="数据结构"></category></entry><entry><title>Mastering Algroithms with C-4: 哈希表</title><link href="https://ivicel.info/2017/03/mastering-algroithms-with-c-4-ha-xi-biao.html" rel="alternate"></link><published>2017-03-24T00:00:00+08:00</published><updated>2017-03-24T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2017-03-24:/2017/03/mastering-algroithms-with-c-4-ha-xi-biao.html</id><summary type="html">&lt;p&gt;哈希表通过一种最有效的检索方法--&lt;strong&gt;散列&lt;/strong&gt;来查找元素, 一个哈希表通过一个哈希函数, 在所有可能的键与槽位之间建立一张映射表. 理想的状态就是把不同键生成的哈希值互不相同, 但这会使得哈希表里的条目变得巨大, 而且条目中可能绝大多数是无用的.&lt;/p&gt;
&lt;p&gt;所以, 通常哈希函数把一些不同的键映射到表中相同的槽位上, 这就会产生冲突, 一个好的哈希函数要最大限度的地减少冲突&lt;/p&gt;
&lt;h3&gt;链式哈希表(Chained Hash Table)&lt;/h3&gt;
&lt;p&gt;链式哈希表从根本上来说是由一组链表构成, 每个链表可以看成一个"桶(bucket)"&lt;/p&gt;
&lt;p&gt;链式哈希表在插入元素时, 将其键传入一个&lt;strong&gt;哈希函数&lt;/strong&gt;&lt;code&gt;h(k)&lt;/code&gt;, 函数通过散列的方式告知元素属于哪个"桶",然后在相应的&lt;strong&gt;链表头&lt;/strong&gt;插入元素&lt;/p&gt;
&lt;p&gt;在查找或删除元素时, 用同样的方式先找到元素的"桶", 然后遍历相应的链表&lt;/p&gt;
&lt;p&gt;每个链表并不限制包含元素的个数, 但是表如果变得很大, 性能就会变得很低&lt;/p&gt;
&lt;p&gt;&lt;img alt="链式哈希表" src="../../assets/images/链式哈希表.png" /&gt;&lt;/p&gt;
&lt;h4&gt;冲突的发生&lt;/h4&gt;
&lt;p&gt;当两个键通过哈希函数到表里相同的位置时, 这两个键就产生的冲突.&lt;/p&gt;
&lt;p&gt;链式哈希表当产生冲突时, 它就把元素放到冲突发生的"桶"中. 这就产生一个问题, 如果总是发生这样的冲突, 那么这个桶就会越来越大, 里面的元素越来越多&lt;/p&gt;
&lt;p&gt;理想的情况是, 把元素平均和随机的分配到每一个 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;哈希表通过一种最有效的检索方法--&lt;strong&gt;散列&lt;/strong&gt;来查找元素, 一个哈希表通过一个哈希函数, 在所有可能的键与槽位之间建立一张映射表. 理想的状态就是把不同键生成的哈希值互不相同, 但这会使得哈希表里的条目变得巨大, 而且条目中可能绝大多数是无用的.&lt;/p&gt;
&lt;p&gt;所以, 通常哈希函数把一些不同的键映射到表中相同的槽位上, 这就会产生冲突, 一个好的哈希函数要最大限度的地减少冲突&lt;/p&gt;
&lt;h3&gt;链式哈希表(Chained Hash Table)&lt;/h3&gt;
&lt;p&gt;链式哈希表从根本上来说是由一组链表构成, 每个链表可以看成一个"桶(bucket)"&lt;/p&gt;
&lt;p&gt;链式哈希表在插入元素时, 将其键传入一个&lt;strong&gt;哈希函数&lt;/strong&gt;&lt;code&gt;h(k)&lt;/code&gt;, 函数通过散列的方式告知元素属于哪个"桶",然后在相应的&lt;strong&gt;链表头&lt;/strong&gt;插入元素&lt;/p&gt;
&lt;p&gt;在查找或删除元素时, 用同样的方式先找到元素的"桶", 然后遍历相应的链表&lt;/p&gt;
&lt;p&gt;每个链表并不限制包含元素的个数, 但是表如果变得很大, 性能就会变得很低&lt;/p&gt;
&lt;p&gt;&lt;img alt="链式哈希表" src="../../assets/images/链式哈希表.png" /&gt;&lt;/p&gt;
&lt;h4&gt;冲突的发生&lt;/h4&gt;
&lt;p&gt;当两个键通过哈希函数到表里相同的位置时, 这两个键就产生的冲突.&lt;/p&gt;
&lt;p&gt;链式哈希表当产生冲突时, 它就把元素放到冲突发生的"桶"中. 这就产生一个问题, 如果总是发生这样的冲突, 那么这个桶就会越来越大, 里面的元素越来越多&lt;/p&gt;
&lt;p&gt;理想的情况是, 把元素平均和随机的分配到每一个"桶"中, 这种称为&lt;strong&gt;均匀散列&lt;/strong&gt;(uniform hash). 实际情况只能是无限接近平均分配&lt;/p&gt;
&lt;p&gt;一个重要的因素--&lt;strong&gt;负载因子&lt;/strong&gt;(load factor)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;a = n / m&lt;/code&gt; 其中, &lt;code&gt;n&lt;/code&gt;是元素个数, &lt;code&gt;m&lt;/code&gt;是"桶"的个数&lt;/p&gt;
&lt;p&gt;最好的情况是每个链表的中的元素个数接近负载因子的数值&lt;/p&gt;
&lt;h4&gt;选择哈希函数&lt;/h4&gt;
&lt;p&gt;哈希函数&lt;code&gt;h(k) = x&lt;/code&gt;将键&lt;code&gt;k&lt;/code&gt;映射到哈希表中的&lt;code&gt;x&lt;/code&gt;位置, 大多数的散列方法假设&lt;code&gt;k&lt;/code&gt;设整数, 这样&lt;code&gt;k&lt;/code&gt;能够很容易的以数学的方式修改, 使&lt;code&gt;x&lt;/code&gt;更加均匀的分布在表中, 当&lt;code&gt;k&lt;/code&gt;不是一个整数时, 我们需要将&lt;code&gt;k&lt;/code&gt;转换为整数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取余法: &lt;code&gt;h(k) = k mod m&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常选择的&lt;code&gt;m&lt;/code&gt;会是一个素数, 且不要太接近于 2 的幂, 同时还要考虑存储的限制和负载因子&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;乘法: &lt;code&gt;h(k) = m(kA mod 1)&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;(0&amp;lt;A&amp;lt;1)通常是 0.618 左右&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种方法对&lt;code&gt;m&lt;/code&gt;的选择不像取余法中那么慎重&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* 一个适用于处理字符串的哈希函数 */
/* hashpjw.c */

unsigned int hashpjw(const void *key)
{
    const char *ptr = key;
    unsigned int val = 0;
    unsigned int tmp;

    while (*ptr != '\0') {
        val = (val &amp;lt;&amp;lt; 4) + *ptr;

        if (tmp = (val &amp;amp; 0xf0000000)) {
            val = val ^ (tmp &amp;gt;&amp;gt; 24);
            val = val ^ tmp;
        }
        ptr++;
    }
    /* PRIME_TBLSIZ 是实际的表的大小 */
    return val % PRIME_TBLSIZ;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;链式哈希表头文件&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/** chtbl.h */
#ifndef CHTBL_H
#define CHTBL_H

#include &amp;lt;stdlib.h&amp;gt;
#include "list.h"

/* 链式哈希表结构 */
typedef struct CHTbl_ {
    /* "桶的个数" */
    int buckets;
    /* hash_func 是自定义传入的哈希函数 */
    int (*hash_func)(const void *key);
    int (*match)(const void *key1, const void *key2);
    void (*destroy)(void *data);
    /* 元素数量 */
    int size;
    List *table;
}CHTbl;

/* 初始化哈希表 */
int chtbl_init(CHTbl *htbl, int buckets, int (*hash_func)(const void *key), 
    int (*match)(const void *key1, const void *key2), void (*destroy)(void *data));
/* 销毁函数 */
void chtbl_destroy(CHTbl *htbl);
/* 插入数据 */
int chtbl_insert(CHTbl *htbl, const void *data);
/* 删除数据 */
int chtbl_remove(CHTbl *htbl, void **data);
/* 查找数据 */
int chtbl_lookup(const CHTbl *htbl, void **data);

#define chtbl_size(htbl) ((htbl)-&amp;gt;size)

#endif&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;链式哈希表的实现&lt;/p&gt;
&lt;p&gt;&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#include "list.h"
#include "chtbl.h"

int chtbl_init(CHTbl *htbl, int buckets, int (*hash_func)(const void *key),
    int (*match)(const void *key1, const void *key2), void (*destroy)(void *data))
{
    /* 初始化所需要多少个链表, 即多少个"桶"的内存 */
    if ((htbl-&amp;gt;table = (List *)malloc(sizeof(List) * buckets)) == NULL) {
        return -1;
    }

    htbl-&amp;gt;buckets = buckets;
    /* 为每个链表设置销毁函数 */
    for (int i = 0; i &amp;lt; htbl-&amp;gt;buckets; i++) {   
        /* list_init(&amp;amp;htbl-&amp;gt;table[i], destroy); */
        list_init(htbl-&amp;gt;table + i, destroy);
    }

    htbl-&amp;gt;hash_func = hash_func;
    htbl-&amp;gt;match = match;
    htbl-&amp;gt;destroy = destroy;
    /* 初始表长度 */
    htbl-&amp;gt;size = 0;

    return 0;
}

void chtbl_destroy(CHTbl *htbl)
{
    for (int i = 0; i &amp;lt; htbl-&amp;gt;buckets; i++) {
        list_destroy(htbl-&amp;gt;table + i);
    }
    free(htbl-&amp;gt;table);
    memset(htbl, 0, sizeof(CHTbl));
}

int chtbl_insert(CHTbl *htbl, const void *data)
{
    void *temp;
    int bucket, retval;

    temp = (void *)data;
    /* 不插入重复的数据 */
    if (chtbl_lookup(htbl, &amp;amp;temp) == 0) {
        return 1;
    }
    /* hash the key */
    bucket = htbl-&amp;gt;hash_func(data) % htbl-&amp;gt;buckets;
    if ((retval = list_ins_next(htbl-&amp;gt;table + bucket, NULL, data)) == 0) {
        htbl-&amp;gt;size++;
    }
    return retval;
}

int chtbl_remove(CHTbl *htbl, void **data)
{
    ListElmt *element, *prev;
    int bucket;
    /* 使用 hash 函数确认数据属于哪个"桶" */
    bucket = htbl-&amp;gt;hash_func(*data) % htbl-&amp;gt;buckets;
    prev = NULL;
    /* 在"桶"中查找, 即是查找链表 */
    for (element = list_head(htbl-&amp;gt;table + bucket); element != NULL;
        element = list_next(element)) {
        if (htbl-&amp;gt;match(*data, list_data(element))) {
            /* 如果查找到相同数据, 删除这个元素 */
            if (list_rem_next(htbl-&amp;gt;table + bucket, prev, data) == 0) {
                htbl-&amp;gt;size--;
                return 0;
            } else {
                return -1;
            }
        }
        prev = element;
    }
    return -1;
}

int chtbl_lookup(const CHTbl *htbl, void **data)
{
    ListElmt *element;
    int bucket;
    /* Hash the key. */
    bucket = htbl-&amp;gt;(*data) % htbl-&amp;gt;buckets;

    for (element = lsit_head(htbl-&amp;gt;table + buckets); element != NULL;
        element = list_next(element)) {
        if (hb-&amp;gt;match(*data, list_data(element))) {
            *data = list_data(element);
            return 0;
        }
    }
    return -1;
}&lt;/code&gt;&lt;/pre&gt;
链式哈希表的应用: 符号表&lt;/p&gt;
&lt;p&gt;在使用程序解析某种语法时, 为了能够更有效的管理程序中的符号信息, 通学使用一种叫做符号表的数据结构, 一般使用哈希表来实现. 对符号表进行插入数据时, 也即是向哈希表插入数据, 称为词法分析.&lt;/p&gt;
&lt;p&gt;下面的例子是一个非常简单的词法分析器, 分析传入的字符串, &lt;code&gt;next_token&lt;/code&gt;从输入&lt;code&gt;istream&lt;/code&gt;中取得下一个字符串, 如果没有了, 就返回退出&lt;/p&gt;
&lt;p&gt;假设输入的字符只有两种: 一种是数字, 另一种是数字之外的字符. 字符之间以空格隔开&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* lex.c */
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include "chtbl.h"

typedef enum Token_ {lexit, error, digit, other} Token;

Token lex(const char *istream, CHTbl *symtbl);

static char *next_token(const char *istream) {
    /* check next there is a token */
    /* return NULL; */
}

typedef struct Symbol_ {
    char *lexeme;
    Token token;
}Symbol;

Token lex(const char *istream, CHTbl *symtbl)
{
    Token token;
    Symbol *symbol;
    int length, retval, i;

    if ((symbol = (Symbol *)malloc(sizeof(Symbol))) == NULL) {
        return error;
    }
    /* next_token 返回下一个字符或者 NULL */
    if ((symbol-&amp;gt;lexeme = next_token(istream)) == NULL) {
        /* 如果没有下一个词 */
        free(symbol);
        return lexit;
    }else {
        symbol-&amp;gt;token = digit;
        length = strlen(symbol-&amp;gt;lexeme);

        for (i = 0; i &amp;lt; length; i++) {
            /* -&amp;gt; 和 [] 同一运算级, 从左到右 */
            if (!isdigit(symbol-&amp;gt;lexeme[i])) {
                /* 检查是否是数字 */
                symbol-&amp;gt;token = other;
            }
        }
        memcpy(&amp;amp;token, &amp;amp;symbol-&amp;gt;token, sizeof(Token));
        /* 将符号插入哈希表中 */
        if ((retval = chtbl_insert(symtbl, symbol)) &amp;lt; 0) {
            free(symbol);
            return error;
        } else if (retval == 1) {
            /* 符号已经存在于哈希表中 */
            free(symbol);
        }
    }
    return token;
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;开地址哈希表(Open-Addressed Hash Tables)&lt;/h3&gt;
&lt;p&gt;在链式哈希表中, 元素存放在每个地址的"桶"中, 而在开地址哈希表中, 元素存放在表本身&lt;/p&gt;
&lt;h4&gt;冲突解决&lt;/h4&gt;
&lt;p&gt;在开地址哈希表中, 探查这个表, 直到找到一个可以旋转元素的槽. 例如, 如果要插入一个元素, 我们探查槽位直到找一个空槽, 然后将元素插入些槽中. 如果要删除一个元素, 我们探查槽位直到定位到该元素或直到找一个空槽. 如果在找到元素之前找到一个空槽或遍历完所有槽位, 那么说明元素不在表中&lt;/p&gt;
&lt;p&gt;需要进行过多少次探查后就停止探查取决于: 哈希表的负载因子和元素均匀分布程度&lt;/p&gt;
&lt;p&gt;在开地址哈希表中&lt;code&gt;a=n/m&lt;/code&gt;, 因为每个槽位至多能够容纳一个元素, 所以&lt;code&gt;a&lt;/code&gt;总是小于等于 1, 假设进行均匀散列, 探查的槽位个数是&lt;code&gt;1/(1-a)&lt;/code&gt;, 明显的当表中负载因子越大, 所探查次就越多&lt;/p&gt;
&lt;h4&gt;线性探查&lt;/h4&gt;
&lt;p&gt;开地址哈希表中的一种简单的探查方法就是探查表中连续的槽位.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;h(k, i) = (h&amp;lt;sup&amp;gt;'&amp;lt;/sup&amp;gt;(k)+i) mod m&lt;/code&gt;  0 &amp;lt; i &amp;lt; m-1(m 是表中槽位个数), h&lt;sup&gt;'&lt;/sup&gt;是一个辅助函数, 比如取余法函数&lt;/p&gt;
&lt;p&gt;&lt;img alt="线性探查" src="../../assets/images/线性探查.png" /&gt;&lt;/p&gt;
&lt;h4&gt;双散列&lt;/h4&gt;
&lt;p&gt;最有效地探查开地址哈希表的方法之一, 就是通过求两个辅助哈希函数的哈希编码之和, 来得到最终的哈希编码值&lt;/p&gt;
&lt;p&gt;&lt;code&gt;h(h, i)  = (h&amp;lt;sub&amp;gt;1&amp;lt;/sub&amp;gt;(k) + i * h&amp;lt;sub&amp;gt;2&amp;lt;/sub&amp;gt;(k)) mod m&lt;/code&gt;&lt;br /&gt;
h&lt;sub&gt;1&lt;/sub&gt;和h&lt;sub&gt;2&lt;/sub&gt;分别是两个不两同的哈希辅助函数, 为了保证第二次访问任何一个槽之前, 其他所有槽都访问过了, 方法一是: m 必须是 2 次幂, 让 h&lt;sub&gt;2&lt;/sub&gt; 返回一个奇数值; 另一种方法是选择 m 为一个素数, h&lt;sub&gt;2&lt;/sub&gt; 返回值在 1 &amp;lt;= h&lt;sub&gt;2&lt;/sub&gt;(k) &amp;lt;= m-1 之间&lt;/p&gt;
&lt;p&gt;通常情况下, 令h&lt;sub&gt;1&lt;/sub&gt;(k) = k mod m, h&lt;sub&gt;2&lt;/sub&gt;(k) = 1 + (k mod m&lt;sup&gt;'&lt;/sup&gt;), 其中 m&lt;sup&gt;'&lt;/sup&gt; 略小于 m, 类似 m-1, m-2. 双散列的优点是能够探查并产生较好的颁布, 缺点是必须限制 m 的值, 也是表的大小不变, 这样才能保证在一系列探查中访问表中所有槽之后才会再次探查任何槽&lt;/p&gt;
&lt;p&gt;&lt;img alt="双散列" src="../../assets/images/双散列.png" /&gt;&lt;/p&gt;
&lt;p&gt;开地址哈希表头文件&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;#ifndef OHTBL_H
#define OHTBL_H

#include &amp;lt;stdlib.h&amp;gt;

/* 开地址哈希表表结构, 使用双散列方法 */
typedef struct OHTbl_ {
    /* 表中槽位个数 */
    int positions;
    /* 一个哈希表初始化时, 空槽通常包含一个指向 NULL 的空指针
     * 当删除一个元素时, 不能将删除元素的数据指向 NULL, 这是由于当查找
     * 接下来的元素时, NULL 表明些槽位是空的, 随之探查过程将停止
     * 这样一个或多个元素可能被插入之前删除过元素的槽位中, 但实际指向数据还存在
     * 
     * 所以当删除一个元素, 把该槽们标记为一个特殊的值, 来指明这个地址曾经删除一个元素 
     * 
     */
    void *vacated;
    /* 散列方法一 */
    int (*hash_f1)(const void *key);
    /* 散列方法二 */
    int (*hash_f2)(const void *key);
    int (*match)(const void *key1, const void *key2);
    void (*destroy)(void *data);
    /* 表中元素数量 */
    int size;
    /* 槽位指针, 初始为 NULL, 插入数据后其指向数据 */
    void **table;
}OHTbl;
/* 初始化哈希表 */
int ohtbl_init(OHTbl *htbl, int positions, int (*hash_f1)(const void *key),
    int (*hash_f2)(const void *key2), int (*match)(const void *key1, const void *key2),
    void (*destroy)(void *data));
/* 销毁表 */
void ohtbl_destroy(OHTbl *htbl);
/* 插入数据 */
void ohtbl_insert(OHTbl *htbl, const void *data);
/* 删除数据 */
int ohtbl_remove(OHTbl *htbl, void **data);
/* 查找数据 */
int ohtbl_lookup(const OHTbl *htbl, void **data);
/* 哈希表大小 */
#define ohtbl_size(htbl) ((htbl)-&amp;gt;size)

#endif&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开地址哈希表的实现&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* ohtbl.c */
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include "ohtbl.h"

/* 元素辅助 */
static char vacated;
/* 初始化哈希表 */
int ohtbl_init(OHTbl *htbl, int positions, int(*hash_f1)(const void *key),
    int (*hash_f2)(const void *key), int (*match)(const void *key1, const void *key2),
    void (*destory)(void *data))
{
    int i;
    /* 为哈希表槽们指针申请内存 */
    if ((htbl-&amp;gt;table = (void **)malloc(positions * sizeof(void *))) == NULL) {
        return -1;
    }
    /* 初始槽位大小 */
    htbl-&amp;gt;positions = positions;
    /* 将每个槽位都初始为 NULL */
    for (i = 0; i &amp;lt; htbl-&amp;gt;positions; i++) {
        htbl-&amp;gt;table[i] = NULL;
    }
    /* 初始辅助指针 */
    htbl-&amp;gt;vacated = &amp;amp;vacated;

    htbl-&amp;gt;hash_f1 = hash_f1;
    htbl-&amp;gt;hash_f2 = hash_f2;
    htbl-&amp;gt;match = match;
    htbl-&amp;gt;destroy = destroy;
    htbl-&amp;gt;size = 0;
    return 0;
}
/* 销毁 */
void ohtbl_destroy(OHTbl *htbl)
{
    int i;
    if (htbl-&amp;gt;destroy != NULL) {
        /* 遍历每个槽位, 如果槽为空, 并且槽位没有被标注过有元素插入, 销毁这个槽位 */
        for (i = 0; i &amp;lt; htbl-&amp;gt;positions; i++) {
            if (htbl-&amp;gt;table[i] != NULL &amp;amp;&amp;amp; htbl-&amp;gt;table[i] != htbl-&amp;gt;vacated) {
                htbl-&amp;gt;destroy(htbl-&amp;gt;table[i]);
            }
        }
    }

    free(htbl-&amp;gt;table);
    memset(htbl, 0, sizeof(OHTbl));
}
/* 插入元素 */
int ohtbl_insert(OHTbl *htbl, const void *data)
{
    void *temp;
    int position, i;
    /* 如果表的大小达到最大槽位数, 即哈希表已满, 无法再插入元素 */
    if (htbl-&amp;gt;size == htbl-&amp;gt;positions) {
        return -1;
    }
    /* 不插入相同的数据到表中 */
    temp = (void *)data;
    if (ohtbl_lookup(htbl, &amp;amp;temp) == 0) {
        return 1;
    }

    /* use double hashing to hash the key */
    for (i = 0; i &amp;lt; htbl-&amp;gt;positions; i++) {
        /* 双散列方法查找槽位 */
        position = (htbl-&amp;gt;hash_f1(data) + (i * htbl-&amp;gt;hash_f2(data))) % htbl-&amp;gt;positions;
        /* 如果槽位为 NULL 或者该槽位没有指向标记值则可以将数据插入到这个槽位中 */
        if (htbl-&amp;gt;table[position] == NULL || htbl-&amp;gt;table[position] == htbl-&amp;gt;vacated) {
            /* 将槽位指向数据 */
            htbl-&amp;gt;table[position] = (void *)data;
            htbl-&amp;gt;size++;
            return 0;
        }
    }
    return -1;
}

int ohtbl_remove(OHTbl *htbl, void **data)
{
    int position, i;

    for (i = 0; i &amp;lt; htbl-&amp;gt;position; i++) {
        position = (htbl-&amp;gt;hash_f1(*data) + (i *htbl-&amp;gt;hash_f2(*data))) % htbl-&amp;gt;positions;

        if (htbl-&amp;gt;table[position] == NULL) {
            /* 没有查找到数据 */
            return -1;
        } else if (htbl-&amp;gt;table[position] == htbl-&amp;gt;vacated) {
            /* 元素被标注为删除过, 继续查找是否有冲突产生过 */
            continue;
        } else if (htbl-&amp;gt;match(htbl-&amp;gt;table[position], *data)) {
            /* 查找到元素, 对比其中数据 */
            *data = htbl-&amp;gt;table[position];
            htbl-&amp;gt;table[position] = htbl-&amp;gt;vacated;
            htbl-&amp;gt;size--;
            return 0;
        }
    }
    return -1;
}

int ohtbl_lookup(const OHTbl *htbl, void **data)
{
    int position, i;

    for (i = 0; i &amp;lt; htbl-&amp;gt;positions; i++) {
        position = (htbl-&amp;gt;hash_f1(*data) + (i * htbl-&amp;gt;hash_f2(*data))) % htbl-&amp;gt;positions;
        if (htbl-&amp;gt;table[position] == NULL) {
            return -1;
        } else if (htbl-&amp;gt;match(htbl-&amp;gt;table[position], *data)) {
            *data = htbl-&amp;gt;table[position];
            return 0;
        }
    }
    return -1;
}&lt;/code&gt;&lt;/pre&gt;</content><category term="算法"></category><category term="C"></category><category term="集合"></category><category term="数据结构"></category></entry><entry><title>Mastering Algroithms with C-3: 集合</title><link href="https://ivicel.info/2017/03/mastering-algroithms-with-c-3-ji-he.html" rel="alternate"></link><published>2017-03-23T00:00:00+08:00</published><updated>2017-03-23T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2017-03-23:/2017/03/mastering-algroithms-with-c-3-ji-he.html</id><summary type="html">&lt;p&gt;集合是不同对象的无序聚集&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;集合的成员是无序的&lt;/li&gt;
&lt;li&gt;每一个成员只在集合中出现一次&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;集合的定义: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空集&lt;/li&gt;
&lt;li&gt;集合相等&lt;/li&gt;
&lt;li&gt;子集&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;集合操作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交集&lt;/li&gt;
&lt;li&gt;并集&lt;/li&gt;
&lt;li&gt;差集&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现集合的一种好的方法是采用链表. 但每一次插入删除数据都需要遍历集合中的每一个成员, 时间复杂度 O(n)&lt;/p&gt;
&lt;p&gt;由于性能问题, 顺序查找的方式只适合比较小型的集合数据, 可以使用哈希等查找技术提高效率&lt;/p&gt;
&lt;p&gt;集合的抽象数据类型头文件定义&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* set.h */
#ifndef SET_H
#define SET_H

#include &amp;lt;stdlib.h&amp;gt;

/* 集合元素 */
typedef struct SetElmt_ {
    void *data;
    struct SetElmt_ next;
}SetElmt;
/* 集合结构 */
typedef struct Set_ {
    /* 集合大小 */
    int size;
    /* 指向集合头结点 */
    SetElmt *head;
    /* 集合尾结点 …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;p&gt;集合是不同对象的无序聚集&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;集合的成员是无序的&lt;/li&gt;
&lt;li&gt;每一个成员只在集合中出现一次&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;集合的定义: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空集&lt;/li&gt;
&lt;li&gt;集合相等&lt;/li&gt;
&lt;li&gt;子集&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;集合操作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交集&lt;/li&gt;
&lt;li&gt;并集&lt;/li&gt;
&lt;li&gt;差集&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现集合的一种好的方法是采用链表. 但每一次插入删除数据都需要遍历集合中的每一个成员, 时间复杂度 O(n)&lt;/p&gt;
&lt;p&gt;由于性能问题, 顺序查找的方式只适合比较小型的集合数据, 可以使用哈希等查找技术提高效率&lt;/p&gt;
&lt;p&gt;集合的抽象数据类型头文件定义&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* set.h */
#ifndef SET_H
#define SET_H

#include &amp;lt;stdlib.h&amp;gt;

/* 集合元素 */
typedef struct SetElmt_ {
    void *data;
    struct SetElmt_ next;
}SetElmt;
/* 集合结构 */
typedef struct Set_ {
    /* 集合大小 */
    int size;
    /* 指向集合头结点 */
    SetElmt *head;
    /* 集合尾结点 */
    SetElmt *tail;
    void (*destroy)(void *data);
    /* 判断 key1 是否等于 key2, 相等返回 1, 否则返回 0 */
    int (*match)(const void *key1, const void *key2);
}Set;

/* 初始化 */
void set_init(Set *set, int (*match)(const void *key1, const void *key2),
    void (*destroy)(void *data));
/* 销毁 */
void set_destroy(Set *set);
/* 插入结点 */
int set_insert(Set *set, const void *data);
/* 删除结点 */
int set_remove(Set *set, void **data);
/* 求并集 */
int set_union(Set *setu, const Set *set1, const Set *set2);
/* 求交集 */
int set_intersection(Set *seti, const Set *set1, const Set *set2);
/* 求差集 */
int set_difference(Set *setd, const Set *set1, const Set *set2);
/* 判断是否是集合成员 */
int set_is_member(const Set *set, const void *data);
/* 判断是否是了集 */
int set_is_subset(const Set *set1, const Set *set2);
/* 判断集合是否相等 */
int set_is_equal(const Set *set1, const Set *set2);
/* 返回集合大小 */
#define set_size(set) ((set)-&amp;gt;size)

#endif&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;集合抽象数据类型的实现&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* set.c */
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include "set.h"

/* 初始化 */
void set_init(Set *set, int (*match)(const void *key1, const void *key2),
    void (*destroy)(void *data));
{
    set.size = 0;
    set.head = NULL;
    set.tail = NULL;
    set.match = match;
    set.destroy = destroy;
}

/* 销毁 */
void set_destroy(Set *set)
{
    void *data;
    while (set-&amp;gt;size &amp;gt; 0) {
        data = set-&amp;gt;head-&amp;gt;data;
        if (set_remove(set, (void **)&amp;amp;data) == 0 &amp;amp;&amp;amp; set-&amp;gt;destroy != NULL) {
            set-&amp;gt;destroy(data);
        }
    }
    memset(set, 0, sizeof(Set));
}

/* 插入集合 */
int set_insert(Set *set, const void *data)
{
    /* 重复数据 */
    if (set_is_member(set, data)) {
        return 1;
    }

    return _insert_into_set(set, data);
}

/* 删除元素 */
int set_remove(Set *set, void **data)
{
    SetElmt *member = set-&amp;gt;head, 
        /* 用以检测 set-&amp;gt;head 就是所查找的结点 */
        *prev = NUll;

    while (member != NULL) {
        if (set-&amp;gt;match(member-&amp;gt;data, *data)) {
            break;
        }
        prev = member;
        member = member-&amp;gt;next;
    }
    if (member == NULL) {
        return -1;
    }

    if (prev == NULL) {
        /* 头结点是查找的结点 */
        list-&amp;gt;head = member-&amp;gt;next;
    } else {
        prev-&amp;gt;next = member-&amp;gt;next;
    }

    list-&amp;gt;tail = prev;
    *data = (void *)member-&amp;gt;data;
    free(member);
    set-&amp;gt;size--;
    return 0;
}

/* 并集 */
int set_union(Set *setu, const Set *set1, const Set *set2)
{
    SetElmt *member;

    /* set-&amp;gt;destroy 设为 NULL, 避免失败将还有引用的 data 破坏 */
    set_init(setu, set1-&amp;gt;match, NULL);
    for (member = set1-&amp;gt;head; member != NULL; member = member-&amp;gt;next) {
        /* 复制 set1 到 setu 中, data 的指向是同一个地址 */
        if (_insert_into_set(setu, member-&amp;gt;data) != 0) {
            set_destroy(setu);
            return -1;
        }
    }

    for (member = set2-&amp;gt;head, member != NULL; member = member-&amp;gt;next) {
        if (set_insert(setu, member-&amp;gt;data) == -1 ) {
            set_destroy(setu);
            return -1;
        }
    }
    return 0;
}

/* 交集 */
int set_intersection(Set *seti, const Set *set1, const Set *set2)
{
    SetElmt *member;

    set_init(seti, set-&amp;gt;match, NULL)
    for (member = set1-&amp;gt;head; member != NULL; member = member-&amp;gt;next) {
        if (set_is_member(set2, member-&amp;gt;data)) {
            if (_insert_into_set(seti, member-&amp;gt;data) != 0) {
                set_destroy(seti);
                return -1;
            }
        }
    }
    return 0;
}

/* 差集 set1 - set2*/
int set_difference(Set *setd, const Set *set1, const Set *set2)
{
    SetElmt *member;

    set_init(setd, set1-&amp;gt;match, NULL);
    for (member = set1-&amp;gt;head; member != NULL; member = member-&amp;gt;next) {
        if (!set_is_member(set2, member-&amp;gt;data)) {
            if (_insert_into_set(setd, member-&amp;gt;data) != 0) {
                set_destroy(setd);
                return -1;
            }
        }
    }
    return 0;
}

/* 检查是否是集合元素 */
int set_is_member(const Set *set, const void *data)
{
    SetElmt *member;
    for (member = set-&amp;gt;head; member != NULL; member = member-&amp;gt;next) {
        if (set-&amp;gt;match(member-&amp;gt;data, data)) {
            return 1;
        }
    }
    return 0;
}

/* set1 是否是 set2 的子集*/
int set_is_subset(const Set *set1, const Set *set2)
{
    SetElmt *member;
    if (set1-&amp;gt;size &amp;gt; set2-&amp;gt;size) {
        return 0;
    }
    for (member = set1-&amp;gt;head; member != NULL; member = member-&amp;gt;next) {
        if (!set_is_member(set2, member-&amp;gt;data)) {
            return 0;
        }
    }
    return 1;
}

/* 集合相等 */
int set_is_equal(const Set *set1, const Set *set2)
{
    SetElmt *member;
    if (set1-&amp;gt;size != set2-&amp;gt;size) {
        return 0;
    }
    return set_is_subset(set1, set2);
}

/* 不检查重复的集合元素, 不要直接在集合外直接调用 */
int _insert_into_set(Set *set, const void *data)
{
    SetElmt *element;

    if ((element = (SetElmt *)malloc(sizeof(SetElmt))) == NULL) {
        return -1;
    }
    element-&amp;gt;data = (void *)data;
    if (set-&amp;gt;size == 0) {
        /* 空集 */
        set-&amp;gt;head = element;
    } else {
        set-&amp;gt;tail-&amp;gt;next = element;
    }
    set-&amp;gt;tail = element;
    element-&amp;gt;next = NULL;
    set-&amp;gt;size++;
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;集合覆盖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个集合 S, 集合 P 由集合 S 的子集 A&lt;sub&gt;1&lt;/sub&gt; 到 A&lt;sub&gt;n&lt;/sub&gt; 组成, 集合 C 由集合 P 中的一个或多个子集组成.
如果 S 中的每个成员都包含在 C 的至少一个子集中, 则称集合 C 覆盖集合 S
C 包含的 P 的子集应该越少越好&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以下程序使用一种贪心法算法, 每一次都尝试尽可能的覆盖到更多的成员, 得到不一定是最优解&lt;/br&gt;
给定一个集合, 代表有 12 各技能: S = {a, b, c, d, e, f, g, h, i, j, k, l}&lt;/br&gt;
然后一共有 7 名选手 P = {A&lt;sub&gt;1&lt;/sub&gt;, A&lt;sub&gt;2&lt;/sub&gt;, …, A&lt;sub&gt;7&lt;/sub&gt;}&lt;/br&gt;
每一位选手都有不同的技能: &lt;/br&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A&lt;sub&gt;1&lt;/sub&gt; = {a, b, c, d}&lt;/br&gt;
A&lt;sub&gt;2&lt;/sub&gt; = {e, f, g, h, i}&lt;/br&gt;
A&lt;sub&gt;3&lt;/sub&gt; = {j, k, l}&lt;/br&gt;
A&lt;sub&gt;4&lt;/sub&gt; = {a, e}&lt;/br&gt;
A&lt;sub&gt;5&lt;/sub&gt; = {b, f, g}&lt;/br&gt;
A&lt;sub&gt;6&lt;/sub&gt; = {c, d, g, h, k, l}&lt;/br&gt;
A&lt;sub&gt;7&lt;/sub&gt; = {l}&lt;/br&gt;
最优解的集合覆盖是 C = {A&lt;sub&gt;1&lt;/sub&gt; , A&lt;sub&gt;2&lt;/sub&gt; , A&lt;sub&gt;3&lt;/sub&gt;}&lt;/br&gt;
不过我们的程序给出了的是 C = {A&lt;sub&gt;6&lt;/sub&gt;, A&lt;sub&gt;2&lt;/sub&gt;, A&lt;sub&gt;1&lt;/sub&gt;, A&lt;sub&gt;3&lt;/sub&gt;}&lt;/br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="集合覆盖" src="../../assets/images/集合覆盖.png" /&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;#include &amp;lt;stdlib.h&amp;gt;
#include "set.h"

/* 集合 P 元素结点结构 */
typedef struct KSet_ {
    void *key;
    Set set;
}KSet;

/* 函数在集合 P 的子集 A&amp;lt;sub&amp;gt;1&amp;lt;/sub&amp;gt;~A&amp;lt;sub&amp;gt;n&amp;lt;/sub&amp;gt; 中挑选出能够覆盖集合 S 的近似最优解 
 * @param members: 待覆盖的集合 S
 * @param subsets: 集合 P 中的子集
 * @param covering: 作为返回的覆盖集合 C
 *
 * 函数首先初始化 covering, 只要 members 中的还有未覆盖的成员, 且 subsets 中的
 * 子集还没有挑选完, 就继续迭代最外层循环
 * 在循环中,每次迭代时都在 subsets 中找出能够覆盖到 members 的最大交集
 * 然后将这个集合加到覆盖集 covering 中并把它的成员从 members 中移除
 */
int cover(Set *members, Set *subsets, Set *covering)
{
    Set intersection;
    KSet *subset;
    SetElmt *member, *max_member;

    void *data;
    int max_size;
    /* 初始化 covering */
    set_init(covering, subsets-&amp;gt;match, NULL);

    while (set_size(members) &amp;gt; 0 &amp;amp;&amp;amp; set_size(subsets) &amp;gt; 0) {
        /* Find the subset that covers the most members */
        max_size = 0;
        /* 循环集合 P 中的元素 */
        for (member = subsets-&amp;gt;head; member != NULL; member = member-&amp;gt;next) {
            /* 求 P 中元素结点和 S 的交集, 如果 P 中有结点中的元素完全不属于 S, 返回错误 */
            if (set_intersection(&amp;amp;intersection, &amp;amp;((KSet *)member-&amp;gt;data)-&amp;gt;set,
                members) != 0) {
                return -1;
            }
            /* 贪心法, 只保留最大能产生最多交集元素的结点 */
            if (set_size(&amp;amp;intersection) &amp;gt; max_size) {
                max_member = member;
                max_size = set_size(&amp;amp;intersection);
            }
            /* 重置中间集合, 以便循环使用 */
            set_destroy(&amp;amp;intersection);
        }
        /* 检查查找到子集, 若没有匹配到 P 和 S 任何交集, 返回失败. 因为空集是任何集合的子集 */
        if (max_size == 0) {
            return 1;
        }
        /* 将查找到的 P 中的结点加入集合 C 中 */
        subset = (KSet *)max_member-&amp;gt;data;
        if (set_insert(covering, subset) != 0) {
            return -1;
        }
        /* 将查找到的 P 集合中的结点里的属于集合 S 中的数据从 集合 S 中删除掉 */
        for (member = (&amp;amp;subset-&amp;gt;set)-&amp;gt;data;
            member != NULL; member = member-&amp;gt;next) {
            data = member-&amp;gt;data;
            if (set_remove(members, (void **)&amp;amp;data) == 0 &amp;amp;&amp;amp; 
                members-&amp;gt;destroy !== NULL ) {
                members-&amp;gt;destroy(data);
            }
        }
        /* 将该次选中的 P 集合中的结点从集合 P 中删除. */
        if (set_remove(subsets, (void **)&amp;amp;subset) != 0) {
            return -1;
        }
    }
    /* 在查找完 P 集合中所有结点, 依然没有覆盖完 S 的所有元素时, 返回失败 */
    if (set_size(members) &amp;gt; 0) {
        return -1;
    }
    return 0;
}&lt;/code&gt;&lt;/pre&gt;</content><category term="算法"></category><category term="C"></category><category term="集合"></category><category term="数据结构"></category></entry><entry><title>Matering Algorithms with C-2: 栈和队列</title><link href="https://ivicel.info/2017/03/matering-algorithms-with-c-2-zhan-he-dui-lie.html" rel="alternate"></link><published>2017-03-22T00:00:00+08:00</published><updated>2017-03-22T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2017-03-22:/2017/03/matering-algorithms-with-c-2-zhan-he-dui-lie.html</id><summary type="html">&lt;p&gt;栈: 后进先出(LIFO)&lt;/p&gt;
&lt;p&gt;队列: 先进先出(FIFO)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈和队列的一些应用&lt;ol&gt;
&lt;li&gt;信号量: 同步多个进程访问共享资源&lt;/li&gt;
&lt;li&gt;事件处理&lt;/li&gt;
&lt;li&gt;X Window 系统, 使用队列来存储事件&lt;/li&gt;
&lt;li&gt;生产者-消费者问题, 生产者向队列中写入数据, 消费从队列中读出数据&lt;/li&gt;
&lt;li&gt;C 函数的调用, 函数的调用会将一些信息压入程序栈, 程序结束时将信息出栈&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;栈最常用的是使用链表来实现, 以下是栈的抽象数据类型头文件&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* stack.h */
#ifndef STACK_H
#define STACK_H

/* 元素结点 */
typedef struct StackElmt_ {
    void *data;
    struct StackElmt_ *next;
}StackElmt;

/* 栈结构 */
typedef struct Stack_ {
    /* 栈大小 */
    int size;
    /* 指向栈顶结点 */
    StackElmt *top;
    void …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;p&gt;栈: 后进先出(LIFO)&lt;/p&gt;
&lt;p&gt;队列: 先进先出(FIFO)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈和队列的一些应用&lt;ol&gt;
&lt;li&gt;信号量: 同步多个进程访问共享资源&lt;/li&gt;
&lt;li&gt;事件处理&lt;/li&gt;
&lt;li&gt;X Window 系统, 使用队列来存储事件&lt;/li&gt;
&lt;li&gt;生产者-消费者问题, 生产者向队列中写入数据, 消费从队列中读出数据&lt;/li&gt;
&lt;li&gt;C 函数的调用, 函数的调用会将一些信息压入程序栈, 程序结束时将信息出栈&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;栈最常用的是使用链表来实现, 以下是栈的抽象数据类型头文件&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* stack.h */
#ifndef STACK_H
#define STACK_H

/* 元素结点 */
typedef struct StackElmt_ {
    void *data;
    struct StackElmt_ *next;
}StackElmt;

/* 栈结构 */
typedef struct Stack_ {
    /* 栈大小 */
    int size;
    /* 指向栈顶结点 */
    StackElmt *top;
    void (*destroy)(void *data);
    void (*match)(const void *key1, const void *key2);
}Stack;

/* 初始化 */
void stack_init(Stack *stack, void (*destroy)(void *data));
/* 销毁 */
void stack_destroy(Stack *stack);
/* 插入结点 */
int stack_push(Stack *stack, const void *data);
/* 弹出结点 */
int stack_pop(Stack *stack, void **data);
/* 空栈返回 NULL, 非空栈返回头指针指向数据 */
#define stack_peek(stack) ((stack)-&amp;gt;top == NULL ? NULL : (stack)-&amp;gt;top-&amp;gt;data)
/* 返回栈大小 */
#define stack_size(stack) ((stack)-&amp;gt;size)

#endif&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;栈的实现&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* stack.c */
#include &amp;lt;stdlib.h&amp;gt;
#include "stack.h"

/* 初始化 */
void stack_init(Stack *stack, void (*destroy)(void *data))
{
    stack.size = 0;
    stack.destroy = destroy;
    stack.top = NULL;
}

/* 销毁 */
void stack_destroy(Stack *stack)
{
    void *data;

    while (stack-&amp;gt;size &amp;gt; 0) {
        if (stack_pop(stack, (void **)&amp;amp;data) == 0 &amp;amp;&amp;amp; stack-&amp;gt;destroy != NULL) {
            stack-&amp;gt;destroy(data);
        }
    }
    memset(stack, 0, sizeof(Stack));
}

/* 弹出结点 */
int stack_pop(Stack *stack, void **data)
{
    StackElmt *element;

    if (stack-&amp;gt;size == 0) {
        return -1;
    }
    element = stack-&amp;gt;top;
    stack-&amp;gt;top = element-&amp;gt;next;
    free(element);
    stack-&amp;gt;size--;
    return 0;
}

/* 压入结点 */
int stack_push(Stack *stack, const void *data)
{
    StackElmt *element;
    if ((element = (StackElmt *)malloc(sizeof(StackElmt))) == NULL) {
        return -1;
    }
    element-&amp;gt;data = data;
    element-&amp;gt;next = stack-&amp;gt;top;
    stack-&amp;gt;top = element;
    stack-&amp;gt;size++;
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;队列其实就是一个链表结构, 但只提供了先进先出的接口
队列头文件定义&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* queue.h */
#ifndef QUEUE_H
#define QUEUE_H

/* 元素结点 */
typedef struct QueueElmt_ {
    void *data;
    struct QueueElmt_ *next;
}QueueElmt;

/* 队列结构 */
typedef struct Queue_ {
    /* 队列大小 */
    int size;
    /* 指向队列头结点 */
    QueueElmt *head;
    /* 队列尾结点 */
    QueueElmt *tail;
    void (*destroy)(void *data);
    void (*match)(const void *key1, const void *key2);
}Queue;

/* 初始化 */
void queue_init(Queue *queue, void (*destroy)(void *data));
/* 销毁 */
void queue_destroy(Queue *queue);
/* 插入结点 */
int queue_enqueue(Queue *queue, const void *data);
/* 弹出结点 */
int queue_dequeue(Queue *queue, void **data);
/* 空栈返回 NULL, 非空栈返回头指针指向数据 */
#define queue_peek(queue) ((queue)-&amp;gt;head == NULL ? NULL : (queue)-&amp;gt;top-&amp;gt;data)
/* 返回栈大小 */
#define queue_size(queue) ((queue)-&amp;gt;size)


#endif&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;队列抽象数据类型的实现&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* queue.h */
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include "queue.h"

/* 初始化 */
void queue_init(Stack *queue, void (*destroy)(void *data))
{
    queue.size = 0;
    queue.destroy = destroy;
    queue.head = NULL;
    queue.tail = NULL;
}

/* 销毁 */
void queue_destroy(Stack *queue)
{
    void *data;

    while (queue-&amp;gt;size &amp;gt; 0) {
        if (queue_dequeue(queue, (void **)&amp;amp;data) == 0 &amp;amp;&amp;amp; queue-&amp;gt;destroy != NULL) {
            queue-&amp;gt;destroy(data);
        }
    }
    memset(queue, 0, sizeof(Queue));
}

/* 入队 */
int queue_enqueue(Queue *queue, const void *data)
{
    QueueElmt *element;
    if ((element = (QueueElmt *)malloc(sizeof(QueueElmt))) == NULL) {
        return -1;
    }
    element-&amp;gt;data = (void *)data;
    if (queue-&amp;gt;size == 0) {
        /* 空队列 */
        queue-&amp;gt;head = element;
    } else {
        queue-&amp;gt;tail-&amp;gt;next = element;
    }
    queue-&amp;gt;tail = element;
    element-&amp;gt;next = NULL;
    queue-&amp;gt;size++;
    return 0;

}

/* 出队 */
int queue_dequeue(Queue *queue, void **data)
{
    QueueElmt *element;
    if (queue-&amp;gt;size == 0) {
        return -1;
    }
    element = queue-&amp;gt;head;
    data = (void **)&amp;amp;element-&amp;gt;data;
    if (element-&amp;gt;next == NULL) {
        /* 队列中只有一个结点 */
        queue-&amp;gt;head = NULL;
        queue-&amp;gt;tail = NULL;
    } else {
        queue-&amp;gt;head = element-&amp;gt;next;
    }
    free(element);
    queue-&amp;gt;size--;
    return 0;
}&lt;/code&gt;&lt;/pre&gt;</content><category term="算法"></category><category term="C"></category><category term="栈"></category><category term="队列"></category><category term="数据结构"></category></entry><entry><title>javascript</title><link href="https://ivicel.info/2017/03/javascript.html" rel="alternate"></link><published>2017-03-21T00:00:00+08:00</published><updated>2017-03-21T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2017-03-21:/2017/03/javascript.html</id><summary type="html">&lt;h4&gt;对象属性特征&lt;/h4&gt;
&lt;p&gt;1.数据属性
&lt;code&gt;[[Configurable]]&lt;/code&gt; 能否通过 &lt;code&gt;delete&lt;/code&gt; 删除属性从而重新定义属性，能否修改属性，或者能否把属性修改为访问器属性
&lt;code&gt;[[Enumerable]]&lt;/code&gt; 能否通过 &lt;code&gt;for-in&lt;/code&gt; 循环返回属性
&lt;code&gt;[[Writable]]&lt;/code&gt; 能否修改属性的值
&lt;code&gt;[[Value]]&lt;/code&gt; 属性的数据值&lt;/p&gt;
&lt;p&gt;2.访问器属性
&lt;code&gt;[[Configurable]]&lt;/code&gt; 能否通过 &lt;code&gt;delete&lt;/code&gt; 删除属性从而重新定义属性，能否修改属性，或者能否把属性修改为数据属性
&lt;code&gt;[[Enumerable]]&lt;/code&gt; 能否通过 &lt;code&gt;for-in&lt;/code&gt; 循环返回属性
&lt;code&gt;[[Get]]&lt;/code&gt; 在读取属性时调用的函数
&lt;code&gt;[[Set]]&lt;/code&gt; 在写入属性时调用的函数&lt;/p&gt;
&lt;h4&gt;对象属性查找&lt;/h4&gt;
&lt;p&gt;每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。&lt;/p&gt;
&lt;p&gt;搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返
回该属性的值；&lt;/p&gt;
&lt;p&gt;如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;判断属性是否为对象本身属性或是在原型链中&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;hasOwnProperty()&lt;/code&gt; 方法断访问是属性是否是在实例中&lt;/p&gt;
&lt;p&gt;&lt;code&gt;in&lt;/code&gt; 操作符会在通过对象能够访问给富属性时返回 &lt;code&gt;true …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;h4&gt;对象属性特征&lt;/h4&gt;
&lt;p&gt;1.数据属性
&lt;code&gt;[[Configurable]]&lt;/code&gt; 能否通过 &lt;code&gt;delete&lt;/code&gt; 删除属性从而重新定义属性，能否修改属性，或者能否把属性修改为访问器属性
&lt;code&gt;[[Enumerable]]&lt;/code&gt; 能否通过 &lt;code&gt;for-in&lt;/code&gt; 循环返回属性
&lt;code&gt;[[Writable]]&lt;/code&gt; 能否修改属性的值
&lt;code&gt;[[Value]]&lt;/code&gt; 属性的数据值&lt;/p&gt;
&lt;p&gt;2.访问器属性
&lt;code&gt;[[Configurable]]&lt;/code&gt; 能否通过 &lt;code&gt;delete&lt;/code&gt; 删除属性从而重新定义属性，能否修改属性，或者能否把属性修改为数据属性
&lt;code&gt;[[Enumerable]]&lt;/code&gt; 能否通过 &lt;code&gt;for-in&lt;/code&gt; 循环返回属性
&lt;code&gt;[[Get]]&lt;/code&gt; 在读取属性时调用的函数
&lt;code&gt;[[Set]]&lt;/code&gt; 在写入属性时调用的函数&lt;/p&gt;
&lt;h4&gt;对象属性查找&lt;/h4&gt;
&lt;p&gt;每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。&lt;/p&gt;
&lt;p&gt;搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返
回该属性的值；&lt;/p&gt;
&lt;p&gt;如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;判断属性是否为对象本身属性或是在原型链中&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;hasOwnProperty()&lt;/code&gt; 方法断访问是属性是否是在实例中&lt;/p&gt;
&lt;p&gt;&lt;code&gt;in&lt;/code&gt; 操作符会在通过对象能够访问给富属性时返回 &lt;code&gt;true&lt;/code&gt;，无论该属性存在于实例中还是原型中。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;函数原型&lt;/h4&gt;
&lt;p&gt;只要创建一个函数，就会根据一组特定的规则为该函数创建一个 &lt;code&gt;prototype&lt;/code&gt; 属性，该属性指向函数的原型对象&lt;/p&gt;
&lt;p&gt;默认的情况下，所有的原型对象都会自动获得一个 &lt;code&gt;constructor&lt;/code&gt; (构造函数) 属性，这个属性包含一个指向 &lt;code&gt;prototype&lt;/code&gt; 属性所在函数的指针&lt;/p&gt;
&lt;p&gt;当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向函数的原型对象。ECMAScript 5把这个指针叫做 &lt;code&gt;[[prototype]]&lt;/code&gt; ，通过&lt;code&gt;Object.getPrototypeOf()&lt;/code&gt; 访问到这个指针，或是使用非标准属性 &lt;code&gt;__proto__&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="函数原型" src="../../assets/images/函数原型.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;原型语法&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;写法一&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-javascript"&gt;function Person() {
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function() {
    console.log(this.name);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;写法二&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-javascript"&gt;function Person() {
}
Person.prototype = {
    name: "Nicholas",
    age: 29,
    job: "Software Engineer",
    sayName: function() {
        console.log(this.name);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;写法二&lt;/strong&gt;相当把 &lt;code&gt;Person.prototype&lt;/code&gt; 重新指向新的对象&lt;/p&gt;
&lt;h4&gt;1. 工厂模式&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-javascript"&gt;function createPerson(name, age, job) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function() {
﻿        console.log(this.name);
    };
    return o;
}

var person1 = createPerson("Nicholas", 29, "Software Egineer");
var person2 = createPerson("Greg", 27, "Doctor");&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2.构造函数模式&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-javascript"&gt;    fucntion Person(name, age, job) {
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = function() {
            console.log(this.name);
        };
        // 等价 this.sayName = new Function("console.log(this.name)");
    }
    var person1 = new Person("Nicholas", 29, "Software Egineer");
    var person2 = new Person("Greg", 27, "Doctor");

    console.log(person1.sayName == person2.sayName); //false, 说明在两个对象中，sayName是不同的对象&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;3.原型模式&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-javascript"&gt;function Person() {
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function() {
    console.log(this.name);
};
    var person1 = new Person();
    person1.sayName();  //"Nicholas"

    var person2 = new Person();
    person2.sayName();  //"Nicholas"
    console.log(person1.sayName == person2.sayName); //true, 说明在两个对象中，sayName是相同的对象&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;4.组合使用构造函数模式和原型模式&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-javascript"&gt;function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.friend = ["Shelby", "Court"];
}

Person.prototype = {
    constructor: Person;
    sayName: function() {
        console.log(this.name);
    };
};

var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");

person1.friend.push("Van");
console.log(person1.friends);   //"Shelby, Count, Van"
console.log(person2.friends);       //"Shelby, Count"
console.log(person1.friends === person2.friends);   //false
console.log(person2.sayName === person2.sayName);   //true&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;5.动态原型模式&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-javascript"&gt;function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;

    if (typeof this.sayName != "function") {
        Person.prototype.sayName = function() {
            console.log(this.name);
        };
    }
}

var friend = new Person("Nicholas", 29, "Software Engineer");
friend.sayName();&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;6.寄生构造函数模式&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-javascript"&gt;function Person(name, age, job) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function() {
        console.log(this.name);
    };
    return o;
}

var friend = new Person("Nicholas", 29, "Software Engineer");
friend.sayName();       //"Nicholas"

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;构造函数在不返回值的情况下，默认会返回新对象实例&lt;br /&gt;
而通过在构造函数的末尾添加一个 &lt;code&gt;return&lt;/code&gt; 语句，可以重写调用构造函数时返回的值。&lt;br /&gt;
这种模式可以在行列的情况下用来为对象创建构造函数。&lt;br /&gt;
假如想创建一个具有额外方法的特殊数组，由于不能直接修改 &lt;code&gt;Array&lt;/code&gt; 构造函数，可以使用这种模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-javascript"&gt;function SpecialArray() {
    //创建数组
    var values = new Array();
    //添加值
    values.push.apply(values, arguments);
    //添加方法
    values.toPipedString = function() {
        return this.join("|");
    };
    //返回数组
    return values;
}

var colors = new SpecialArray("red", "blue", "green");
console.log(colors.toPipedString()); //"red|blue|green"&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;7.稳妥构造函数模式&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-javascript"&gt;function Person(name, age, job) {
    var o = new Object();

    o.sayName = function() {
        console.log(name);
    };
    return o;
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;原型链&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-javascript"&gt;function SuperType() {
    this.property = true;
    //something else
}
SuperType.prototype.getSuperValue = function() {
    //some codes
    return this.property;
};

function SubType() {
    //something
    this.subproperty = false;
}
//继承了 SuperType
SubType.prototype = new SuperType();
SubType.prototype.getSubValue = function() {
    return this.subproperty;
};
//other codes
var instance = new SubType();
console.log(instance.getSuperValue());      //true&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt="函数继承原型链" src="../../assets/images/函数继承原型链.png" /&gt;&lt;/p&gt;
&lt;h4&gt;原型链继承的问题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;创建子类型时，原先的超类型实例属性变成了子类的原型属性&lt;/li&gt;
&lt;li&gt;创建子类型时，没有办法在不影响所有对象实例的情况下给超类型的构造函数传递对数&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;继承方法&lt;/h4&gt;
&lt;h5&gt;1. 借用构造函数（伪造对象、经典继承）&lt;/h5&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-javascript"&gt;function SuperType(newColor) {
    this.color = ["red", "blue", "green"];
}

function SubType() {
    //继承了 SuperType
    SuperType.call(this, "yellow")
}

var instance1 = new SubType();
instance1.colors.push("black");
console.log(instance1.colors);  //"red,blue,green,yellow,black"

var isntance1 = new SubType();
console.log(instance2.colors);  //"red,blue,green,yellow"&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;2. 组合继承（伪经典继承）&lt;/h5&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-javascript"&gt;function SuperType(name) {
    this.name = name;
    this.colors = ["red", "blue", "green"];
}

SuperType.prototype.sayName = function() {
    console.log(this.name);
};

function SubType(name, age) {
    //继承属性
    SuperType.call(this, name);
    this.age = age;
}

//继承方法
SubType.prototype = new SuperType();
SubType.prototype.sayAge = function() {
    console.log(this.age);
};

var instance1 = new SubType("Nicholas", 29);
instance1.colors1.push("black");
console.log(instance1.colors);      //"red,blue,green,black"
instance1.sayName();    //"Nicholas"
instance.sayAge();      //29

var instance2 = new SubType("Greg", 27);
console.log(instance2.colors);  //"red,blue,green"
instance2.sayName();    //"Greg"
instance2.sayAge();     //27&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;3. 原型式继承&lt;/h5&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-javascript"&gt;function object(o) {
    function F() {}
    F.prototype = o;
    return new F();
}

var person = {
    name: "Nicholas",
    friends: [
        "Shelby",
        "Court",
        "Van"
    ]
};

var anotherPerson = object(person);
anotherPerson.name = "Greg";
anotherPerson.friends.push("Rob");

var yetAnotherPerson = object(person);
yetAnotherPerson.name = "Linda";
yetAnotherPerson.friends.push("Barbie");
console.log(person.friends);  //"Shelby,Court,Van,Rob,Barbie"&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;使用 &lt;code&gt;Object.create()&lt;/code&gt; 原型式继承。该函数接受两个参数：一个用作新对象原型的对象和一个（可选的）新对象定义额外属性的对象，覆盖原型卦象上的同名属性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用一个参数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-javascript"&gt;var person = {
    name: "Nicholas",
    friends: [
        "Shelby",
        "Court",
        "Van"
    ]
};

var anotherPerson = Object.create(person);
anotherPerson.name = "Greg";
anotherPerson.friends.push("Rob");

var yetAnotherPerson = Object.create(person);
yetAnotherPerson.name = "Linda";
yetAnotherPerson.friends.push("Barbie");
console.log(person.friends);  //"Shelby,Court,Van,Rob,Barbie"&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用两个参数，参数传入方式与 &lt;code&gt;Object.definePrototies()&lt;/code&gt; 相同&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-javascript"&gt;var person = {
    name: "Nicholas",
    friends: [
        "Shelby",
        "Court",
        "Van"
    ]
};

var anotherPerson = Object.create(person, {
    name: {
        value: "Greg"
    }
});
console.log(anotherPerson.name);  //"Greg"&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;4. 寄生式继承&lt;/h5&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-javascript"&gt;function createAnother(original) {
    //通过调用函数创建一个新对象
    var clone = Object.create(original);
    //以某种方式来增强这个对象
    clone.sayHi = function() {
        console.log("hi");
    };
    //返回该对象
    return clone;
}

var person = {
    name: "Nicholas",
    friends: [
        "Shelby",
        "Court",
        "Van"
    ]
};

var anotherPerson = createAnother(person);
anotherPerson.sayHi();  //"hi"
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;5. 寄生组合式继承&lt;/h5&gt;
&lt;p&gt;&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-javascript"&gt;function inheritPrototype(subType, superType) {
    //创建对象
    var prototype = Object.create(superType.prototype);
    //增强对象
    prototype.constructor = subType;
    //指定对象
    subType.prototype = prototype;
}

function SuperType(name) {
    this.name = name;
    this.colors = ["red", "blue", "green"];
}

SuperType.prototype.sayName = function() {
    console.log(this.name);
};

function SubType(name, age) {
    SuperType.call(this, name);
    this.age = age;
}

inheritPrototype(SubType, SuperType);
SubType.prototype.sayAge = function() {
    console.log(this.age);
};

var instance = new SubType("Nicholas", 29);&lt;/code&gt;&lt;/pre&gt;
&lt;img alt="寄生组合式继承" src="../../assets/images/寄生组合式继承.png" /&gt;&lt;/p&gt;</content></entry><entry><title>Mastering Algorithms with C-1: 链表</title><link href="https://ivicel.info/2017/03/mastering-algorithms-with-c-1-lian-biao.html" rel="alternate"></link><published>2017-03-21T00:00:00+08:00</published><updated>2017-03-21T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2017-03-21:/2017/03/mastering-algorithms-with-c-1-lian-biao.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;函数的实现在判断元素结点是否为头结点或尾结点时, 并未使用 &lt;code&gt;list-&amp;gt;head&lt;/code&gt; &lt;code&gt;list-&amp;gt;tail&lt;/code&gt; 指针&lt;br&gt;
而是判断该结点是否存在前一结点&lt;code&gt;element-&amp;gt;prev&lt;/code&gt;或后一结点&lt;code&gt;element-&amp;gt;next&lt;/code&gt;是否为空&lt;br&gt;
这样从而导致在向指定结点前面或后面插入元素时, 不能过早将&lt;code&gt;element-prev&lt;/code&gt; &lt;code&gt;element-&amp;gt;next&lt;/code&gt; 指向新结点&lt;code&gt;new_element&lt;/code&gt; 以避免判断头尾结点失败&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;strong&gt;单链表&lt;/strong&gt;(Linked List)&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* list.h */

#ifndef LIST_H
#define LIST_H

#include &amp;lt;stdlib.h&amp;gt;
/* 链表元素结构 */
typedef struct ListElmt_ {
    /* 指向实际数据地址 */
    void *data;    
    /* 指向下一个结点元素的指针 */
    struct ListElmt_ *next;         
}ListElmt;

/* 链表的结构定义 */
typedef struct List_ …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;函数的实现在判断元素结点是否为头结点或尾结点时, 并未使用 &lt;code&gt;list-&amp;gt;head&lt;/code&gt; &lt;code&gt;list-&amp;gt;tail&lt;/code&gt; 指针&lt;br&gt;
而是判断该结点是否存在前一结点&lt;code&gt;element-&amp;gt;prev&lt;/code&gt;或后一结点&lt;code&gt;element-&amp;gt;next&lt;/code&gt;是否为空&lt;br&gt;
这样从而导致在向指定结点前面或后面插入元素时, 不能过早将&lt;code&gt;element-prev&lt;/code&gt; &lt;code&gt;element-&amp;gt;next&lt;/code&gt; 指向新结点&lt;code&gt;new_element&lt;/code&gt; 以避免判断头尾结点失败&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;strong&gt;单链表&lt;/strong&gt;(Linked List)&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* list.h */

#ifndef LIST_H
#define LIST_H

#include &amp;lt;stdlib.h&amp;gt;
/* 链表元素结构 */
typedef struct ListElmt_ {
    /* 指向实际数据地址 */
    void *data;    
    /* 指向下一个结点元素的指针 */
    struct ListElmt_ *next;         
}ListElmt;

/* 链表的结构定义 */
typedef struct List_ {
    /* 链表中元素的个数 */
    int size;
    /* 该函数由从链表结构派生而来的新类型使用 */
    int (*match)(const void *key1, const void *key2);
    /* 销毁链表时调用的析构函数 */
    void (*destroy)(void *data);
    /* 头结点 */
    ListElmt *head;
    /* 末尾结点 */
    ListElmt *tail;
}List;

/* 初始化 list 指定的链表，提供一个函数 destroy 以便在调用 list_destory 来销毁链表时做些必要的工作，如释放数据内存等 */
void list_init(List *list, void (*destory)(void *data));

/* 销毁链表 */
void list_destroy(List *list);

/* 单链表由于不清楚某一结点的前一结点，所以插入和删除只能操作该结点后的元素 */
/* 在element后插入一个元素，如果element为NULL，则在链表头头插入。成功返回0，失败返回-1 */
int list_ins_next(List *list, ListElmt *element, const void *data);

/* 移除element后的那个元素，如果element为NULL，则移除链表头元素。
调用返回后，data指向已移除元素中存储的数据。成功0，失败-1 */
int list_rem_next(List *list, ListElmt *element, void **data);

/* 返回元素个数 */
#define list_size(list) ((list)-&amp;gt;size)

/* 返回链表头元素指针 */
#define list_head(list) ((list)-&amp;gt;head)

/* 判断是否是头结点，是返回1，否则返回0 */
#define list_is_head(list, element) ((element) == (list)-&amp;gt;head ? 1 : 0)

/* 判断链表末尾结点，是返回1，否则返回0 */
#define list_is_tail(element) ((element)-&amp;gt;next == NULL ? 1 : 0)

/* 返回结点中保存的数据 */
#define list_data(element) ((element)-&amp;gt;data)

/* 返回element的下一个结点 */
#define list_next(element) ((element)-&amp;gt;next)

#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;元素插入链表&lt;/p&gt;
&lt;p&gt;&lt;img alt="元素插入链表" src="../../assets/images/元素插入链表.png" /&gt;&lt;/p&gt;
&lt;p&gt;函数实现&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#include "list.h"

void list_init(List *list, void (*destroy)(void *data)) 
{
    /* 初始化链表 */
    list-&amp;gt;size = 0;
    list-&amp;gt;destroy = destroy;
    list-&amp;gt;head = NULL;
    list-&amp;gt;tail = NULL;

    return;
}

void list_destroy(List *list)
{
    void *data;
    /* 移除链表中所有元素 */
    while (list_size(list) &amp;gt; 0) {
        if (list_rem_next(list, NULL, (void **)&amp;amp;data) == 0 &amp;amp;&amp;amp; list-&amp;gt;destroy != NULL) {
            /* 当 destroy 不为 NULL 时，对数据调用 */
            list-&amp;gt;destroy(data);
        }
    }
    /* 清空置0链表内存 */
    memset(list, 0, sizeof(list));
    return;
}

int list_ins_next(List *list, ListElmt *element, const void *data)
{
    ListElmt *new_element;
    /* 为新元素申请内存 */
    if ((new_element = (ListElmt *)malloc(sizeof(ListElmt))) == NULL) {
        return -1;
    }
    new_element-&amp;gt;data = (void *)data;
    if (element == NULL) {
        /* 空链表时，新插入元素是末尾元素 */
        if (list_size(list) == 0) {
            list-&amp;gt;tail = new_element;
        }
        new_element-&amp;gt;next = list-&amp;gt;head;
        list-&amp;gt;head = new_element;
    } else {
        /* element 是末尾元素时，新插入元素是末尾元素 */
        if (element-&amp;gt;next == NULL) {
            list-&amp;gt;tail = new_element;
        }
        new_element-&amp;gt;next = element-&amp;gt;next;
        element-&amp;gt;next = new_element;
    }
    /* 链表长度增加1 */
    list-&amp;gt;size++;

    return 0;
}

int list_rem_next(List *list, ListElmt *element, void **data) {
    ListElmt *old_element;

    /* 空链表 */
    if (list-&amp;gt;size == 0) {
        return -1;
    }
    if (element == NULL) {
        old_element = list-&amp;gt;head;
        list-&amp;gt;head = list-&amp;gt;head-&amp;gt;next;
        *data = old_element-&amp;gt;data;

        /* 链表中只有一个元素时，删除后，head 和 tail 均指向 NULL */
        if (list_size(list) == 1) {
            lsit-&amp;gt;tail = NULL
        }
    } else {
        /* element 是末尾结点时，返回 -1 */
        if (element-&amp;gt;next == NULL) {
            return -1;
        }
        old_element = element-&amp;gt;next;
        element-&amp;gt;next = old_element-&amp;gt;next;
        *data = old_element-&amp;gt;data;

        /* element 下一结点为末尾结点时，删除后 element 为末尾结点 */
        if (element-&amp;gt;next == NULL) {
            list-&amp;gt;tail = element;
        }
    }
    /* 更改链表长度 */
    list-&amp;gt;size--;
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;单链表应用：页帧管理(Frame Management)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用链表管理一个页表(page table)，链表大小预设为页表的大小&lt;/li&gt;
&lt;li&gt;假定页表在系统启动的时候已经被初始化，并且页表中的元素数据 &lt;code&gt;frame_number&lt;/code&gt; 已经映射到真正的物理内存&lt;/li&gt;
&lt;li&gt;链表是虚拟内存和物理内存的映射，页表的操作总是在头结点&lt;/li&gt;
&lt;li&gt;当需要申请一个真正的物理内存地址时，总是检查页表的大小，页表大小为 0 时即映射的内存已使用完;&lt;/li&gt;
&lt;li&gt;如果有可用的页表，&lt;code&gt;alloc_frame&lt;/code&gt; 返回其页表号码，并释放其&lt;code&gt;data&lt;/code&gt;指向的内存以便令程序可能使用&lt;/li&gt;
&lt;li&gt;释放页表时，重新为页表元素数据申请一个内存，如果没有可用内存，释放失败&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="页帧映射" src="../../assets/images/页表映射.png" /&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;#include &amp;lt;stdlib.h&amp;gt;
#include "list.h"

/* 申请空闲页帧 */
int alloc_frame(List *frames)
{
    int frame_number, *data;

    if (list_size(frames) == 0) {
        /* 无可用物理内存 */
        return -1;
    } else {
        if (list_rem_next(frames, NULL, (void **)&amp;amp;data) != 0) {
            return -1;
        } else {
            /* 页表号是内存映射地址 */
            frame_number = *data;
            /* 释放该内存以及令程序使用 */
            free(data);
        }
    }
    return frmae_number;
}

int free_frame(List *frames, int frame_number)
{
    int *data;

    /* 重新申请一个内存来作页表的映射，避免程序申请页表时导致
       有空闲的页帧，实际却没有空闲的内存可用 */
    if ((data = (int *)malloc(sizeof(int))) == NULL) {
        return -1;
    }

    *data = frame_number;
    /* 将数据插入链表头结点 */
    if (list_ins_next(frames, NULL, data) != 0) {
        return -1;
    }
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;双向链表&lt;/strong&gt;(Doubly-Linked List)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="双向链表" src="../../assets/images/双向链表.png" /&gt;&lt;/p&gt;
&lt;p&gt;头文件
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* dlist.h */
#ifndef DLIST_H
#define DLIST_H

/* 双向链表元素结构 */
typedef struct DListElmt_ {
    /* 指向存储的数据 */
    void *data;
    /* 指向前一结点 */
    struct DListElmt_ *prev;
    /* 指向后一个结点 */
    struct DListElmt_ *next;
}DListElmt;

/* 双向链表 */
typedef struct DList_ {
    /* 链表大小 */
    int size;
    int (*match)(const void *key1, const void *key2);
    /* 销毁时数据回调函数 */
    void (*destroy)(void *data);
    /* 头结点 */
    DListElmt *head;
    DListElmt *tail;
}DList;

/* 链表初始化 */
void dlist_init(DList *list, void (*destroy)(void *data));
/* 销毁链表 */
void destroy(DList *list);
/* 向element后插入一个结点，element为NULL时表示向空链表插入新结点 */
int dlist_ins_next(DList *list, DListElmt *element, const void *data);
/* 向element前插入一个结点，element为NULL时删除失败 */
inst dlist_ins_prev(DList *list, DListElmt *element, const void *data);
/* 由于有指向前一结点和后一结点的指针，所以双向链表可以直接删除指定结点 */
int dlist_remove(DList *list, DListElmt *element, void **data);
/* 返回链表大小 */
#define dlist_size(list) ((list)-&amp;gt;size)
/* 返回链表头结点 */
#define dlist_head(list) ((list)-&amp;gt;head)
/* 返回链表尾结点 */
#define dlist_tail(list) ((list)-&amp;gt;tail)
/* 判断是否是头结点 */
#define dlist_is_head(element) ((element)-&amp;gt;prev == NULL ? 1 : 0)
/* 判断是否是尾结点 */
#define dlist_is_tail(element) ((element)-&amp;gt;next == NULL ? 1 : 0)
/* 返回结点指向数据 */
#define dlist_data(element) ((element)-&amp;gt;data)
/* 返回结点的前一结点 */
#define dlist_prev(element) ((element)-&amp;gt;prev)
/* 返回结点的后一结点 */
#define dlist_next(element) ((element)-&amp;gt;next)

#endif&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;函数实现&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* dlist.c */
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include "dlist.h"

/* 初始化 */
void dlist_init(DList *list, void (*destroy)(void *data))
{
    list-&amp;gt;size = 0;
    list-&amp;gt;destroy = destroy;
    list-&amp;gt;head = NULL
    list-&amp;gt;tail = NULL

    return;
}

/* 销毁 */
void dlist_destroy(DList *list)
{
    void *data;
    /* 删除所有结点 */
    while (dlist-&amp;gt;size(list) &amp;gt; 0) {
        if (dlist_remove(list, dlist_tail(list), (void **)&amp;amp;data) == 0 &amp;amp;&amp;amp; list-&amp;gt;destroy != NULL) {
            /* 调用数据回调函数 */
            list-&amp;gt;destroy(data);
        }
    }
    memset(list, 0, size(DList));
    return;
}

/* 向后插入一结点 */
int dlist_ins_next(DList *list, DListElmt *element, const void *data)
{
    DListElmt *new_element;
    /* 为避免混淆, NULL 仅用向空链表插入元素 */
    if (element == NULL &amp;amp;&amp;amp; dlist_size(list) != 0) {
        return -1;
    }
    /* 申请结点内存 */
    if ((new_element = (DListElmt *)malloc(sizeof(DListElmt))) == NULL) {
        return -1;
    }
    new_element-&amp;gt;data = (void *)data;

    if (dlist_size(list) == 0) {
        /* 当链表为空时 */
        list-&amp;gt;head = new_element;
        list-&amp;gt;head-&amp;gt;prev = NULL;
        list-&amp;gt;head-&amp;gt;next = NULL;
        list-&amp;gt;tail = new_element;
    } else {
        /* 无论 element 情况如何, new_element 的 prev 和 next 指向不会变
        只会指向 element 和其后一结点 */
        new_element-&amp;gt;next = element-&amp;gt;next;
        new_element-&amp;gt;prev = element;

        if (element-&amp;gt;next == NULL) {
            /* 当链表中只有一个结点时, 新结点是末尾结点 */
            list-&amp;gt;tail = new_element;
        } else {
            element-&amp;gt;next-&amp;gt;prev = new_element;
        }
        element-&amp;gt;next = new_element;
    }
    list-&amp;gt;size++;
    return 0;
}

/* 向结点前插入 */
int dlist_ins_prev(DList *list, DListElmt *element, const void *data)
{
    DListElmt *new_element;
    /* NULL 用作向空链表插入结点 */
    if (element == NULL &amp;amp;&amp;amp; dlist_size(list) != 0) {
        return -1;
    }
    /* 申请结点内存 */
    if ((new_element = (DListElmt *)malloc(sizeof(DListElmt))) == NULL) {
        return -1;
    }
    new_element-&amp;gt;data = data;

    if (dlist_size(list) == 0) {
        /* 空链表 */
        list-&amp;gt;head = new_element;
        list-&amp;gt;head-&amp;gt;prev = NULL;
        list-&amp;gt;head-&amp;gt;next = NULL;
        list-&amp;gt;tail = new_element;
    } else {
        /* 无论 element 情况如何, new_element 的 next 和 prev 指向不会变
        只会指向 element 和其前一结点 */
        new_element-&amp;gt;next = element;
        new_element-&amp;gt;prev = element-&amp;gt;prev;

        if (element-&amp;gt;prev == NULL) {
            /* element 是头结点时, 重新调整头结头指向 */
            list-&amp;gt;head = new_element;
        } else {
            /* 非头结点时, 将前一结点的后结点指向 new_element */
            new_element-&amp;gt;prev-&amp;gt;next = new_element;
        }
        element-&amp;gt;prev = new_element;
    }
    dlist-&amp;gt;size++;
    return 0;
}

/* 删除结点 */
int dlist_remove(DList *list, DListElmt *element, void **data)
{
    /* 无法删除 NULL 或者空链表 */
    if (element == NULL || list_size(list) != 0) {
        return -1;
    }
    *data = element-&amp;gt;data;

    if (list-&amp;gt;head == element) {
        /* 删除头结点 */
        list-&amp;gt;head = element-&amp;gt;next;
        if (element-&amp;gt;next == NULL) {
            /* 头结点也是末尾结点 */
            list-&amp;gt;tail = NULL;
        } else {
            element-&amp;gt;next-&amp;gt;prev = NULL;
        }
    } else {
        element-&amp;gt;prev-&amp;gt;next = element-&amp;gt;next;
        if (element-&amp;gt;next == NULL) {
            /* element 是末尾结点 */
            list-&amp;gt;tail = element-&amp;gt;prev;
        } else {
            element-&amp;gt;next-&amp;gt;prev = element-&amp;gt;prev;
        }
    }
    free(element);
    dlist-&amp;gt;size--;
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;循环链表&lt;/strong&gt;(Circular Lists)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="循环链表" src="../../assets/images/循环链表.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* clist.h */
#ifndef CLIST_H
#define CLIST_H

#include &amp;lt;stdlib.h&amp;gt;

/* 结点定义 */
typedef struct CListElmt_ {
    /* 指向数据 */
    void *data;
    /* 指向下一结点 */
    struct CListElmt *next;
}CListElmt;

/* 链表定义 */
typedef struct CList_ {
    /* 链表大小 */
    int size;
    int (*match)(const void *key1, const void *key2);
    /* 链表销毁回调函数 */
    void (*destroy)(void *data);
    /* 头结点 */
    CListElmt *head;
}CList;
/* 初始化链表 */
void clist_init(CList *list, void (*destroy)(void *data));
/* 销毁链表 */
void clist_destroy(CList *list);
/* 向 element 后插入结点, 向空链表插入元素时, element 可以是任何值, 但避免混乱最好为 NULL */
int clist_ins_next(CList *list, CListElmt *element, const void *data);
/* 删除 element 后一结点, element 传入 NULL 返回-1 */
int clist_rem_next(CList *list, CListElmt *element, void **data);
/* 返回链表大小 */
#define clist_size(list) ((list)-&amp;gt;size)
/* 返回头结点 */
#define clist_head(list) ((list)-&amp;gt;head)
/* 返回结点数据 */
#define clist_data(element) ((element)-&amp;gt;data)
/* 返回结点的下一结点 */
#define clist_next(element) ((element)-&amp;gt;next)

#endif&lt;/code&gt;&lt;/pre&gt;
函数实现
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include "clist.h"

/* 初始化 */
void clist_init(CList *list, void (*destroy)(void *data))
{
    list-&amp;gt;size = 0;
    list-&amp;gt;destroy = destroy;
    list-&amp;gt;head = NULL;

    return;
}

/* 销毁 */
void clist_destroy(CList *list)
{
    void *data;
    while (clist_size(list) &amp;gt; 0) {
        if (clist_rem_next(list, list-&amp;gt;head, (void **)&amp;amp;data) == 0 &amp;amp;&amp;amp; list-&amp;gt;destroy != NULL) {
            list-&amp;gt;destroy(data);
        }
    }
    memset(list, 0, sizeof(CList));
    return;
}

/* 插入结点 */
int clist_ins_next(CList *list, CListElmt *element, const void *data)
{
    CListElmt *new_element;
    if ((new_element = (CListElmt *)malloc(sizeof(CListElmt))) == NULL) {
        return -1;
    }
    new_element-&amp;gt;data = (void *)data;

    if (list-&amp;gt;size == 0) {
        /* 向空链表插入元素 */
        list-&amp;gt;head = new_element;
        new_element-&amp;gt;next = new_element;
    } else {
        new_element-&amp;gt;next = element-&amp;gt;next;
        element-&amp;gt;next = new_element;
    }
    list-&amp;gt;size++;
    return 0;
}

/* 删除结点 */
int clist_rem_next(CList *list, CListElmt *element, void **data)
{
    CListElmt *old_element;

    if (list_size(list) == 0 || element == NULL) {
        return -1;
    }

    *data = element-&amp;gt;data;
    if (element-&amp;gt;next == element) {
        /* 链表只有一个元素 */
        old_element = element;
        list-&amp;gt;head = NULL;
    } else {
        old_element = element-&amp;gt;next;
        element-&amp;gt;next = old_element-&amp;gt;next;
        if (list_head(list) == old_element) {
            list-&amp;gt;head = old_element-&amp;gt;next
        }
    }
    free(old_element);
    list-&amp;gt;size--;
    return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;</content><category term="算法"></category><category term="数据结构"></category><category term="C"></category><category term="链表"></category></entry><entry><title>C 语言简记</title><link href="https://ivicel.info/2017/03/c-yu-yan-jian-ji.html" rel="alternate"></link><published>2017-03-20T00:00:00+08:00</published><updated>2017-03-20T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2017-03-20:/2017/03/c-yu-yan-jian-ji.html</id><summary type="html">&lt;p&gt;First C program&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char **argv)
{
    printf("Hello C!!!\n");
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;1. 注释&lt;/strong&gt;&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* 
 *
 * 注释不能嵌套 
 *  
 */&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;2. 关键字、保留字&lt;/strong&gt;&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;auto&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;else&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;long&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;switch&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;break&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;register&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;typedef&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;case&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;union&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;char&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;float&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;short&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;unsigned&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;for&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;signed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sizeof&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;volatile&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;default&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;if&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;static&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;while&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;do …&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</summary><content type="html">&lt;p&gt;First C program&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char **argv)
{
    printf("Hello C!!!\n");
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;1. 注释&lt;/strong&gt;&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* 
 *
 * 注释不能嵌套 
 *  
 */&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;2. 关键字、保留字&lt;/strong&gt;&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;auto&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;else&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;long&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;switch&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;break&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;register&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;typedef&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;case&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;union&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;char&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;float&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;short&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;unsigned&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;for&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;signed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sizeof&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;volatile&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;default&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;if&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;static&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;while&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;do&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;int&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;_Packed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;double&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;&lt;strong&gt;3. 数据类型&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;整型&lt;br /&gt;
 - (&lt;code&gt;signed&lt;/code&gt;或&lt;code&gt;unsinged&lt;/code&gt;)&lt;br /&gt;
 - &lt;code&gt;char&lt;/code&gt;&lt;br /&gt;
 - &lt;code&gt;int&lt;/code&gt; &lt;br /&gt;
 - &lt;code&gt;short&lt;/code&gt; &lt;br /&gt;
 - &lt;code&gt;long&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;浮点型&lt;br /&gt;
 - &lt;code&gt;float&lt;/code&gt;&lt;br /&gt;
 - &lt;code&gt;double&lt;/code&gt;&lt;br /&gt;
 - &lt;code&gt;long double&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;数据在系统中占据的内存大小，与系统类型有关&lt;/p&gt;
&lt;p&gt;&lt;img alt="存储大小" src="../../assets/images/存储大小.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void&lt;/code&gt;类型&lt;/p&gt;
&lt;p&gt;作为函数返回值: &lt;code&gt;void func(int status)&lt;/code&gt;&lt;br /&gt;
作函数参数: &lt;code&gt;int rand(void)&lt;/code&gt;&lt;br /&gt;
作可变指针: &lt;code&gt;void *malloc(size_t size)&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;4. 标识符，变量&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;以&lt;code&gt;A-Z&lt;/code&gt;或&lt;code&gt;a-z&lt;/code&gt;或&lt;code&gt;_&lt;/code&gt;开头，加上数字&lt;br /&gt;
&lt;code&gt;extern&lt;/code&gt;关键字声明而不定义，在别的文件定义该变量&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在函数或块内部的&lt;strong&gt;局部变量&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在所有函数外部的&lt;strong&gt;全局变量&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在函数中定义的&lt;strong&gt;形式参数&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;#include &amp;lt;stdio.h&amp;gt;

/* 全局变量 */
/* 不手动初始化时，默认值被系统初始化为:
 * int =&amp;gt; 0
 * char =&amp;gt; '\0'
 * float =&amp;gt; 0
 * double =&amp;gt; 0
 * pointer =&amp;gt; NULL
 */
int a;
int main(void)
{
    /* 局部变量 */
    int b;

}
/* 形式变量 */
void func(int a)
{
    /* do something */
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;5. 常量&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;整数常量：十进制、十六进制(前缀&lt;code&gt;0x&lt;/code&gt;或&lt;code&gt;0X&lt;/code&gt;)、八进制(前缀&lt;code&gt;0&lt;/code&gt;)，可以带上后缀&lt;code&gt;U&lt;/code&gt; &lt;code&gt;u&lt;/code&gt;(表示&lt;code&gt;unsigned&lt;/code&gt;), &lt;code&gt;L&lt;/code&gt; &lt;code&gt;l&lt;/code&gt;(表示&lt;code&gt;long&lt;/code&gt;)&lt;br /&gt;
浮点常量：&lt;code&gt;e&lt;/code&gt;或&lt;code&gt;E&lt;/code&gt;的指数 &lt;code&gt;1.3&lt;/code&gt;&lt;br /&gt;
字符常量：&lt;code&gt;'x'&lt;/code&gt;, &lt;code&gt;'y'&lt;/code&gt;, 转义字符&lt;br /&gt;
字符串常量：&lt;code&gt;"hello"&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;定义常量：&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* 1. define预处理器 */ 
#define LENGTH 10
/* 2. const关键字 */
const int LEN = 10&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;6. C存储类&lt;/strong&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;auto&lt;/code&gt;: 局部变量默认类型，只能在局部变量使用  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;register&lt;/code&gt;: 存储在寄存器中，不能对其使用&lt;code&gt;&amp;amp;&lt;/code&gt;运算符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt;: 静态变量  &lt;/li&gt;
&lt;li&gt;修饰局部变量时，变量退出函数时不会被销毁  &lt;/li&gt;
&lt;li&gt;修饰全局时该变量只能在当前文件使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extern&lt;/code&gt;: 全局变量在所有程序文件可见，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;&lt;strong&gt;7. 运算符&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;算术运算符: &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, 前/后缀&lt;code&gt;++&lt;/code&gt;, 前/后缀&lt;code&gt;--&lt;/code&gt;&lt;br /&gt;
关系运算符: &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;br /&gt;
逻辑运算符: &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;&lt;br /&gt;
位运算符: &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;(取反), &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;(左移), &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;(右移)&lt;br /&gt;
赋值运算符: &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;&lt;br /&gt;
其他运算符: &lt;code&gt;sizeof&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;(返回变量地址), &lt;code&gt;*&lt;/code&gt;(指向一个变量), &lt;code&gt;?:&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;8. 语句&lt;/strong&gt;&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* 判断 */
if (a == b) {
    printf("yes\n");
} esle {
    print("no\n");
}

if (c == d) {
    /*..*/
} else if (e == f) {
    /*..*/
}

switch (a) {
    case 0:
        /*..*/
        break;
    default:
        /*..*/
}

/* 循环 */
while (a != 0) {
    /* do something */
}

do {
    /* do something */
} while (a != 0)

for (int i = 0; i &amp;lt; 10; i++) {
    /* do something */
}

/* continue 语句 */
/* goto 语句 */
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;9. 函数&lt;/strong&gt;&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* 传值 */
int func1(int a, int b)
{
    /* do something */
    return a;
}

/* 引用 */
int func2(int *a, int *b)
{
    /* do something */
    return a;
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;10. 数组&lt;/strong&gt;&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;double balance[10];
int a[5] = {1, 2, 3, 4, 5};
char b[6] = "hello";    /* 最后一位存储'\0' */
int c[] = {1, 2, 3, 4}; /* 忽略数组大小时，数组大小初始化为元素个数 */
/* 多维数组 */
int val[3][2] = {
    {0, 1},
    {2, 3},
    {4, 5}
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;11. 指针&lt;/strong&gt;&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* 指针的大小跟系统有关，64位中为8个字节 */
int a = 5;
int *p1 = &amp;amp;a;    /* p是a的地址，*p是a的值 */
int *p2 = NULL;  /* 空指针 */
/* 指针运算, 其实是内存的运算，指针的类型决定其运算增加或减少几个字节 */
p++;
p--;
p1 &amp;gt; p2;
/* 指针数组 */
int a = 5;
int *p[3];
p[0] = &amp;amp;a;
/* 指向指针的指针 */
int a = 5;
int *p = &amp;amp;a;
int **ptr = &amp;amp;p;&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;12. 结构体&lt;/strong&gt;&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* 定义 */
struct Books {
    char title[50];
    int book_id;
};

/* 声明 */
struct Books b1;
struct Books *book_ptr;
/* 访问 */
b1-&amp;gt;title;
b1-&amp;gt;book_id;&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;13. 共用体&lt;/strong&gt;&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* 大小是占内存最大的成员的大小 */
union Data {
    int i;
    float f;
    char str[20];
}data;
/* 访问 */
data.i;
data.f;

/*********************************/
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main()
{
    union Data {
        int i;
        float j;
        char a[20];
    }data;

    data.i = 10;
    data.j = 2.3;
    /* 最的出赋值覆盖了前面的值 */
    strcpy(data.a, "C Programming");
    printf("data.i = %d\n", data.i);
    printf("data.j = %f\n", data.j);
    printf("data.a = %s\n", data.a);

    return 0;
}

/* 输出 */
data.i = 1917853763
data.j = 4122360580327794860452759994368.000000
data.a = C Programming

/**************************************/
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main()
{
    union Data {
        int i;
        float j;
        char a[20];
    } data;

    data.i = 10;
    printf("data.i = %d\n", data.i);
    data.j = 2.3;
    printf("data.j = %f\n", data.j);
    strcpy(data.a, "C Programming");
    printf("data.a = %s\n", data.a);

    return 0;
}

/* 输出正常 */
data.i = 10
data.j = 2.300000
data.a = C Programming&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;14. 位域&lt;/strong&gt;&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* 一个位域必须存储在同一字节中，有些编译器可以跨字节，可以有空域来作占位符 */
/* 因为不能跨字节，所以位域最大为8位，大于8位产生不可预计影响 */
/* 无名位域即空域，只能用来作占位符，不能被使用 */

/* 位域使用struct声明 
 * struct {
 *     type [member_name] : width;
 * };
 * type可以是有符号或无符号整型，准定了如何解释位域
 */
struct {
    /* 只占4个字节，并且只有两bit被使用 */
    unsigned int width:1;       
    unsigned int length:1;
}status;

struct {
    unsigned a:4;
    unsigned :4;    /* 空域 */
    usigned b:4;    /* 从下一个字节开始存储 */
    usigned c:4;
}bs;
/* 位域调用，赋值大小应当小于位数能表示的最大数
 * 超过这个数时编译器会产警告 
 */
bs.a;
bs-&amp;gt;b;&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;15. typedef&lt;/strong&gt;&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* typedef 来定义别名 */
typedef unsigned char BYTE;
BYTE b1, b2;

typedef struct Books {
    char title[50];
    int book_id;
} Book;
Book b1;
/* typedef vs define
 * typedef 仅限于为类型定义符号名称
 * #define 不仅可以为类型定义别名，也能为数值定义别名，比如可以定义 1 为 ONE
 * typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的
 */&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;**16. 标准输入、输出、错误输出&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;stdin&lt;/code&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;code&gt;stderr&lt;/code&gt;
读或输出字符：&lt;code&gt;getchar()&lt;/code&gt; &lt;code&gt;putchar()&lt;/code&gt;
读或输出一行：&lt;code&gt;gets()&lt;/code&gt; &lt;code&gt;puts()&lt;/code&gt;
格式化输入输出：&lt;code&gt;scanf()&lt;/code&gt; &lt;code&gt;printf()&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* 文件读写 */
FILE *fopen(const char *filename, const char *mode);
/* 模式:
 * r 只读，文件不存在程序出错
 * w 只写，文件不存在则创建，存在截为0
 * a 增加写入，文件不存在则创建
 * r+ 读写，文件不存在程序出错，存在截为0
 * w+ 读写，文件不存在则创建，存在截为0
 * a+ 读写增加，文件不存在则创建
 * b 二进制模式
 */
int fputc(int c, FILE *fp);
int fputs(const char *str, FILE *fp);

int fgetc(FILE *fp);
char *fgets(char *buf, int n, FILE *fp);

/* 读写二进制 */
size_t fread(void *ptr, size_t size, size_t numbers, FILE *fp);
size_t fwrite(const void *ptr, size_t size, size_t numbers, FILE *fp);&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;17.预处理器&lt;/strong&gt;&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/*
 * #define   定义宏
 * #include  包含一个源代码文件
 * #ifdef    如果宏已经定义，返回真
 * #ifndef   如果宏未定义，返回真
 * #if       如果条件为真，则编译下方代码
 * #else
 * #elif
 * #endif    结束一个#if语句
 * #error    当遇到标准错误时，输出错误消息
 * #pragma   使用标准化方法，向编译器发布特殊命令到编译器中
 */

#define MAX_ARRAY_LENGTH 20

#include &amp;lt;stdio.h&amp;gt;
#include "myheader.h"

#undef FILE_SIZE
#define FILE_SIZE 42

#ifndef MESSAGE
   #define MESSAGE "You wish"
#endif

#ifdef DEBUG
    /* do something */
#else
    /* doing... */
#endif

/* # 号的使用使用传入宏的变量转为字符串
 * ## 号使两个参数合并
 */
#include &amp;lt;stdio.h&amp;gt;

#define tokenpaster(n) printf ("token" #n " = %d", token##n)

int main(void)
{
   int token34 = 40;

   tokenpaster(34);
   return 0;
}

/* 输出 */
token34 = 40
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;预定义的宏
&lt;code&gt;__DATE__&lt;/code&gt; 以"MMM DD YYYY"表示的日期
&lt;code&gt;__TIME__&lt;/code&gt; 以"HH:MM:SS"表示的时间
&lt;code&gt;__FILE__&lt;/code&gt; 当前文件名
&lt;code&gt;__LINE__&lt;/code&gt; 当前行号
&lt;code&gt;__STDC__&lt;/code&gt; 当以ANSI标准编译时，定义为1&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;18. 类型转换&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img alt="强制类型转换" src="../../assets/images/强制类型转换.png" /&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;19. 可变参数&lt;/strong&gt;&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;/* 可变参数定义在 stdarg.h 头文件中
 * 函数的第一个参数总是int，表示参数的个数，后面跟省略号
 * 使用int参数和va_start宏初始化va_list变量为参数列表
 * 使用va_arg宏和va_list变量来访问参数列表中的每一项
 * 使用va_end来清理赋予va_list变量的内存
 */
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdarg.h&amp;gt;


double average(int num, ...)
{
    double sum = 0.0;
    va_list valist;
    va_start(valist, num);
    for (int i = 0; i &amp;lt; num; i++) {
        sum += va_arg(valist, int);
    }
    va_end(valist);
    return sum / num;
}

int main()
{
    double i = average(5, 1, 2, 3, 4, 5);
    printf("average is: %f\n", i);
    return 0;
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;20. 内存管理&lt;/strong&gt;&lt;/h4&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-c"&gt;void *calloc(int num, int size);
void *malloc(int num);
void realloc(void *address, int newsize);
void free(void *address);&lt;/code&gt;&lt;/pre&gt;</content><category term="C"></category></entry><entry><title>Python类内置魔术方法</title><link href="https://ivicel.info/2017/03/pythonlei-nei-zhi-mo-zhu-fang-fa.html" rel="alternate"></link><published>2017-03-20T00:00:00+08:00</published><updated>2017-03-20T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2017-03-20:/2017/03/pythonlei-nei-zhi-mo-zhu-fang-fa.html</id><summary type="html">&lt;h3&gt;内置类特殊属性&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;object.__dict__

instance.__class__

class.__bases__

definition.__name__

definition.__qualname__

class.__mro__

class.mro()

class.__subclasses__()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自定义类都有一个&lt;code&gt;namespace&lt;/code&gt;，即一个字典对象来存储类的属性。&lt;code&gt;C.x&lt;/code&gt;即表示&lt;code&gt;C.__dict__['x']&lt;/code&gt;，当类&lt;code&gt;C&lt;/code&gt;中不存在属性&lt;code&gt;x&lt;/code&gt;，会依据继承顺序&lt;a href="https://www.python.org/download/releases/2.3/mro/"&gt;&lt;code&gt;MRO&lt;/code&gt;&lt;/a&gt;表来查找该属性。&lt;/p&gt;
&lt;p&gt;如若查找完基类后，依然找不到属性，才会调相应用&lt;code&gt;C.__getattribute__()&lt;/code&gt;、&lt;code&gt;C.__getattr__()&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;class A(object):
    def __getattr__(self, name):
        print('call __getattr__ …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;h3&gt;内置类特殊属性&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;object.__dict__

instance.__class__

class.__bases__

definition.__name__

definition.__qualname__

class.__mro__

class.mro()

class.__subclasses__()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自定义类都有一个&lt;code&gt;namespace&lt;/code&gt;，即一个字典对象来存储类的属性。&lt;code&gt;C.x&lt;/code&gt;即表示&lt;code&gt;C.__dict__['x']&lt;/code&gt;，当类&lt;code&gt;C&lt;/code&gt;中不存在属性&lt;code&gt;x&lt;/code&gt;，会依据继承顺序&lt;a href="https://www.python.org/download/releases/2.3/mro/"&gt;&lt;code&gt;MRO&lt;/code&gt;&lt;/a&gt;表来查找该属性。&lt;/p&gt;
&lt;p&gt;如若查找完基类后，依然找不到属性，才会调相应用&lt;code&gt;C.__getattribute__()&lt;/code&gt;、&lt;code&gt;C.__getattr__()&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;class A(object):
    def __getattr__(self, name):
        print('call __getattr__()')

a = A()
a.x = 'X'
print(a.x)              # 'X', __getattr__()并未调用
print(a.__dict__)       # {'x': 'X'}

######################################

class A(object):
    x = 'A'

class B(A):
    def __getattr__(self, name):
        print('call __getattr__()')
        return 'B'

a = B() 
print(a.x)          # 'A', a.__getattr__()并不会调用
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;code&gt;__slots__&lt;/code&gt; 的特殊性&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;类变量&lt;code&gt;__slots__&lt;/code&gt; 可赋值 string, iterable，字符list&lt;/p&gt;
&lt;p&gt;定义&lt;code&gt;__slots__&lt;/code&gt;变量后，类将不再使用&lt;code&gt;__dict__&lt;/code&gt;来存储属性&lt;/p&gt;
&lt;p&gt;类不会自动生成&lt;code&gt;__dict__&lt;/code&gt;和&lt;code&gt;__weakref__&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;对象方法&lt;/h3&gt;
&lt;p&gt;类中的对象方法(instance method\bound method), 其方法名也存在&lt;code&gt;M.__dict__&lt;/code&gt;中，对象方法有两个只读变量&lt;code&gt;mehtod.__self__&lt;/code&gt;和&lt;code&gt;method.__func__&lt;/code&gt;，当调用方法时&lt;code&gt;method(arg1, arg2)&lt;/code&gt;时，等于调用&lt;code&gt;method.__func__(method.__self__, arg1, arg2)&lt;/code&gt;&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;class A(object):
    def m(self):
        print('call method m')

a = A()
a.m()   # a.m.__func__(a.m.__self__)&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;访问控制 &lt;code&gt;self.x&lt;/code&gt;&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;__getattr__(self, name)

__getattribute__(self, name)

# Attribute assignments and deletions update the instance’s dictionary, never a class’s dictionary.
# If the class has a __setattr__() or __delattr__() method, 
# this is called instead of updating the instance dictionary directly.
# 删除对象的属性或者对对象属性赋值，是直接对实例 __dict__ 的操作
# 当定义了 __setattr__ 、__delattr__ 方法时，使用方法替代
__setattr__(self, name, value)

__delattr__(self, name)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基类 &lt;code&gt;object&lt;/code&gt; 中并没有 &lt;code&gt;__getattr__()&lt;/code&gt; 方法，所以，只有当自定义类的自定义了&lt;code&gt;__getattr__()&lt;/code&gt;方法，才有可能访问该方法&lt;/p&gt;
&lt;p&gt;访问属性&lt;code&gt;self.x&lt;/code&gt;时，首先会隐式调用&lt;code&gt;__getattribute__()&lt;/code&gt;方法，只有在&lt;code&gt;__getattribute__()&lt;/code&gt;中显示调用或者&lt;code&gt;raise&lt;/code&gt;出&lt;code&gt;AttributeError&lt;/code&gt;时，才会调用&lt;code&gt;__getattr__()&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;类中没有定义&lt;code&gt;__getattribute__()&lt;/code&gt;时，当&lt;code&gt;self.x&lt;/code&gt;不存在时，默认&lt;code&gt;raise&lt;/code&gt;出&lt;code&gt;AttributeError&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类中有定义&lt;code&gt;__getattribute__()&lt;/code&gt;时，访问&lt;code&gt;self.x&lt;/code&gt;时，调用&lt;code&gt;__getattribute__()&lt;/code&gt;，除非显示调用&lt;code&gt;__getattr__()&lt;/code&gt;或者&lt;code&gt;raise&lt;/code&gt;出&lt;code&gt;AttributeError&lt;/code&gt;,才会调用&lt;code&gt;__getattr__()&lt;/code&gt;如若存在&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;在定义&lt;code&gt;__getattribute__()&lt;/code&gt;时，为避免无限递归调用，一般使用&lt;code&gt;object.__getattribute__(self, name)&lt;/code&gt;来获取对象的值&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;class A(object):
    def __getattr__(self, name):
        print('get =&amp;gt; ' + name)

    def __getattribute__(self, name):
        print('get attribute =&amp;gt; ' + name)
        raise AttributeError()  # 隐式调用 __getattr__()



# get attribute =&amp;gt; b
# get =&amp;gt; b
# None
a = A()
print(a.b)

########################################

class A(object):
    def __getattr__(self, name):
        print('get =&amp;gt; ' + name)

# get =&amp;gt; b
# None
a = A()
print(a.b)

########################################

class A(object):
    def __getattribute__(self, name):
        print('get attribute =&amp;gt; ' + name)


# get attribute =&amp;gt; b
# None
a = A()
print(a.b)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;自定义序列 self[x]&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;__len__(self)                       # len() 方法

__getitem__(self, key)              # self[key]

__setitem__(self, key)              # self[key] = XXX

__iter__(self, key)                 # 迭代器

__reversed__(self)                  # reversed() 方法

__contains__(self, item)            # in 和 not in 测试

__missing__(self, key)              # self[key] 不存在时&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当类没有定义&lt;code&gt;__getitem__()&lt;/code&gt;时，&lt;code&gt;self['x']&lt;/code&gt;会产生&lt;strong&gt;&lt;code&gt;Type Error&lt;/code&gt;:object is not subscriptable&lt;/strong&gt;, 定义&lt;code&gt;__getitem__()&lt;/code&gt;后，类变成一个&lt;strong&gt;subscriptor&lt;/strong&gt;，&lt;code&gt;self['x']&lt;/code&gt;隐式调用&lt;code&gt;__getitem__()&lt;/code&gt;。一般在普通的如&lt;code&gt;list&lt;/code&gt;中，&lt;code&gt;x&lt;/code&gt;不存在或错误会产生&lt;code&gt;KeyError&lt;/code&gt;，超出范围则产生&lt;code&gt;IndexError&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;描述符对象&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;__get__(self, instance, owner)

__set__(self, instance, owner)

__delete__(self, instance, owner)

# 生成描述符实例时调用
__set_name__(self, owner, name)&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;当一个类实现&lt;code&gt;__get__()&lt;/code&gt; &lt;code&gt;__set__()&lt;/code&gt; &lt;code&gt;__delete__()&lt;/code&gt;中一个方法，称为&lt;strong&gt;描述符类&lt;/strong&gt;(&lt;code&gt;decriptor class&lt;/code&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;定义 &lt;code&gt;__set__()&lt;/code&gt; and/or &lt;code&gt;__delete__()&lt;/code&gt;，称为&lt;strong&gt;数据描述符&lt;/strong&gt;(&lt;code&gt;data descriptor&lt;/code&gt;); 没有定义其中一个的称为&lt;strong&gt;非数据描述符&lt;/strong&gt;(&lt;code&gt;non-data descriptor&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;通常&lt;code&gt;data descriptor&lt;/code&gt;都定义&lt;code&gt;__set__()&lt;/code&gt;和&lt;code&gt;__get__()&lt;/code&gt;，&lt;code&gt;non-data descriptor&lt;/code&gt;只定义&lt;code&gt;__get__()&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The following methods only apply when an instance of the class containing the method (a so-called descriptor class) appears in an owner class (the descriptor must be in either the owner’s class dictionary or in the class dictionary for one of its parents). In the examples below, “the attribute” refers to the attribute whose name is the key of the property in the owner class’ &lt;code&gt;__dict__&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;只有描述符类的实例&lt;code&gt;instance&lt;/code&gt;是&lt;code&gt;owner_class&lt;/code&gt;中或&lt;code&gt;owner_class&lt;/code&gt;的某一个父类中&lt;code&gt;__dict__&lt;/code&gt;中属性的实例，描述符方法才会调用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;描述符调用&lt;code&gt;a.x&lt;/code&gt;和&lt;code&gt;A.x&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接调用&lt;code&gt;x.__get__(a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;实例对象绑定：&lt;code&gt;a.x&lt;/code&gt;即&lt;code&gt;type(a).__dict__['x'].__get__(a, type(a))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;类绑定：&lt;code&gt;A.x&lt;/code&gt;即&lt;code&gt;A.__dict__['x'].__get__(None, A)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Super绑定(继承的类有类属性是描述符的实例对象)：&lt;code&gt;super(B, obj).m&lt;/code&gt;查找&lt;code&gt;obj.__class__.__mro__&lt;/code&gt;，当找到&lt;code&gt;A&lt;/code&gt;类有&lt;code&gt;m&lt;/code&gt;属性为描述符对象时调用&lt;code&gt;A.__dict__['m'].__get__(obj, obj.__class__)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;# example
# owner的类属性是一个decriptor的实例
class A(object):
    def __get__(self, instance, cls):
        print('call A.__get__()')
        return 'Class A'

class B(object):
    x = A()

# call A.__get__()
# 'Class A' 
b = B()
print(b.x)  

##############################

# owner的父类的属性是一个decriptor的实例
class A(object):
    def __get__(self, instance, cls):
        print('call A.__get__()')
        return 'Class A'

class B(object):
    x = A()

class C(B):
    pass

# print('call A.__get__()')
# 'Class A'
c = C()
print(c.x)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;对象属性访问原理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;访问顺序：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;资料描述器(&lt;code&gt;data descriptor&lt;/code&gt;)优先于实例变量(&lt;code&gt;instance.attribute&lt;/code&gt;)，实例变量优先于非资料描述器(&lt;code&gt;non-data descriptor&lt;/code&gt;)，&lt;code&gt;__getattr__()&lt;/code&gt;方法(如果对象中包含的话) 具有最低的优先级&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;class descriptor(object):
    def __get__(self, instance, cls):
        print('__get__()')

    def __set__(self, instance, value):
        print('__set__()')

class A(object):
    x = descriptor()
    def __init__(self):
        # 资料描述符优先实例变量
        self.x = 'x'        #=&amp;gt; type(a).__dict__['x'].__set__(a, type(a))


# '__set__()'
# '__get__()'
# '__set__()'       
a = A()
a.x         #=&amp;gt; type(a).__dict__['x'].__get__(a, type(a))
a.x = 5     #=&amp;gt; type(a).__dict__['x'].__set__(a, type(a))

##############################################

class descriptor(object):
    def __get__(self, instance, cls):
        print('__get__()')

class A(object):
    x = descriptor()
    def __init__(self):
        # 实例变量优先非资料描述符
        self.x = 'x'        #=&amp;gt; self.__dict__['x'] = 'x'


# x
# {'x': 'x'}        
a = A()
print(a.x)          
print(a.__dict__)       

##############################################

class descriptor(object):
    def __get__(self, instance, cls):
        print('__get__()')

class A(object):
    x = descriptor()

    def __getattr__(self, key):
        print('__getattr__()')

# '__get__()'   
a = A()
# 非资料描述符优先 __getattr__ 
a.x         #=&amp;gt; type(a).__dict__['x'].__get__(a, type(a))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;描述符(descriptor)举例&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;内置 property 的实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;class Property(object):
    def __init__(self, func):
        self._func_getter = func

    def __get__(self, instance, cls):
        return self._func_getter(instance)

    def __set__(self, instance, value):
        if getattr(self, '_setter', False):
            self._func_setter(instance, value)
        else:
            raise AttributeError("can't set attribute")

    def setter(self, func):
        self._setter = True
        self._func_setter = func
        return self

class A(object):
    @Property
    def say_hello(self):
        if hasattr(self, '_x'):
            return self._x
        else:
            return 'xxxxxxxxxxxxx'

    @say_hello.setter
    def say_hello(self, value):
        print('say hello again')
        self._x = value&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;classmethod&lt;/code&gt;和&lt;code&gt;staticmethod&lt;/code&gt;的简单实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;class ClassMethod(object):
    def __init__(self, func):
        self._f = func

    def __get__(self, instance, cls):
        def func():
            return self._f(cls)
        return func

class StaticMethod(object):
    def __init__(self, f):
        self._f = f

    def __get__(self, instance, cls):
        return self._f
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;h3&gt;比较操作符&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-Python"&gt;__eq__(self, other)     # ==

__ne__(self, other)     # !=

__lt__(self, other)     # &amp;lt;

__gt__(self, other)     # &amp;gt;

__le__(self, other)     # &amp;lt;=

__ge__(self, other)     # &amp;gt;=
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;数值操作符&lt;/h3&gt;
&lt;p&gt;.1 一元操作符&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;__post__(self)          # 取正 +some_object

__neg__(self)           # 取负 -some_object

__abs__(self)           # 绝对值 abs()

__invert__(self)        # 取反 ~

__round__(self, n)      # 内建函数 round()

__floor__(self)         # math.floor() 函数，向下取整

__ceil__(self)          # math.ceil() 函数，向上取整

__trunc__(self)         # math.trunc() 函数，距离0最返的整数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.2 算数操作符&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;__add__(self, other)

__sub__(self, other)

__mul__(self, other)

__floordiv__(self, other)

__truediv__(self, other)

__mod__(self, other)

__divmod__(self, other)

__pow__(self)

__lshift__(self, other)

__rshift__(self, other)

__and__(self, other)

__or__(self, other)

__xor__(self, other)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.3 反射算数运算符&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;__radd__(self, o)

__rsub__(self, o)

__rmul__(self, o)

__rfloordiv__(self, o)

__rtruediv__(self, o)

__rmod__(self, o)

__rpow__(self)

__rlshift__(self, o)

__rshift__(self, o)

_rand__(self, o)

__ror__(self, o)

__rxor__(self, o)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.4 增强赋值运算符&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;__iadd__(self, o)

__isub__(self, o)

__imul__(self, o)

__ifloordiv__(self, o)

__itruediv__(self, o)

__imod__(self, o)

__ipow__(self, o)

__ilshift__(self, o)

__irshift__(self, o)

__iand__(self, o)

__ixor__(self, o)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.5 类型转换操作符&lt;/p&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;__int__(self)

__long__(self)

__float__(self)

__complex__(self)

__oct__(self)

__hex__(self)

__index__(self)

__trunc__(self)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;类的表示&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;__str__(self)

__repr__(self)

__format__(self)

__hash__(self)

__dir__(self)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;反射&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;# isinstance(instance, class) 方法
__instancecheck__(self, instance)       

# issubclass(subclass, class) 方法
__subclasscheck__(self, subclass)       &lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;抽象基类&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;可调用的对象&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;__call__(self, [args...])

class A():
    def __call__(self):
        pass

a = A()
a()     # 调用A.__call__()&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;上下文管理器&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;# 使用 with 声明时调用，返回值即为 as 后的东西
__enter__(self)

# 退出 with 时调用，处理 with 产生的 exception
__exit__(self, exceptiop_type, exception_value, traceback)


# 跟 async with 使用, 异步上下文, 除了必须返回一个 awaitable, 其他与上相同
__aenter__(self)
__aexit__(self, exec_type, exec_value, traceback)&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;拷贝&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-python"&gt;__copy__(self)

__deepcopy__(self, memodict=)&lt;/code&gt;&lt;/pre&gt;</content></entry><entry><title>SQL 简单速记</title><link href="https://ivicel.info/2017/03/sql-jian-dan-su-ji.html" rel="alternate"></link><published>2017-03-20T00:00:00+08:00</published><updated>2017-03-20T00:00:00+08:00</updated><author><name>ivicel</name></author><id>tag:ivicel.info,2017-03-20:/2017/03/sql-jian-dan-su-ji.html</id><summary type="html">&lt;h3&gt;&lt;strong&gt;1. 检索数据&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-sql"&gt;/* 单个列 */
SELECT prod_name FROM Product;
/* 多个列 */
SELECT prod_id, prod_name FROM Products;
/* 所有列 */
SELECT * FROM Products;
/* 检索不同值 */
SELECT DISTINCT vend_id FROM Products;
/* 条件限制 */
SELECT prod_id FROM Products WHERE prod_id = 5;
SELECT prod_id FROM Products LIMIT 5;
/* 注释 */
/*...多行注释*/
--- 单行注释&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;strong&gt;2. 排序&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-sql"&gt;/* 排序条件不一定出现在选择结果中 */

/* 排序单个列 */
SELECT * FROM  Products ORDER BY prod_id …&lt;/code&gt;&lt;/pre&gt;</summary><content type="html">&lt;h3&gt;&lt;strong&gt;1. 检索数据&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-sql"&gt;/* 单个列 */
SELECT prod_name FROM Product;
/* 多个列 */
SELECT prod_id, prod_name FROM Products;
/* 所有列 */
SELECT * FROM Products;
/* 检索不同值 */
SELECT DISTINCT vend_id FROM Products;
/* 条件限制 */
SELECT prod_id FROM Products WHERE prod_id = 5;
SELECT prod_id FROM Products LIMIT 5;
/* 注释 */
/*...多行注释*/
--- 单行注释&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;strong&gt;2. 排序&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-sql"&gt;/* 排序条件不一定出现在选择结果中 */

/* 排序单个列 */
SELECT * FROM  Products ORDER BY prod_id;
/* 多个列排序 */
SELECT prod_id, prod_name FROM Products ORDER BY prod_id, prod_name;
/* 按位置排序，即选择结果中的位置，prod_id,prod_name */
SELECT prod_id, prod_name FROM Products ORDER BY 1, 2;
/* 降序，默认升序 ASC */
SELECT prod_id FROM Products ORDER BY prod_name DESC;&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;strong&gt;3. 过滤数据&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-sql"&gt;/* WHREE子句 */
SELECT * FROM Products WHERE prod_id &amp;lt; 5;
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;&amp;gt;&lt;/td&gt;
&lt;td&gt;不等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;不等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;小于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;=&lt;/td&gt;
&lt;td&gt;小于等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!&lt;/td&gt;
&lt;td&gt;不小于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&gt;&lt;/td&gt;
&lt;td&gt;大于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&gt;=&lt;/td&gt;
&lt;td&gt;大于等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!&amp;gt;&lt;/td&gt;
&lt;td&gt;不大于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BETWEEN&lt;/td&gt;
&lt;td&gt;在指定值之间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IS NULL&lt;/td&gt;
&lt;td&gt;为NULL&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;&lt;strong&gt;4. 高级过滤&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-sql"&gt;/* AND、OR */
SELECT prod_id, prod_name FROM Products WHERE prod_id = 5 AND prod_name = 'hello';
SELECT prod_id, prod_name FROM Products WHERE prod_id = 5 OR prod_name = 'hello';

SELECT prod_name, prod_price
FROM Products
WHERE vend_id = 'DLL01' OR vend_id = 'BRS01'
AND prod_price &amp;gt;= 10;

/* IN */
SELECT prod_name, prod_id
FROM Products
WHERE vend_id IN ('DLL01', 'BRS01')
ORDER BY prod_name;

/* NOT */
SELECT prod_name, prod_id 
FROM Products
WHERE NOT prod_id = 5;&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;strong&gt;5. 通配符过滤&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-sql"&gt;/* % 任意字符出现任意次, 匹配多个字符*/
SELECT prod_name, prod_id
FROM Products
WHERE prod_name LIKE 'fish%';

/* _ 匹配单个字符 */
SELECT prod_name, prod_id
FROM Products
WHERE prod_name LIKE 'fish_';

/* [] 匹配方括号内指定字符 */
SELECT prod_name, prod_id
FROM Products
WHERE prod_name LIKE '[JM]%';

&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;strong&gt;6. 创建字段&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-sql"&gt;SELECT vend_name + ' (' + vend_country + ')'
FROM Vendors
ORDER BY vend_name;
/* 或者, 具体依赖于具体的数据库 */
SELECT vend_name || ' (' || vend_country || ')'
FROM Vendors
ORDER BY vend_name;

/* AS 别名 */
SELECT vend_name + ' (' + vend_country + ')' AS vend_title
FROM Vendors
ORDER BY vend_name;

/* 算术计算 "+, -, *, \" */
SELECT prod_id, quantity, item_price, quantity * item_price AS expanded_price
FROM OrderItems
WHERE order_num = 2008;&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;strong&gt;7. 数据处理函数&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;各个数据库函数的名称可能不同&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函　　数&lt;/th&gt;
&lt;th&gt;语　　法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;提取字符串的组成部分&lt;/td&gt;
&lt;td&gt;Access使用MID()；DB2、Oracle、PostgreSQL和SQLite使用SUBSTR()；MySQL和SQL Server使用SUBSTRING()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据类型转换&lt;/td&gt;
&lt;td&gt;Access和Oracle使用多个函数，每种类型的转换有一个函数；DB2和PostgreSQL使用CAST()；MariaDB、MySQL和SQL Server使用CONVERT()”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;“取当前日期&lt;/td&gt;
&lt;td&gt;Access使用NOW()；DB2和PostgreSQL使用CURRENT_DATE；MariaDB和MySQL使用CURDATE()；Oracle使用SYSDATE；SQL Server使用GETDATE()；SQLite使用DATE()”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;取当前日期&lt;/td&gt;
&lt;td&gt;Access使用NOW()；DB2和PostgreSQL使用CURRENT_DATE；MariaDB和MySQL使用CURDATE()；Oracle使用SYSDATE；SQL Server使用GETDATE()；SQLite使用DATE()”&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;文本处理函数&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函　　数&lt;/th&gt;
&lt;th&gt;说　　明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;LEFT()（或使用子字符串函数）&lt;/td&gt;
&lt;td&gt;返回字符串左边的字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LENGTH()（也使用DATALENGTH()或LEN()）&lt;/td&gt;
&lt;td&gt;返回字符串的长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LOWER()（Access使用LCASE()）&lt;/td&gt;
&lt;td&gt;将字符串转换为小写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LTRIM()&lt;/td&gt;
&lt;td&gt;去掉字符串左边的空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RIGHT()&lt;/td&gt;
&lt;td&gt;（或使用子字符串函数）  返回字符串右边的字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RTRIM()&lt;/td&gt;
&lt;td&gt;去掉字符串右边的空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SOUNDEX()&lt;/td&gt;
&lt;td&gt;返回字符串的SOUNDEX值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UPPER()（Access使用UCASE()）&lt;/td&gt;
&lt;td&gt;将字符串转换为大写”&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;聚集函数&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函　　数&lt;/th&gt;
&lt;th&gt;说　　明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AVG()&lt;/td&gt;
&lt;td&gt;返回某列的平均值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;COUNT()&lt;/td&gt;
&lt;td&gt;返回某列的行数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MAX()&lt;/td&gt;
&lt;td&gt;返回某列的最大值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MIN()&lt;/td&gt;
&lt;td&gt;返回某列的最小值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SUM()&lt;/td&gt;
&lt;td&gt;返回某列值之和”&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-sql"&gt;SELECT AVG(DISTINCT prod_price) AS avg_price
FROM Products
WHERE vend_id 'DLL01';&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;strong&gt;8. 分组&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-sql"&gt;/* GROUP BY 组合条件必须出现在选择结果中*/
SELECT vend_id, COUNT(*) AS num_prods
FROM Products
GROUP BY vend_id;

/* HAVING 与 GROUP BY 一同使用来过滤分组*/
SELECT vend_id, COUNT(*) AS num_prods
FROM Products
GROUP BY vend_id
HAVING COUNT(*) &amp;gt;= 2;

/* 分组后排序 */
SELECT order_num, COUNT(*) AS items
FROM OrderItems
GROUP BY order_num
HAVING COUNT(*) &amp;gt;= 3
ORDER BY items, order_num;&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;strong&gt;9. 子查询&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-sql"&gt;SELECT cust_name, cust_contact
FROM Customers
WHERE cust_id IN (
    SELECT cust_id FROM Order WHERE order_num IN (
        SELECT order_num FROM OrderItems WHERE prod_id = 'RGA001'
    )
);

SELECT cust_name, cust_state, (
    SELECT COUNT(*) FROM Orders WHERE cust_id = cust_id) AS orders
FROM Customers 
ORDER BY cust_name;&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;strong&gt;10. 联结&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-sql"&gt;/* 使用联结时一定要有限定条件 WHERE， LIKE等 */

/* 多表查询 */
SELECT vend_name, prod_name, prod_price
FROM Vendors, Products
WHERE Vendors.vend_id = Products.vend_id;

/* 内联结 */
SELECT vend_name, prod_name, prod_price
FROM Vendors INNER JOIN Products
ON Vendors.vend_id = Products.vend_id;

/* 左外联结 */
SELECT Customers.cust_id, Orders.order_num
FROM Customers LEFT OUTER JOIN Orders
ON Customers.cust_id = Orders.cust_id; 

/* 右外联结 */
SELECT Customers.cust_id, Orders.order_num
FROM Customers RIGHT OUTER JOIN Orders
ON Orders.cust_id = Customers.cust_id;


/* 表自联结 */
SELECT cust_id, cust_name, cust_contact
FROM Customers
WHERE cust_name = (
    SELECT cust_name FROM Customers WHERE cust_contact = 'Jim Jones'
);

SELECT c1.cust_id, c1.cust_name, c1.cust_contact
FROM Customers AS c1, Customers AS c2
WHERE c1.cust_name = c2.cust_name
AND c2.cust_contact = 'Jim Jones'; &lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;strong&gt;11. 组合查询&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-sql"&gt;SELECT cust_name, cust_contact, cust_email
FROM Customers
WHERE cust_state IN ('IL','IN','MI');

SELECT cust_name, cust_contact, cust_email
FROM Customers
WHERE cust_name = 'Fun4All';


/* 以上两条使用 UNION 来查询*/
SELECT cust_name, cust_contact, cust_email
FROM Customers
WHERE cust_state IN ('IL','IN','MI')
UNION
SELECT cust_name, cust_contact, cust_email
FROM Customers
WHERE cust_name = 'Fun4All';”

/* UNION默认去掉重复的行，使用ALL包含所有行*/
SELECT cust_name, cust_contact, cust_email 
FROM Customers 
WHERE cust_state IN ('IL','IN','MI') 
UNION ALL
SELECT cust_name, cust_contact, cust_email 
FROM Customers 
WHERE cust_name = 'Fun4All';&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;strong&gt;12. 数据插入&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-sql"&gt;/* 必须与库中顺序对齐 */
INSERT INTO Customers
VALUES('1000000006',
       'Toy Land',
       '123 Any Street',
       'New York',
       'NY',
       '11111',
       'USA',
       NULL,
       NULL);

/* 插入部分数据 */
INSERT INTO Customers(
    cust_name,
    cust_address,
    cust_city,
    cust_state,
    cust_zip,
    cust_country
)
VALUES(
    'Toy Land',
    '123 Any Street',
    'New York',
    'NY',
    '11111',
    'USA'
);

/* 使用检出行插入数据 */
INSERT INTO Customers(cust_id,
                      cust_contact,
                      cust_email,
                      cust_name,
                      cust_address,
                      cust_city,
                      cust_state,
                      cust_zip,
                      cust_country)
SELECT cust_id,
       cust_contact,
       cust_email,
       cust_name,
       cust_address,
       cust_city,
       cust_state,
       cust_zip,
       cust_country
FROM CustNew;

/* 从一个表复制到另一个表 */
SELECT * INTO CustCopy FROM Customers;&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;strong&gt;13. 更新数据&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-sql"&gt;/* 更新数据时不要忘记限制条件，否则会更新整个表的所有行 */
UPDATE Customers SET cust_email = 'kil@there.com' WHERE cust_id = '100005';

/* 删除行 */
DELETE FROM Customers WHERE cust_id = '100005';&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;strong&gt;14. 创建表&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-sql"&gt;CREATE TABLE Products
(
    prod_id     CHAR(10)        NOT NULL,
    vend_id     CHAR(10)        NOT NULL,
    prod_name   CHAR(254)       NOT NULL,
    prod_price  DECIMA(8, 2)    NOT NULL,
    prod_desc   VARCHAR(1000)   NULL
);


CREATE TABLE OrderItems
(
    order_num      INTEGER          NOT NULL,
    order_item     INTEGER          NOT NULL,
    prod_id        CHAR(10)         NOT NULL,
    quantity       INTEGER          NOT NULL      DEFAULT 1,
    item_price     DECIMAL(8,2)     NOT NULL
);

/* 更新表结构 */
ALTER TABLE Vendors
ADD vend_phone CHAR(128);

ALTER TABLE Vendors
DROP COLUMN vend_phone;

/* 删除表 */
DROP TABLE CustCopy;&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;strong&gt;15. 视图&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class="highlight line-numbers"&gt;&lt;code class="language-sql"&gt;/* 虚拟的表 */
CREATE VIEW ProductCustomers AS
SELECT cust_name, cust_contact, prod_id
FROM Customers, Orders, OrderItems
WHERE Customers.cust_id = Orders.cust_id
AND OrderItems.order_num = Orders.order_num;&lt;/code&gt;&lt;/pre&gt;</content></entry></feed>