<!DOCTYPE html>
<html lang="zh">
    <head>
          <meta charset="utf-8" />
        <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />


        <title>
数据结构(Python描述) 第 6 章 二叉树与树        </title>


        <meta name="HandheldFriendly" content="True" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="referrer" content="origin" />
        <meta name="generator" content="Pelican" />
        <link
            rel="icon"
            type="image/png"
            href="/assets/images/favicon.png"
        />
        <link href="/" rel="canonical" />

        <!-- Feed -->
         
        <link
            href="/theme/css/style.css"
            type="text/css"
            rel="stylesheet"
        />

        <!-- Code highlight color scheme -->
        <link
            href="/theme/css/code_blocks/github.css"
            rel="stylesheet"
        />
         <!-- CSS specified by the user -->
  
        <link href="/assets/css/prism.css" type="text/css" rel="stylesheet" />
  
        <link href="/assets/css/base.css" type="text/css" rel="stylesheet" />
  
        <link href="/assets/css/base-control.css" type="text/css" rel="stylesheet" />
  
        <link href="/assets/css/github.css" type="text/css" rel="stylesheet" />
  
        <link href="/assets/css/codemirror.css" type="text/css" rel="stylesheet" />
  
        <link href="/assets/css/ivicel.css" type="text/css" rel="stylesheet" />
 
        <!-- Custom fonts -->
        <link
            href="https://fonts.googleapis.com/css?family=Montserrat:400,300"
            rel="stylesheet"
            type="text/css"
        />
        <link
            href="https://fonts.googleapis.com/css?family=Lato"
            rel="stylesheet"
            type="text/css"
        />

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->


  <link href="/shu-ju-jie-gou-pythonmiao-shu-di-6-zhang-er-cha-shu-yu-shu.html" rel="canonical" />

    <meta name="description" content="1. 二叉树 1.1 概念 不包含任何结点的称为 空树 , 只包含一个结点称为 单点树 没有子结点的称为 树叶 , 非树叶结点称为 分支结点 , 对于二叉树有左分支 , 右分支 一个结点的子结点个数称为该结点的 度数 , 很明显度只能取 [0, 1, 2] 三个值 路径...">

    <meta name="author" content="ivicel">

    <meta name="tags" content="二叉树">
    <meta name="tags" content="树">
    <meta name="tags" content="堆">




<!-- Open Graph -->
<meta property="og:site_name" content="Ambertime"/>
<meta property="og:title" content="数据结构(Python描述) 第 6 章 二叉树与树"/>
<meta property="og:description" content="1. 二叉树 1.1 概念 不包含任何结点的称为 空树 , 只包含一个结点称为 单点树 没有子结点的称为 树叶 , 非树叶结点称为 分支结点 , 对于二叉树有左分支 , 右分支 一个结点的子结点个数称为该结点的 度数 , 很明显度只能取 [0, 1, 2] 三个值 路径..."/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="/shu-ju-jie-gou-pythonmiao-shu-di-6-zhang-er-cha-shu-yu-shu.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2018-07-30 00:00:00+08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="/author/ivicel.html">
<meta property="article:section" content="misc"/>
<meta property="article:tag" content="二叉树"/>
<meta property="article:tag" content="树"/>
<meta property="article:tag" content="堆"/>
<meta property="og:image" content="/theme/images/post-bg.jpg">

<!-- Twitter Card -->

<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "name": "数据结构(Python描述) 第 6 章 二叉树与树",
  "headline": "数据结构(Python描述) 第 6 章 二叉树与树",
  "datePublished": "2018-07-30 00:00:00+08:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "ivicel",
    "url": "/author/ivicel.html"
  },
  "image": "/theme/images/post-bg.jpg",
  "url": "/shu-ju-jie-gou-pythonmiao-shu-di-6-zhang-er-cha-shu-yu-shu.html",
  "description": "1. 二叉树 1.1 概念 不包含任何结点的称为 空树 , 只包含一个结点称为 单点树 没有子结点的称为 树叶 , 非树叶结点称为 分支结点 , 对于二叉树有左分支 , 右分支 一个结点的子结点个数称为该结点的 度数 , 很明显度只能取 [0, 1, 2] 三个值 路径..."
}
</script>    </head>
    <!-- TODO : Body class -->
    <body class="home-template">
<nav id="menu">
  <a class="close-button">Close</a>
  <div class="nav-wrapper">
    <p class="nav-label">Menu</p>
    <ul>

              <li role="presentation"><a href="/pages/about.html">About</a></li>
              <li role="presentation"><a href="/pages/archives.html">Archives</a></li>
              <li role="presentation"><a href="/pages/category.html">Category</a></li>

    </ul>
  </div>
</nav>     <!-- Progressbar -->
    <div class="progress-container">
        <span class="progress-bar"></span>
    </div>

    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
    <header id="blog-header" >
      <div class="inner">
        <nav id="navigation">
            <span id="home-button" class="nav-button">
                <a class="home-button" href="/" title="Home"><i class="ic ic-arrow-left"></i> Home</a>
            </span>
          <span id="menu-button" class="nav-button">
            <a class="menu-button"><i class="ic ic-menu"></i> Menu</a>
          </span>
        </nav>
        <h1 class="post-title">数据结构(Python描述) 第 6 章 二叉树与树</h1>
        <!-- TODO : Proper class for headline -->
        <span class="post-meta">
                <a href="/author/ivicel.html">Ivicel</a>
            | <time datetime="Mon 30 July 2018">Mon 30 July 2018</time>
        </span>
        <!-- TODO : Modified check -->
      </div>
    </header>

        <section id="wrapper">
            <a class="hidden-close"></a>

    <!-- Post content -->
    <main class="content" role="main">
        <article class="post">
        <div class="inner">
            <section class="post-content">
                <h4 id="1">1. 二叉树 </h4>
<h5 id="11">1.1 概念 </h5>
<ul>
<li> 不包含任何结点的称为 <strong> 空树 </strong>, 只包含一个结点称为 <strong> 单点树 </strong></li>
<li> 没有子结点的称为 <strong> 树叶 </strong>, 非树叶结点称为 <strong> 分支结点 </strong>, 对于二叉树有左分支 , 右分支 </li>
<li> 一个结点的子结点个数称为该结点的 <strong> 度数 </strong>, 很明显度只能取 <code>[0, 1, 2]</code> 三个值 </li>
<li><strong> 路径 </strong>: 从祖先结点到子孙结点包含的一系列边 , 称为路径 . </li>
<li> 二叉树是分层的 , 根结点所在为第 0 层 . 树中结点的最大层数称为树的 <strong> 高度 </strong></li>
<li><strong> 满二叉树 </strong>: 二叉树中的所有分支结点的度数都是 2</li>
<li><strong> 扩充二叉树 </strong>: 对于二叉树 T, 加入足够多的新的结点 , 使 T 原有的结点的度都变成 2, 得到的这棵新树称为扩充二叉树 . 扩充二叉树新加入的结点称为 <strong> 外部结点 </strong>, 原来的结点称为 <strong> 内部结点 </strong></li>
<li><strong> 完全二叉树 </strong>: 对于高度为 h 的二叉树 , 其 h - 1 层及到根都是满结点的 , 并且在 h 层的结点是从左向右填 , 数量不定 . 这说明满二叉树一定是棵完全二叉树 </li>
</ul>
<h5 id="12">1.2 性质 </h5>
<ul>
<li> 在非空叉树第 i 层最多有 <code>2&lt;sup&gt;i&lt;/sup&gt; (i &gt;= 0)</code> 个结点 </li>
<li> 高度为 h 的二叉树 , 最多有 <code>2&lt;sup&gt;h+1&lt;/sup&gt; - 1 (h &gt;= 0)</code> 个结点 . 这其实是上面的一个推论 , 如果每层都 是满的 , 那么则有 <code>S = 1 + 2 + 4 + ... + 2&lt;sup&gt;h&lt;/sup&gt;</code>, 则有 <code>2S  - S = 2&lt;sup&gt;h+1&lt;/sup&gt; - 1</code></li>
<li> 对于任何非空二叉树 T, 如果其叶结点个数为 <code>n&lt;sub&gt;0&lt;/sub&gt;</code>, 度数为 2 的结点个数为 <code>n&lt;sub&gt;2&lt;/sub&gt;</code>, 那么有 <code>n&lt;sub&gt;0&lt;/sub&gt; = n&lt;sub&gt;2&lt;/sub&gt; + 1</code></li>
<li> 满二叉树中 , 分支结点比叶子结点多一个 , 这是上面的推论 </li>
<li> 扩充二叉树根到各个外部结点的路径和 E 与根到各个内部结点的路径和 I, 有 <code>E = I + 2 * n</code>, 其中 n 为内部结点个数 </li>
<li>n 个结点的完全二叉树 , 其高度 <code>h &lt;= log&lt;sub&gt;2&lt;/sub&gt; n</code>, 即 <code>h = floor(log&lt;sub&gt;2&lt;/sub&gt;N</code>. 这是很容易证明 , 对于一棵满二叉树 , 其结点数有 <code>n = 2&lt;sup&gt;h + 1&lt;/sup&gt; - 1</code>, 那么对于完全二叉树则有 <code>2&lt;sup&gt;h&lt;/sup&gt; &lt;= n &lt;= 2&lt;sup&gt;h + 1&lt;/sup&gt; - 1</code>, h, n 都是整数 , 则 h 是不大于 <code>log&lt;sub&gt;2&lt;/sub&gt;N</code> 的整数 </li>
<li> 在完全二叉树 , 对于任意结点 <code>i (0 &lt;= i &lt;= n - 1, n 为结点总数 )</code>, 其左子结点 ( 如果有 ) 为 <code>2 * i + 1</code>, 右子结点 ( 如果有 ) 为 <code>2 * i + 1</code>. 我们还可以算出该结点的父结点 ( 如果有 ) 位置为 <code>floor((i - 1) / 2)</code>. 这是由上面推出来的 , 父结点位置应该在区间 <code>((j - 2) / 2, (j - 1) / 2)</code> 并且是一个整数 , 所以对这两个边界作向上或向下取整即可 </li>
</ul>
<h5 id="13">1.3 遍历方式 </h5>
<ul>
<li><strong> 深度优先遍历 </strong>, 这种遍历方法 , 在使用非递归实现时 , 由于先有上层才有下层 , 但我们是要先访问下层 , 所以是一个 <strong> 后进先出 (LIFO)</strong> 的栈结构 .</li>
</ul>
<blockquote>
<p> 记忆技巧 : 三种方法区别方式都是对根来说的 , 对于每一棵树 , 都最多只有三个结点 , 就是 根 , 左结点 , 右结点 , 对于每一棵子树 , 我们都要执行一样的遍历顺序 </p>
</blockquote>
<ul>
<li>
<p><strong> 先根序遍历 Pre-order</strong>: 根 -&gt; 左 -&gt; 右 . 在非递归的方法中 , 使用一个辅助栈来保存上层的结点信息 . 因为要先访问左结点要再访问右结点 . 从栈内弹出结点的顺序就是我们要的遍历顺序 , 当栈中为空的时候就完成遍历 .</p>
<ol>
<li><strong> 循环体外先把根结点入栈 </strong></li>
<li>
<p> 循环判断栈是否为空 , 不为空的话 , 弹出栈中结点 , 对该节点 node 调用访问函数 </p>
</li>
<li>
<p> 如果 node 有右结点 , 则右结点入栈 </p>
</li>
<li>
<p> 如果 node 有左结点 , 则左结点入栈 . 回到第 2 步 </p>
</li>
<li> 一直判断栈中没有节点为止 </li>
</ol>
<pre class="highlight"><code class="language-c linenums">void preorder(BinaryTree *tree)
{
    if (tree == NULL || tree-&gt;root == NULL) {
        return;
    }

    Stack *stack = (Stack *)malloc(sizeof(Stack));
    if (stack == NULL) {
        return;
    }
    stack-&gt;push(tree-&gt;root);
    Node *node = NULL;
    while (!stack-&gt;isEmpty()) {
        node = stack-&gt;pop();
        process(node);
        if (node-&gt;right != NULL) {
            stack-&gt;push(node-&gt;right);   
        }

        if (node-&gt;left != NULL) {
            stack-&gt;push(node-&gt;left);
        }
    }
    free(stack);
}</code></pre>

</li>
<li>
<p><strong> 中根序遍历 In-order</strong>: 左 -&gt; 根 -&gt; 右 . 依旧还使用一个栈作为辅助 , 由于要保存父结点的信息 , 所以父结点必须要入栈 , 然后再向下访问左结点 , 但当我们从栈中 <code>pop</code> 出父结点时 , 处理完后 , 不能再访问其左结点 , 避免造成死循环 </p>
<ol>
<li> 设置一个变量 node, node 首先指向树的根结点 , 设置一个栈 </li>
<li> 循环判断当 栈不为空 , 或者 node 指向不为 <code>NULL</code> </li>
<li> 当 node 不为空 , 我们把这个当作一个父结点入栈 , 然后把 node 指向 node 的左结点 , 回到循环条件 . 此时 , 栈中已经有至少一个结点 , 条件成立 </li>
<li> 如果 node 此时指向 <code>NULL</code>, 说明 node 往下再没有左子结点 </li>
<li> 处理 node , 然后把 node 指向 node 的右子结点 , 回到 循环条件 </li>
<li> 这样通过两个条件先向下查找 , 到底后再弹出 , 弹出再查找其右结点 </li>
</ol>
<pre class="highlight"><code class="language-c linenums">void inorder(BinaryTree *tree)
{
    Stack *stack = (Stack *)malloc(sizeof(Stack));
    if (stack == NULL) {
        return;
    }
    Node *node = tree-&gt;root;
    while (!stack.isEmpty() || node != NULL) {
        if (node != NULL) {
            stack-&gt;push(node);
            node = node-&gt;left;
        } else {
            process(node);
            node = node-&gt;right;
        }
    }
    free(stack);
}</code></pre>

</li>
<li>
<p><strong> 后根序遍历 Post-order</strong>: 左 -&gt; 右 -&gt; 根 . </p>
<ul>
<li> 简单方法 , 使用两个栈 : 我们使用容易的对 <strong> 前序遍历 </strong> 稍加修改便可以得到一个 <strong> 根 -&gt; 右 -&gt; 左 </strong> 访问顺序栈 s1, 然后依次把这个遍历压入另一个栈 s2 中 , 当 s1 遍历完成时 , 对 s2 进行遍历我们便得到一个 <strong> 左 -&gt; 右 -&gt; 根 </strong> 的遍历顺序 </li>
</ul>
<pre class="highlight"><code class="language-c linenums">void postorder(BinaryTree *tree)
{
    if (tree == NULL || tree-&gt;root == NULL) {
        return;
    }

    Stack *s1 = (Stack *)malloc(sizeof(Stack));
    Stack *s2 = (Stack *)malloc(sizeof(Stack));
    if (s1 == NULL || s2 == NULL) {
        if (s2 == NULL) {
            free(s1);
        }
        return;
    }


    Node *node;
    s1-&gt;push(tree-&gt;root);
    while (!s1-&gt;isEmpty()) {
        node = s1-&gt;pop();
        s2-&gt;push(node);
        if (s1-&gt;left != NULL) {
            s2-&gt;push(node-&gt;left);
        }
        if (s1-&gt;right != NULL) {
            s2-&gt;push(node-&gt;right)
        }
    }

    while (!s2-&gt;isEmpty()) {
        process(s2-&gt;pop())
    }
}</code></pre>

</li>
</ul>
<blockquote>
<p> 当使用递归方式遍历时 , 每次我们都是递归左子树再递归又子树 , 所以这两次递归中 , 每层函数在栈中都保存有递归节点 , 不同的遍历方式只是体现在 , 处理访问节点的时机不两路 ;</p>
<pre class="highlight"><code class="language-c linenums">void preorder(Node *node)
{
    if (node == NULL) {
        return;
    }
    process(node);
    preorder(node-&gt;left);
    preorder(node-&gt;right);
}

void inorder(Node *node)
{
    if (node == NULL) {
        return;
    }
    inorder(node-&gt;left);
    process(node);
    inorder(node-&gt;right);
}

void postorder(Node *node)
{
    if (node == NULL) {
        return;
    }
    postorder(node-&gt;left);
    process(node);
    postorder(node-&gt;right);
}</code></pre>

</blockquote>
<ul>
<li><strong> 宽度优先遍历 </strong>: 把每一层的所有结点都访问完 , 再访问下层 . 一般我们都从同层的左边结点开始 </li>
</ul>
<h4 id="2">2. 优先队列 </h4>
<p> 优先队列是一种带权值的队列 , 队列总保持一种可以按优先级的访问顺序 . 根据需要从高到低或从低到高 </p>
<h5 id="21">2.1 基于线性表的实现 </h5>
<p> 如果基于线表来实现优先队列 , 从外部使用角度看 , 我们只关心每一次出队的元素都是队列中优先级最高的 , 向其中插入值时 , 按优先级排到队列中最合适的位置 . 这样插入的话可能出产生 <code>O(n)</code>, 取出都是 <code>O(1)</code>. 我们也可以不保持队列的存储顺序 , 在取出时再查找最优先元素 . 这样插入是 <code>O(1)</code>, 取出是 <code>O(n)</code></p>
<h5 id="22">2.2 基于树形结构的实现 </h5>
<ul>
<li><strong> 堆 </strong>: 堆是一种完全二叉树 , 其有一个主要性质 , 从任意一条 <strong> 根 -&gt; 叶子结点的这条路径 </strong>, 总有 <strong> 父结点 &gt; 子结点 </strong> 的叫 <strong> 最大堆 </strong>, 反之叫 <strong> 最小堆 </strong>. 同一兄弟结点没有特定的大小关系 </li>
<li><strong> 向上筛选 </strong>: 向堆中末尾插入一个结点 , 这个结点跟其父结点比较大小 , 根据需要来交换位置 , 依次循环这两个操作 , 直到确定位置 , 或者到根结点 </li>
<li><strong> 向下筛选 </strong>: 当我们拿走根结点后 , 其两个子树依然还是两个堆 , 这样我们从原堆中取出最后一个结点 , 因为我们取出最后一个结点 , 堆序是不变 . 把这个结点当作新的根结点 , 形成新的二叉树 . 对比两个左右子结点 , 找到最小或大 ( 根据堆序 ) 的 , 然后跟根结点比较 , 如果根结点大小不合适 , 那么交换这两结点 , 然后在新的子树层里 , 重复上两步比较操作 . 这看起来就像结点在往树底下移动 .</li>
</ul>
<p> 完全二叉树可以用一个线性的结构来表示 , 我们只关心其父子结点的位置 , 对于一个结点 i, 其左结点就是 <code>2 * i + 1</code>, 右结点就是 <code>2 * i + 2</code>, 其父结点就是 <code>floor((i - 1) / 2)</code>. 所以用一个数组很容易的表示堆 , 并且每个结点的访问都是 <code>O(1)</code>.</p>
            </section>

            <section class="post-info">
                <div class="post-share">
                    <a class="twitter" href="https://twitter.com/share?text=数据结构(Python描述) 第 6 章 二叉树与树&amp;url=/shu-ju-jie-gou-pythonmiao-shu-di-6-zhang-er-cha-shu-yu-shu.html" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <i class="ic ic-twitter"></i><span class="hidden">Twitter</span>
                    </a>
                    <a class="facebook" href="https://www.facebook.com/sharer/sharer.php?u=/shu-ju-jie-gou-pythonmiao-shu-di-6-zhang-er-cha-shu-yu-shu.html" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <i class="ic ic-facebook"></i><span class="hidden">Facebook</span>
                    </a>
                    <a class="googleplus" href="https://plus.google.com/share?url=/shu-ju-jie-gou-pythonmiao-shu-di-6-zhang-er-cha-shu-yu-shu.html" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <i class="ic ic-googleplus"></i><span class="hidden">Google+</span>
                    </a>
                    <div class="clear"></div>
                </div>

                <aside class="post-tags">
<a href="/tag/er-cha-shu.html">二叉树</a><a href="/tag/shu.html">树</a><a href="/tag/dui.html">堆</a>                </aside>

                <div class="clear"></div>


                </section>


                <aside class="post-nav">
                    <div class="clear"></div>
                </aside>

            </div>
        </article>
    </main>
            <!-- TODO : Body class -->
            <div
                id="body-class"
                style="display: none;"
                class=""
            ></div>

            <footer id="footer">
                <div class="inner">
                    <section class="credits">
      
                        <span class="credits-theme">Theme
                        <a
                            href="https://github.com/arulrajnet/attila"
                            rel="nofollow"
                            >Attila</a
                        ></span>
                        <span class="credits-software">Published with
                        <a
                            href="https://github.com/getpelican/pelican"
                            rel="nofollow"
                            >Pelican</a
                        ></span>
                    </section>
                </div>
            </footer>
        </section>

        <script
            type="text/javascript"
            src="/theme/js/script.js"
        ></script>

        <!-- Script specified by the user -->
           <script type="text/javascript" src="/assets/js/prism.js"></script>
       </body>
</html>